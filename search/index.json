
{
    
    
    
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
    "pages": [{"date":"2023-04-25","image":"","imageAlt":"","link":"https://adrianherrera.github.io/pages/talks/","summary":"Talks I\u0026rsquo;ve given.\nThe Hitchhiker\u0026rsquo;s Guide to Fuzzer Coverage Metrics. Australasian Software Engineering Summer School (ASESS), 2024.\nHot Fuzz: \u0026ldquo;We\u0026rsquo;ve got grey, or\u0026hellip; white[box fuzzers]\u0026rdquo;. Australian Reverse Engineering and Vulnerability Research (AUREVR), 2022.\nSeed Selection for Successful Fuzzing. CSIRO\u0026rsquo;s Data61 \u0026amp; DST Cyber Security Summer School (CSSS), 2022.\nAnalyzing Trigger-Based Malware with S2E. Malware Reverse Engineering (MRE), 2019.\nOptimizing Away JavaScript Obfuscation. BSides Canberra, 2019.\nProgram Analysis for Reverse Engineers: from ⊤ to ⊥.","tags":[],"text":"talks i\u0026rsquo;ve given.\nthe hitchhiker\u0026rsquo;s guide to fuzzer coverage metrics. australasian software engineering summer school (asess), 2024.\nhot fuzz: \u0026ldquo;we\u0026rsquo;ve got grey, or\u0026hellip; white[box fuzzers]\u0026rdquo;. australian reverse engineering and vulnerability research (aurevr), 2022.\nseed selection for successful fuzzing. csiro\u0026rsquo;s data61 \u0026amp; dst cyber security summer school (csss), 2022.\nanalyzing trigger-based malware with s2e. malware reverse engineering (mre), 2019.\noptimizing away javascript obfuscation. bsides canberra, 2019.\nprogram analysis for reverse engineers: from ⊤ to ⊥. bsides canberra, 2018.\n","title":"Talks"},{"date":"2023-03-05","image":"","imageAlt":"","link":"https://adrianherrera.github.io/pages/academics/","summary":"A summary of my academic endeavours.\nPublications Conference Proceedings Workshop Proceedings Journal Publications Technical Reports Service Publications Conference Proceedings Make out like a (Multi-Armed) Bandit: Improving the Odds of Fuzzer Seed Scheduling with T-Scheduler. Simon Luo, Adrian Herrera, Paul Quirk, Michael Chase, Damith C. Ranasinghe, and Salil S. Kanhere. Asia Computer and Communications Security (AsiaCCS), 2024.\nEvocatio: Conjuring Bug Capabilities from a Single PoC. Zhiyuan Jiang, Shuitao Gan, Adrian Herrera, Flavio Toffalini, Lucio Romerio, Chaojing Tang, Manuel Egele, Chao Zhang, and Mathias Payer.","tags":[],"text":"a summary of my academic endeavours.\npublications conference proceedings workshop proceedings journal publications technical reports service publications conference proceedings make out like a (multi-armed) bandit: improving the odds of fuzzer seed scheduling with t-scheduler. simon luo, adrian herrera, paul quirk, michael chase, damith c. ranasinghe, and salil s. kanhere. asia computer and communications security (asiaccs), 2024.\nevocatio: conjuring bug capabilities from a single poc. zhiyuan jiang, shuitao gan, adrian herrera, flavio toffalini, lucio romerio, chaojing tang, manuel egele, chao zhang, and mathias payer. computer and communications security (ccs), 2022.\nseed selection for successful fuzzing. adrian herrera, hendra gunadi, shane magrath, michael norrish, mathias payer, and antony l. hosking. international symposium on software testing and analysis (issta), 2021.\nmagma: a ground-truth fuzzing benchmark. ahmad hazimeh, adrian herrera, and mathias payer. sigmetrics, 2021.\njmd: a hybrid approach for detecting java malware. adrian herrera and ben cheney. australiasian information security conference (aisc), 2015.\na key distribution protocol for wireless sensor networks. adrian herrera and wen hu. local computer networks (lcn), 2012.\nworkshop proceedings registered report: dataflow - towards a data-flow-guided fuzzer. adrian herrera, mathias payer, and antony l. hosking. international fuzzing workshop (fuzzing), 2022.\noptimizing away javascript obfuscation. adrian herrera. source code analysis and manipulation (scam), 2020.\njournal publications dataflow: toward a data-flow-guided fuzzer. adrian herrera, mathias payer, and antony l. hosking. transactions on software engineering methodologies (tosem), 2023.\ndiscover deeper bugs with dynamic symbolic execution and coverage-based fuzz testing. bin zhang, chao feng, adrian herrera, vitaly chipounov, george candea, and chaojing tang. iet software, 2018.\ntechnical reports how secure is the next-generation internet? an examination of ipv6. adrian herrera. defence science and technology group (dstg) technical report. service artifact evaluation committee, workshop on offensive technologies (woot), 2023. technical reviewer, fuzzing against the machine: automated vulnerability research with emulated iot devices on qemu, 2022. artifact evaluation committee, international fuzzing workshop (fuzzing), 2022. organizing committee, csiro\u0026rsquo;s data61 \u0026amp; dstg cyber security summer school (csss), 2022. organizing committee, international summer school on information security and protection (issip), 2018. ","title":"Academics"},{"date":"2018-09-02","image":"","imageAlt":"","link":"https://adrianherrera.github.io/posts/malware-s2e/","summary":"Introduction This blog post is a quick brain-dump of the work that I was doing during my last month in the Dependable Systems Lab at EPFL. At the time I was working on malware analysis with S2E. While not anything earth-shatteringly novel, I\u0026rsquo;m hopeful that this post will help others who want to use symbolic execution/S2E to analyse malware behaviour.\nWhat makes malware analysis different? My previous blog posts have looked at solving a CTF challenge and analysing file parsers.","tags":["malware analysis","s2e","symbolic execution"],"text":"introduction this blog post is a quick brain-dump of the work that i was doing during my last month in the dependable systems lab at epfl. at the time i was working on malware analysis with s2e. while not anything earth-shatteringly novel, i\u0026rsquo;m hopeful that this post will help others who want to use symbolic execution/s2e to analyse malware behaviour.\nwhat makes malware analysis different? my previous blog posts have looked at solving a ctf challenge and analysing file parsers. these programs had two things in common:\nthey were linux elf executables; and program input was specified by the user — either via stdin or from a file that was read from disk. in contrast, most malware:\ntargets windows (while some reports suggest that android malware is on the rise, windows remains the primary target for malware authors); and does not have a well defined input source. input could come from command-line arguments, but this is uncommon. input is more likely to come from registry keys, network data, etc. for these reasons, analysing malware in s2e is not as simple as making command-line arguments symbolic, or feeding the program a symbolic file. this blog post will walk through the s2e-based tools that we developed for malware analysis, followed by two \u0026ldquo;case studies\u0026rdquo;. as usual, if you wish to play along at home you can find all of the code on github.\nanalysing windows software in s2e up until now, we have only analysed linux programs. fortunately, s2e also supports the analysis of windows programs. so what\u0026rsquo;s the difference?\nwhen building a windows guest image, a windows iso must be provided to the image_build command. isos for all versions of windows supported by s2e (listed here) can be downloaded from msdn. it is also possible to add support for other versions if required. for this post we\u0026rsquo;ll use windows 7 professional 32-bit. there is no equivalent to s2e.so on windows. therefore, we\u0026rsquo;ll need an alternative approach to inject symbolic data into our malware. we could write an s2e plugin to do this, but this is complex. instead, we\u0026rsquo;ll use dll injection in the guest to hook windows api calls and inject symbolic data through these hooks. hooking the windows api there are many different techniques for hooking the windows api. we\u0026rsquo;ll use an \u0026ldquo;off the shelf\u0026rdquo; solution rather than (re)inventing a new one. when i first started this work, i wanted to reuse cuckoo sandbox\u0026rsquo;s monitor for api hooking (as it was designed for malware analysis). however, we decided to use easyhook instead, primarily because it required less work to get started with.\nbefore we dive into some code, here\u0026rsquo;s an overview of what we are going to build:\nmalware-inject: a program that will start other programs (e.g. malware) and inject a dll into the newly-started process\u0026rsquo; address space; and malware-hook: a dll that is injected into a process\u0026rsquo; address space via malware-inject. this dll will hook key functions from the windows api, providing us with a mechanism to inject symbolic data. now let\u0026rsquo;s dive into some code!\nwe\u0026rsquo;ll start by opening $s2edir/source/s2e/guest/windows/s2e.sln in visual studio and creating two new projects:\nmalware-inject: a win32 console application; and malware-hook: a win32 dll. both projects require the easyhook native package, installable via nuget. note that in the github repo the malware-hook project is split into getlocaltime-hook and wannacry-hook projects (our two case studies).\nmalware-inject malware-inject is based on easyhook\u0026rsquo;s example injector application. however, instead of using rhinjectlibrary (which injects a dll into an already-running process), we\u0026rsquo;ll use rhcreateandinject. this function starts an application in a suspended state, injects a dll and then resumes the suspended process. malware-inject will also wait for the injected process to complete before returning. this is useful because it prevents s2e killing states when the malware-inject process exits.\ncreate inject.c and add the following code to it:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;easyhook.h\u0026gt; // we must add this header file to support writing to s2e\u0026#39;s logs. s2e.h resides // in the libcommon project, so the libcommon project must be added as a // dependency to the malware-inject project #define user_app #include \u0026lt;s2e/s2e.h\u0026gt; #define s2e_msg_len 512 #define max_path_len 256 static int s2eversion = 0; static void message(lpcstr fmt, ...) { char message[s2e_msg_len]; va_list args; va_start(args, fmt); vsnprintf(message, s2e_msg_len, fmt, args); va_end(args); if (s2eversion) { s2emessagefmt(\u0026#34;[malware-inject] %s\u0026#34;, message); } else { printf(\u0026#34;[malware-inject] %s\u0026#34;, message); } } static void getfullpath(lpcwstr path, pwchar fullpath) { if (!path) { message(\u0026#34;path has not been provided\\n\u0026#34;); exit(1); } if (!pathfileexistsw(path)) { message(\u0026#34;invalid path %s has been provided\\n\u0026#34;, path); exit(1); } if (!getfullpathnamew(path, max_path_len, fullpath, null)) { message(\u0026#34;unable to get full path of %s\\n\u0026#34;, path); exit(1); } } int main() { int argc; lpwstr *argv = commandlinetoargvw(getcommandlinew(), \u0026amp;argc); if (argc \u0026lt; 5) { printf(\u0026#34;usage: %s [options..]\\n\u0026#34; \u0026#34; --dll \u0026lt;dll\u0026gt; path to dll to inject into the application\\n\u0026#34; \u0026#34; --app \u0026lt;target\u0026gt; path to application to start\\n\u0026#34; \u0026#34; --timeout \u0026lt;time\u0026gt; timeout value in milliseconds \u0026#34; \u0026#34;(infinite if not provided)\\n\u0026#34;, argv[0]); exit(1); } // used by the message function to decide where to write output to s2eversion = s2egetversion(); lpwstr dllpath = null; wchar fulldllpath[max_path_len]; lpwstr apppath = null; wchar fullapppath[max_path_len]; dword timeout = infinite; for (int i = 1; i \u0026lt; argc; ++i) { if (wcscmp(argv[i], l\u0026#34;--dll\u0026#34;) == 0) { dllpath = argv[++i]; continue; } if (wcscmp(argv[i], l\u0026#34;--app\u0026#34;) == 0) { apppath = argv[++i]; continue; } if (wcscmp(argv[i], l\u0026#34;--timeout\u0026#34;) == 0) { timeout = wcstoul(argv[++i], null, 10); continue; } message(\u0026#34;unsupported argument: %s\\n\u0026#34;, argv[i]); exit(1); } // check that the given paths are valid getfullpath(dllpath, fulldllpath); getfullpath(apppath, fullapppath); // start the target application (in a suspended state) and inject the given dll ulong pid; ntstatus result = rhcreateandinject(apppath, l\u0026#34;\u0026#34;, create_suspended, easyhook_inject_default, #if defined(_m_ix86) dllpath, null, #elif defined(_m_x64) null, dllpath, #else #error \u0026#34;platform not supported\u0026#34; #endif null, 0, \u0026amp;pid); if (failed(result)) { message(\u0026#34;rhcreateandinject failed: %s\\n\u0026#34;, rtlgetlasterrorstring()); exit(1); } message(\u0026#34;successfully injected %s into %s (pid=0x%x)\\n\u0026#34;, fulldllpath, fullapppath, pid); dword exitcode = 1; // get a handle to the newly-created process and wait for it to terminate. // once the process has terminated, get its return code and return that as // our return code handle hprocess = openprocess(synchronize | process_query_information, false, pid); if (hprocess) { waitforsingleobject(hprocess, timeout); getexitcodeprocess(hprocess, \u0026amp;exitcode); closehandle(hprocess); } else { message(\u0026#34;unable to open process 0x%x: 0x%x\\n\u0026#34;, pid, getlasterror()); } return exitcode; } of course, it is entirely possible that the malware will be watching for api hooks (we are dealing with malicious software after all!). whilst an important issue, we won\u0026rsquo;t deal with it in this post.\nnow that we\u0026rsquo;ve written the tool to run our malware with an injected dll, let\u0026rsquo;s turn our attention to what this dll actually does.\nmalware-hook likewise, we\u0026rsquo;ll base malware-hook on easyhook\u0026rsquo;s example beephook dll. here is the skeleton of our hook dll, which we\u0026rsquo;ll put in malware-hook.cpp:\n#include \u0026lt;windows.h\u0026gt; #include \u0026lt;strsafe.h\u0026gt; #include \u0026lt;easyhook.h\u0026gt; #define user_app extern \u0026#34;c\u0026#34; { #include \u0026lt;s2e/s2e.h\u0026gt; } #define s2e_msg_len 512 static int s2eversion = 0; static void message(lpcstr fmt, ...) { char message[s2e_msg_len]; va_list args; va_start(args, fmt); vsnprintf(message, s2e_msg_len, fmt, args); va_end(args); if (s2eversion) { s2emessagefmt(\u0026#34;[0x%x|malware-hook] %s\u0026#34;, getcurrentprocessid(), message); } else { printf(\u0026#34;[0x%x|malware-hook] %s\u0026#34;, getcurrentprocessid(), message); } } // easyhook will be looking for this export to support dll injection. if not // found then dll injection will fail extern \u0026#34;c\u0026#34; void __declspec(dllexport) __stdcall nativeinjectionentrypoint(remote_entry_info *); void __stdcall nativeinjectionentrypoint(remote_entry_info *inremoteinfo) { // unused (void*) inremoteinfo; // used by the message function to decide where to write output to s2eversion = s2egetversion(); // todo initialize hooks // the process was started in a suspended state. wake it up... rhwakeupprocess(); } so, what are we going to hook? let\u0026rsquo;s take some inspiration from two great papers on this topic: david brumley\u0026rsquo;s \u0026ldquo;automatically identifying trigger-based behaviour in malware\u0026rdquo; and andreas moser\u0026rsquo;s \u0026ldquo;exploring multiple execution paths for malware analysis\u0026rdquo;. both of these papers look at \u0026ldquo;trigger-based malware\u0026rdquo;, which is malware whose malicious actions only occur under specific circumstances; i.e. when certain trigger conditions are met. for example, malware may only launch its payload on a specific date (as the mydoom worm did), or upon receiving specific data from a command \u0026amp; control server. in these two examples, the trigger sources are the current date/time and data read from a network. other trigger sources include (as listed in moser\u0026rsquo;s paper):\ninternet connectivity; mutex objects; existence of files; existence of registry entries; and data read from a file. how can we analyse trigger-based malware? brumley\u0026rsquo;s paper proposed minesweeper, a tool designed to detect the existence of trigger-based behaviours and to find inputs that exercise these behaviours. as far as i can tell, minesweeper was never publicly released. however, we can build a very similar system in s2e using our malware-hook dll! so let\u0026rsquo;s go ahead and create hooks for some of the trigger sources discussed in these two papers.\ncase study 1: getlocaltime-test the first trigger source that brumley\u0026rsquo;s paper explores is getlocaltime. getlocaltime has the following prototype:\nvoid winapi getlocaltime( _out_ lpsystemtime lpsystemtime ); in minesweeper, the user was required to specify where in memory the trigger inputs will be stored. this was so the symbolic execution engine could properly assign symbolic variables during execution. in the case of getlocaltime, this would require specifying that getlocaltime stores its result in a 16-byte structure pointed to by a stack value when getlocaltime is called. fortunately, we don\u0026rsquo;t have to worry about these low-level details. instead, we can just call s2emakesymbolic on the variable we pass to getlocaltime. here\u0026rsquo;s how we do this in malware-hook:\n// function hooks static void winapi getlocaltimehook(lpsystemtime lpsystemtime) { message(\u0026#34;intercepted getlocaltime\\n\u0026#34;); // call the original getlocaltime to get a concrete value getlocaltime(lpsystemtime); // make the value concolic s2emakesymbolic(lpsystemtime, sizeof(*lpsystemtime), \u0026#34;systemtime\u0026#34;); } // the names of the functions to hook (and the library they belong to) static lpcstr functionstohook[][2] = { { \u0026#34;kernel32\u0026#34;, \u0026#34;getlocaltime\u0026#34;} , { null, null }, }; // the function hooks that we will install static pvoid hookfunctions[] = { getlocaltimehook, }; // the actual hooks static hook_trace_info hooks[] = { { null }, }; // this function was defined previously void __stdcall nativeinjectionentrypoint(remote_entry_info *inremoteinfo) { // ... // replace the previous todo with the following code to install the getlocaltime hook for (unsigned i = 0; functionstohook[i][0] != null; ++i) { lpcstr modulename = functionstohook[i][0]; lpcstr functionname = functionstohook[i][1]; // install the hook ntstatus result = lhinstallhook( getprocaddress(getmodulehandlea(modulename), functionname), hookfunctions[i], null, \u0026amp;hooks[i]); if (failed(result)) { message(\u0026#34;failed to hook %s.%s: %s\\n\u0026#34;, modulename, functionname, rtlgetlasterrorstring()); } else { message(\u0026#34;successfully hooked %s.%s\\n\u0026#34;, modulename, functionname); } // ensure that all threads _except_ the injector thread will be hooked ulong aclentries[1] = { 0 }; lhsetexclusiveacl(aclentries, 1, \u0026amp;hooks[i]); } // ... } let\u0026rsquo;s implement the running example that brumley et al. used in their paper (fig. 1.1) to test that everything works as expected.\n#include \u0026lt;windows.h\u0026gt; void ddos (lpcstr target) { // ddos code goes here :) } int main() { systemtime systime; lpcstr site = \u0026#34;www.usenix.org\u0026#34;; getlocaltime(\u0026amp;systime); if (9 == systime.wday) { if (10 == systime.whour) { if (11 == systime.wmonth) { if (6 == systime.wminute) { ddos(site); } } } } return 0; } ensure that you compile everything for the x86 platform (since we\u0026rsquo;ll be using a 32-bit windows 7 vm). once everything is built (including the vm!), we can create a new project:\ns2e new_project -i windows-7sp1pro-i386 /path/to/malware-s2e/getlocaltime-test/debug/getlocaltime-test.exe note that this will create a bootstrap.sh that executes getlocaltime-test.exe directly. we must modify bootstrap.sh to have malware-inject.exe execute getlocaltime-test.exe instead. to do this we\u0026rsquo;ll need access to our hooking tools from within the vm. we can do this by executing the following command in our s2e environment to create the necessary symbolic links in our project directory:\ncd $s2edir/projects/getlocaltime-test hook_files=\u0026#34;easyhook32.dll malware-hook.dll malware-inject.exe\u0026#34; for file in $hook_files; do ln -s $s2edir/source/s2e/guest/windows/debug/$file $file done and then edit bootstrap.sh as follows:\n# ... # the target does not get executed directly - we execute it via malware-inject function execute_target { local target target=\u0026#34;$1\u0026#34; ./malware-inject.exe --dll \u0026#34;./malware-hook.dll\u0026#34; --app ${target} } # ... # we also need to download the files required for hooking # download the target file to analyze ${s2eget} \u0026#34;getlocaltime-test.exe\u0026#34; ${s2eget} \u0026#34;easyhook32.dll\u0026#34; ${s2eget} \u0026#34;malware-hook.dll\u0026#34; ${s2eget} \u0026#34;malware-inject.exe\u0026#34; # ... finally, we can disable the following plugins in s2e-config.lua (they are not required):\nwebserviceinterface keyvaluestore multisearcher cupasearcher staticfunctionmodels we are now ready to run our analysis!\nresults we should see s2e fork four times during our analysis. if we enable the --verbose-fork-info klee argument (in s2e-config.lua) we can see the constraints generated at each of these four fork points. the following image shows a disassembly with these points highlighted.\nreadlsb w16 x systemtime can be understood as \u0026ldquo;read 16 bits (i.e. one word) at offset x in the symbolic systemtime variable. if we look up the systemtime struct on msdn we will see that each word at these offsets (0x6, 0x8, 0x2, 0xa) corresponds with the wday, whour, wmonth and wminute fields respectively - just as expected. finally, we should find a line in debug.txt containing the following test case (i\u0026rsquo;ve reformatted the line and added the field names to make it easier to read):\ntestcasegenerator: v0_systemtime_0 = {0x0, 0x0, /* wyear */ 0xb, 0x0, /* wmonth */ 0x0, 0x0, /* wdayofweek */ 0x9, 0x0, /* wday */ 0xa, 0x0, /* whour */ 0x6, 0x0, /* wminute */ 0x0, 0x0, /* wsecond */ 0x0, 0x0} /* wmilliseconds */ if we cross-reference this against getlocaltime-test/test.c we can see that this is the time to launch the ddos. success!\ncase study 2: wannacry that was nice, but malware has moved on since the minesweeper paper was written in 2007. let\u0026rsquo;s look at something a bit more recent - the wannacry ransomware. wannacry famously contained a \u0026ldquo;killswitch\u0026rdquo; that stopped the ransomware from encrypting the target\u0026rsquo;s data. this killswitch was a check for whether a gibberish url led to a live webpage. wannacry would shut down if this url could be reached (this check was probably done to fool dynamic analysis tools, which are typically configured to return valid, dummy responses to all network queries). with this in mind, let\u0026rsquo;s use s2e to explore wannacry\u0026rsquo;s behaviour when this trigger condition is and isn\u0026rsquo;t satisfied. we\u0026rsquo;ll focus on the sample discussed in amanda rousseau\u0026rsquo;s excellent writeup (md5 hash db349b97c37d22f5ea1d1841e3c89eb4).\ndisassembly let\u0026rsquo;s take a quick look at the wannacry killswitch in a disassembler.\nwe can see that the wininet api is used to open a connection to the killswitch url (hxxp://www[.]iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea[.]com). the following functions are called to do this:\ninternetopena: initializes the wininet system. returns an hinternet handle on success, or null on failure. internetopenurla: using the handle returned by internetopena, open a resource specified by the given url. returns an hinternet handle on success, or null on failure. internetclosehandle: close the handles opened by internetopena and internetopenurla. at a minimum we must hook internetopenurla and force a fork to explore both paths at 0x4081a5. what about internetopena? we can see in the wannacry code that the hinternet handle returned by internetopena is never checked, so we don\u0026rsquo;t have to worry about this function. if the returned handle was (properly) checked, we may have needed to hook internetopena and force it to return some dummy, non-null value. similarly, if we were interested in the code executed when internetopena fails, we could also force a fork on some symbolic value. however, for simplicity we\u0026rsquo;ll just focus on internetopenurla. let\u0026rsquo;s write some more code!\nwininet hooks first, replace the hooked functions in malware-hook.cpp with the following:\nstatic lpcstr functionstohook[][2] = { { \u0026#34;wininet\u0026#34;, \u0026#34;internetopenurla\u0026#34; }, { \u0026#34;wininet\u0026#34;, \u0026#34;internetclosehandle\u0026#34; }, { null, null }, }; static pvoid hookfunctions[] = { internetopenurlahook, internetclosehandlehook, }; static hook_trace_info hooks[] = { { null }, { null }, } then write the actual hook functions:\n/// keep track of dummy internet handles that we\u0026#39;ve created static std::set\u0026lt;hinternet\u0026gt; dummyhandles; static hinternet winapi internetopenurlahook( hinternet hinternet, lpcstr lpszurl, lpcstr lpszheaders, dword dwheaderslength, dword dwflags, dword_ptr dwcontext ) { message(\u0026#34;intercepted internetopenurla(%p, %s, %s, 0x%x, 0x%x, %p)\\n\u0026#34;, hinternet, lpszurl, lpszheaders, dwheaderslength, dwflags, dwcontext); // force a fork via a symbolic variable. since both branches are feasible, // both paths are taken uint8 returnresource = s2esymbolicchar(\u0026#34;hinternet\u0026#34;, 1); if (returnresource) { // explore the program when internetopenurla \u0026#34;succeeds\u0026#34; by returning a // dummy resource handle. because we know that the resource handle is never // used, we don\u0026#39;t have to do anything fancy to create it. // however, we will need to keep track of it so we can free it when the // handle is closed. hinternet resourcehandle = (hinternet) malloc(sizeof(hinternet)); // record the dummy handle so we can clean up afterwards dummyhandles.insert(resourcehandle); return resourcehandle; } else { // explore the program when internetopenurla \u0026#34;fails\u0026#34; return null; } } static bool winapi internetclosehandlehook(hinternet hinternet) { message(\u0026#34;intercepted internetclosehandle(%p)\\n\u0026#34;, hinternet); std::set\u0026lt;hinternet\u0026gt;::iterator it = dummyhandles.find(hinternet); if (it == dummyhandles.end()) { // the handle is not one of our dummy handles, so call the original // internetclosehandle function return internetclosehandle(hinternet); } else { // the handle is a dummy handle. free it free(*it); dummyhandles.erase(it); return true; } } here we follow the approach taken in s2e\u0026rsquo;s multi-path fault injection tutorial. the returnresource symbolic variable forces a fork, resulting in one state where internetopenurla succeeds (by returning a dummy resource) and another state where internetopenurla fails (by returning null). we can return a dummy resource handle because the internetopenurla handle is never actually used: remember, wanncry only checks if it is null. the internetclosehandle hook then cleans up the allocated memory. now let\u0026rsquo;s hook and run wannacry in s2e.\ninitial results we can follow the same procedure that we used for getlocaltime-test to set up an s2e project for wannacry. remember to make symbolic links to easyhook32.dll, malware-hook.dll and malware-inject.exe and s2eget them in the bootstrap script.\nbefore running s2e, enable the librarycallmonitor plugin in s2e-config.lua. this plugin monitors and logs external library function calls, which gives us a better picture of what wannacry is doing. when you run s2e, you should see a fork in malware-hook\u0026rsquo;s address space (likely hidden amongst a lot of debug output produced by librarycallmonitor). if you follow the library calls made by the wannacry executable (instead of all the other dlls loaded in its address space), you should see the following library calls in state 0:\naddress dll function 0x4081bc wininet internetclosehandle 0x4081bf wininet internetclosehandle 0x409b4e msvcrt exit while in state 1 you should see:\naddress dll function 0x4081a7 wininet internetclosehandle 0x4081ab wininet internetclosehandle 0x40809f kernel32 getmodulefilenamea 0x4080a5 msvcrt __p___argc 0x407c56 msvcrt sprintf 0x407c68 advapi32 openscmanagera 0x407c9b advapi32 createservicea 0x407cb2 advapi32 startservicea \u0026hellip; 0x407d74 kernel32 findresourcea 0x407d86 kernel32 loadresource 0x407d95 kernel32 lockresource 0x407da9 kernel32 sizeofresource \u0026hellip; 0x407ee8 kernel32 createprocessa \u0026hellip; this looks good: we have successfully explored wannacry\u0026rsquo;s behaviour when the killswitch was and wasn\u0026rsquo;t triggered. rousseau\u0026rsquo;s writeup outlines wannacry\u0026rsquo;s execution flow, and if we follow state 1\u0026rsquo;s library calls we should see that the execution flows match.\nhooking process creation let\u0026rsquo;s write one last hook. what happens if our hooked process spawns a new process? this is pretty common for \u0026ldquo;dropper\u0026rdquo; malware, and indeed wannacry does this by loading an executable (tasksche.exe) from a resource, writing it to disk and then running it (via createprocessa). when this happens, we are totally blind to what this new process is doing: both in terms of injecting symbolic data via our hooks and tracking its behaviour with s2e (e.g. via the librarycallmonitor plugin).\nwe can solve the former (losing our ability to inject symbolic data into the new process) by hooking createprocessa and using the easyhook api to inject malware-hook into this new process. the following code achieves this:\n// don\u0026#39;t forget to add createprocessa to the functionstohook, hookfunctions and // hooks arrays bool winapi createprocessahook( lpcstr lpapplicationname, lpstr lpcommandline, lpsecurity_attributes lpprocessattributes, lpsecurity_attributes lpthreadattributes, bool binherithandles, dword dwcreationflags, lpvoid lpenvironment, lpcstr lpcurrentdirectory, lpstartupinfoa lpstartupinfo, lpprocess_information lpprocessinformation ) { message(\u0026#34;intercepted createprocessa(%s, %s, %p, %p, %d, %d, %p, %s, %p, %p)\u0026#34;, lpapplicationname, lpcommandline, lpprocessattributes, lpthreadattributes, binherithandles, dwcreationflags, lpenvironment, lpcurrentdirectory, lpstartupinfo, lpprocessinformation); // get this dll\u0026#39;s path hmodule hdll = null; dword hmodflags = get_module_handle_ex_flag_from_address | get_module_handle_ex_flag_unchanged_refcount; if (!getmodulehandleex(hmodflags, (lpctstr)\u0026amp;message, \u0026amp;hdll)) { message(\u0026#34;failed to retrive dll handle: 0x%x\\n\u0026#34;, getlasterror()); goto default_create_process; } wchar dllpath[max_path_len]; if (!getmodulefilenamew(hdll, dllpath, max_path_len)) { message(\u0026#34;failed to retrive dll path: 0x%x\\n\u0026#34;, getlasterror()); goto default_create_process; } // create the new process, but force it to be created in a suspended state if (!createprocessa(lpapplicationname, lpcommandline, lpprocessattributes, lpthreadattributes, binherithandles, dwcreationflags | create_suspended, lpenvironment, lpcurrentdirectory, lpstartupinfo, lpprocessinformation)) { message(\u0026#34;failed to create suspended process: 0x%x\\n\u0026#34;, getlasterror()); goto default_create_process; } // inject ourselves into the new, suspended process. // nativeinjectionentrypoint will call rhwakeupprocess, which will kick // ourselves out of the suspended state ntstatus result = rhinjectlibrary(lpprocessinformation-\u0026gt;dwprocessid, lpprocessinformation-\u0026gt;dwthreadid, easyhook_inject_default, #if defined(_m_ix86) dllpath, null, #elif defined(_m_x64) null, dllpath, #else #error \u0026#34;platform not supported\u0026#34; #endif null, 0); if (failed(result)) { message(\u0026#34;rhinjectlibrary failed: %s\\n\u0026#34;, rtlgetlasterrorstring()); goto default_create_process; } message(\u0026#34;successfully injected %s into %s %s (pid=0x%x)\\n\u0026#34;, dllpath, lpapplicationname, lpcommandline, lpprocessinformation-\u0026gt;dwprocessid); return true; default_create_process: return createprocessa(lpapplicationname, lpcommandline, lpprocessattributes, lpthreadattributes, binherithandles, dwcreationflags, lpenvironment, lpcurrentdirectory, lpstartupinfo, lpprocessinformation); } this hook will start the new process in a suspended state and inject itself into the new process. malware-hook\u0026rsquo;s nativeinjectionentrypoint function is then responsible for waking the process up.\nthis solves the problem of injecting symbolic data into a new process started by wannacry. what about tracking this new process\u0026rsquo; behaviour in s2e? unfortunately, this requires a bit more work. one approach could be to write an s2e plugin that listened for osmonitor\u0026rsquo;s onprocessload signal. if a new process was found to originate from the wannacry process, we could add the new child process to processexecutiondetector\u0026rsquo;s tracked modules. librarycallmonitor would then start emitting onlibrarycall events for this new process, allowing us to track its behaviour too. because i wanted to avoid writing s2e plugins in this post, i\u0026rsquo;ll leave this \u0026ldquo;as an exercise for the reader\u0026rdquo;.\none last problem exists: the original wannacry process terminates after it starts tasksche.exe. this causes malware-inject to also terminate (remember it calls waitforsingleobject), leading to bootstrap.sh killing the current (and only active) state. unfortunately, this means that s2e will terminate before we get to see wannacry do something interesting (like encrypt our data). the hacky way to fix this: add a sleep command after the call to execute in bootstrap.sh (don\u0026rsquo;t forget to set an appropriate amount of time to sleep for). this is hacky because it means that we\u0026rsquo;ll waste time sleeping in state 0 after wannacry exits (and does nothing interesting). a better approach is to wait for tasksche.exe (and any other child processes) to terminate. let\u0026rsquo;s add a function to do this:\n// set a sensible timeout value (in milliseconds). can also be infinite #define child_process_timeout 10 * 1000 /// keep track of child proceses (such as tasksche.exe) static std::set\u0026lt;dword\u0026gt; childpids; static bool waitforchildprocesses(dword timeout) { bool retcode = true; if (childpids.size() \u0026gt; 0) { // convert the set of pids to a list of handles with the appropriate permissions std::vector\u0026lt;handle\u0026gt; childhandles; for (dword pid : childpids) { message(\u0026#34;getting handle to process 0x%x\\n\u0026#34;, pid); handle childhandle = openprocess(synchronize | process_query_information, false, pid); if (childhandle) { childhandles.push_back(childhandle); } else { message(\u0026#34;unable to open child process 0x%x: 0x%x\\n\u0026#34;, pid, getlasterror()); return false; } } // wait for the processes to terminate message(\u0026#34;waiting %d ms for %d children processes to terminate...\\n\u0026#34;, timeout, childhandles.size()); dword waitres = waitformultipleobjects(childhandles.size(), childhandles.data(), true, timeout); switch (waitres) { case wait_failed: message(\u0026#34;failed to wait for child processes: 0x%x\\n\u0026#34;, getlasterror()); retcode = false; break; case wait_timeout: message(\u0026#34;timeout - not all child processes may have terminated\\n\u0026#34;); break; } // close all handles for (handle handle : childhandles) { closehandle(handle); } } return retcode; } waitforchildprocesses should be called when the hooked wannacry process exits. we can do this by adding dllmain and checking for reason code dll_process_detach:\nbool winapi dllmain(hinstance hinstdll, dword fdwreason, lpvoid lpvreserved) { switch (fdwreason) { // don\u0026#39;t exit until all child processes have terminated (or a timeout is reached) case dll_process_detach: return waitforchildprocesses(child_process_timeout); } return true; } finally, don\u0026rsquo;t forget to add the following code to createprocessahook to track child processes. the child process should only be saved if it is successfully hooked (i.e. before returning true).\n// this function was defined previously static bool winapi createprocessahook( lpcstr lpapplicationname, lpstr lpcommandline, lpsecurity_attributes lpprocessattributes, lpsecurity_attributes lpthreadattributes, bool binherithandles, dword dwcreationflags, lpvoid lpenvironment, lpcstr lpcurrentdirectory, lpstartupinfoa lpstartupinfo, lpprocess_information lpprocessinformation ) { // ... // save the newly-created process\u0026#39; pid childpids.insert(lpprocessinformation-\u0026gt;dwprocessid); return true; // ... } if you comment out graphics=-nographic in launch-s2e.sh (to enable the qemu gui), you\u0026rsquo;ll eventually be rewarded with the following (depending on the value chosen for child_process_timeout):\nconclusion and next steps in this post we\u0026rsquo;ve looked at analysing windows malware with s2e, essentially recreating david brumley\u0026rsquo;s minesweeper tool in s2e. unlike programs we\u0026rsquo;ve looked at in previous posts, we had to come up with some new techniques to inject symbolic data into our windows programs. we used easyhook to hook \u0026ldquo;trigger\u0026rdquo; functions that are commonly used by malware to hide their behaviour. while this approach worked well for our two case studies (which were admittedly highly contrived), there are many avenues for improvement. these avenues include:\nhooking more of the windows api. brumley and moser describe a number of different trigger sources (e.g. network data, registry keys, etc.) that aren\u0026rsquo;t covered in this post. building more complex hooks. for example, our internetopenurla hook was overly simplistic - it just returned a dummy handle allocated on the heap. if this handle was later passed to a function like internetreadfile, we\u0026rsquo;d have to hook this function as well. this is essentially the \u0026ldquo;environment modelling\u0026rdquo; problem inherit in most symbolic execution engines. hiding our hooks from the malware being analysed. some ideas including porting cuckoo monitor to s2e or doing everything in an s2e plugin. a broader study on real malware. is this type of symbolic execution even helpful for malware analysis? how common is trigger-based malware - can we get away with just doing a dynamic analysis in cuckoo sandbox? are the obfuscation techniques discussed in banescu\u0026rsquo;s work on code obfuscation against symbolic execution attacks used by malware authors, and if so how do they affect our analysis? hopefully this post gives you the necessary background and tools to go and look at some of these improvements. maybe one day i\u0026rsquo;ll even find the time to look at some of them myself!\nedit 21/10/2018: i\u0026rsquo;ve updated this post with a less-hacky way of waiting for wannacry\u0026rsquo;s tasksche.exe to start encrypting data.\n","title":"Analysing \"Trigger-based\" Malware with S2E"},{"date":"2017-10-23","image":"","imageAlt":"","link":"https://adrianherrera.github.io/posts/kaitai-s2e/","summary":"Introduction Recently I\u0026rsquo;ve been playing around with file parsers in S2E. This typically involves calling s2ecmd symbfile to make the parser\u0026rsquo;s input symbolic and then running S2E to explore different paths through the parser. However, this is a relatively heavy-handed approach; it makes the entire input file one big symbolic blob, which quickly causes path explosion. Additionally, we may only be interested in exploring paths that exercise specific functionality.\nSo how can we achieve more targeted symbolic execution on file-based programs such as parsers?","tags":["kaitai struct","s2e","symbolic execution"],"text":"introduction recently i\u0026rsquo;ve been playing around with file parsers in s2e. this typically involves calling s2ecmd symbfile to make the parser\u0026rsquo;s input symbolic and then running s2e to explore different paths through the parser. however, this is a relatively heavy-handed approach; it makes the entire input file one big symbolic blob, which quickly causes path explosion. additionally, we may only be interested in exploring paths that exercise specific functionality.\nso how can we achieve more targeted symbolic execution on file-based programs such as parsers? one approach could be to write a custom s2e plugin that handles the onsymbolicvariablecreation event and intercepts s2ecmd symbfile. you could then write c++ code that iterated over the symbolic data and adjusted what was symbolic/concrete. the downsides of this approach should be evident: it is time consuming and error prone to write c++ code to do this; it requires knowledge of the input file format; and you would have to repeat this process for different file formats. can we do better?\nkaitai struct let\u0026rsquo;s briefly diverge from s2e and discuss kaitai struct. kaitai struct is a tool for developing parsers for binary structures. it provides a yaml-like language that allows for the concise definition of a binary structure. the kaitai struct compiler (ksc) then generates a parser from this definition. this parser can be generated in a number of languages, including c++, python and java.\nhere is a partial definition of the elf format in kaitai struct (taken from the format gallery). it consists of a number of \u0026ldquo;attributes\u0026rdquo; (e.g. magic, abi_version, etc.) which describe an elf file:\nmeta: id: elf title: executable and linkable format application: svr4 abi and up, many *nix systems license: cc0-1.0 ks-version: 0.8 seq: # e_ident[ei_mag0]..e[ei_mag3] - id: magic size: 4 contents: [0x7f, \u0026#34;elf\u0026#34;] # e_ident[ei_class] - id: bits type: u1 enum: bits # e_ident[ei_data] - id: endian type: u1 enum: endian # e_ident[ei_version] - id: ei_version type: u1 # e_ident[ei_osabi] - id: abi type: u1 enum: os_abi - id: abi_version type: u1 - id: pad size: 7 - id: header type: endian_elf i strongly recommend reading the kaitai struct documentation to get the most out of this post, as i will skip much of the detail here (mostly because i\u0026rsquo;m not really an expert myself!). nevertheless, there is one feature that is worth singling out: the \u0026ldquo;processing spec\u0026rdquo;.\nthe processing spec allows you to apply a custom function that will \u0026ldquo;process\u0026rdquo; an attribute in some way. for example, an attribute may be encrypted/encoded. a processing spec can be applied to decrypt/decode this attribute at run time.\nhow is this relevant to symbolic execution? suppose that we had an s2e_make_symbolic processing spec, and by applying this spec to particular attributes we would make only those parts of the input file symbolic. this would give us more fine-grained control over s2e\u0026rsquo;s state space and potentially reduce the path explosion problem. all we need is a way to combine s2e and kaitai struct to make this possible!\ncombining s2e and kaitai struct we will use the lua programming language to combine s2e and kaitai struct. using lua allows us to reuse existing components — s2e contains an embedded lua interpreter (for parsing the s2e configuration file and writing function/instruction annotations), while ksc is capable of generating lua parsers. thus, we can use ksc to generate a lua parser for our input file and embed this parser within the s2e configuration file to make it accessible to s2e. (we could have used ksc to generate a c++ parser, but this would require recompiling s2e every time we wanted to use a different file format.) by selectively applying the s2e_make_symbolic processing spec in our input definition, we can achieve more targeted symbolic execution.\nthe remainder of this blog post will walk through how i combined s2e and kaitai struct. i\u0026rsquo;ll use the elf definition (discussed previously) and readelf as a practical example.\nin an effort to make it easier for others to play with the code, i\u0026rsquo;ve tried to make it as stand-alone as possible — there are no modifications to s2e\u0026rsquo;s core engine or ksc. however, this means that the code is far from polished! the code consists of the following components:\na command-line tool (s2e_kaitai_cmd) that executes in the guest os. this tool reads the input file and invokes an s2e plugin to selectively make the file symbolic; an s2e plugin (kaitaistruct) that invokes lua code to run a parser generated by ksc; and a small amount of lua glue between the s2e configuration file and the parser generated by ksc. each of these components are described below. the complete code is available here.\nthe s2e_kaitai_cmd tool at the start of this post i mentioned that we would normally use s2ecmd symbfile to make an input file symbolic. the symbfile command makes an input file symbolic by:\nopening the input file in read/write mode reading the input file into a buffer calling s2e_make_symbolic on the buffer writing the (now symbolic) buffer back to the original input file we\u0026rsquo;ll take a similar approach, except we\u0026rsquo;ll modify step (3) to:\ninvoke the kaitaistruct plugin to selectively make the buffer symbolic to do this we\u0026rsquo;ll add the following directories/files to our s2e environment:\nsource/s2e/guest/common/s2e_kaitai_cmd/s2e_kaitai_cmd.c source/s2e/guest/common/include/s2e/kaitai/commands.h i\u0026rsquo;ll skip steps 1, 2 and 4 because they have already been implemented in s2ecmd. for step 3, we\u0026rsquo;ll create a custom s2e command to invoke a plugin (described later) that will selectively make the input file symbolic. the command structure should be placed in source/s2e/guest/common/include/s2e/kaitai/commands.h. it follows the standard method for invoking s2e plugins from the guest:\nenum s2e_kaitai_commands { kaitai_make_symbolic, }; struct s2e_kaitai_command_make_symbolic { // pointer to guest memory where the symbolic file has been loaded uint64_t inputfile; // size of the input file (in bytes) uint64_t filesize; // 1 on success, 0 on failure uint64_t result; } __attribute__((packed)); struct s2e_kaitai_command { enum s2e_kaitai_commands command; union { struct s2e_kaitai_command_make_symbolic makesymbolic; }; } __attribute__((packed)); we can then add the following function to s2e_kaitai_cmd.c. this function takes a pointer to the file contents (which have been read into a buffer) and the size of the buffer (determined with lseek), constructs the relevant command and sends this command to s2e.\nstatic inline int s2e_kaitai_make_symbolic(const uint8_t *buffer, unsigned size) { struct s2e_kaitai_command cmd = {0}; cmd.command = s2e_kaitai_make_symbolic; cmd.makesymbolic.inputfile = (uintptr_t) buffer; cmd.makesymbolic.filesize = size; cmd.makesymbolic.result = 0; s2e_invoke_plugin(\u0026#34;kaitaistruct\u0026#34;, \u0026amp;cmd, sizeof(cmd)); return (int) cmd.makesymbolic.result; } now we need an s2e plugin to handle this command.\nthe kaitaistruct plugin let\u0026rsquo;s start with a skeleton plugin (don\u0026rsquo;t forget to add s2e/plugins/kaitaistruct.cpp to the add_library command in source/s2e/libs2eplugins/src/cmakelists.txt).\nthe header file:\n#ifndef s2e_plugins_kaitai_struct_h #define s2e_plugins_kaitai_struct_h #include \u0026lt;s2e/coreplugin.h\u0026gt; #include \u0026lt;s2e/plugins/core/baseinstructions.h\u0026gt; // forward declare the s2e command from s2e_kaitai_cmd struct s2e_kaitai_command; namespace s2e { namespace plugins { // in addition to extending the basic plugin class, we must also implement the // iplugininvoker to handle custom s2e commands class kaitaistruct : public plugin, public iplugininvoker { s2e_plugin public: kaitaistruct(s2e *s2e) : plugin(s2e) { } void initialize(); // the method from iplugininvoker that we must implement to respond to a // custom command. this method takes the current s2e state, a pointer to // the custom command object and the size of the custom command object virtual void handleopcodeinvocation(s2eexecutionstate *state, uint64_t guestdataptr, uint64_t guestdatasize); private: // the name of the lua function that will run the kaitai struct parser std::string m_kaitaiparserfunc; // handleopcodeinvocation will call this method to actually invoke the lua function bool handlemakesymbolic(s2eexecutionstate *state, const s2e_kaitai_command \u0026amp;command); } } // namespace plugins } // namespace s2e #endif and the cpp file:\n// from source/s2e/guest/common/include #include \u0026lt;s2e/kaitai/commands.h\u0026gt; #include \u0026lt;s2e/configfile.h\u0026gt; #include \u0026lt;s2e/s2e.h\u0026gt; #include \u0026lt;s2e/utils.h\u0026gt; #include \u0026#34;kaitaistruct.h\u0026#34; namespace s2e { namespace plugins { s2e_define_plugin( kaitaistruct, \u0026#34;combine s2e and kaitai struct\u0026#34;, \u0026#34;\u0026#34;, // dependencies \u0026#34;luabindings\u0026#34;); // reuse the existing lua binding code from the // function/instruction annotation plugins void kaitaistruct::initialize() { m_kaitaiparserfunc = s2e()-\u0026gt;getconfig()-\u0026gt;getstring( getconfigkey() + \u0026#34;.parser\u0026#34;); } bool kaitaistruct::handlemakesymbolic(s2eexecutionstate *state, const s2e_kaitai_command \u0026amp;command) { // we\u0026#39;ll finish this later return true; } void kaitaistruct::handleopcodeinvocation(s2eexecutionstate *state, uint64_t guestdataptr, uint64_t guestdatasize) { s2e_kaitai_command cmd; // 1. validate the received command if (guestdatasize != sizeof(cmd)) { getwarningsstream(state) \u0026lt;\u0026lt; \u0026#34;s2e_kaitai_command: mismatched command \u0026#34; \u0026lt;\u0026lt; \u0026#34;structure size \u0026#34; \u0026lt;\u0026lt; guestdatasize \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; exit(1); } // 2. read the command if (!state-\u0026gt;mem()-\u0026gt;read(guestdataptr, \u0026amp;cmd, guestdatasize)) { getwarningsstream(state) \u0026lt;\u0026lt; \u0026#34;s2e_kaitai_command: failed to read \u0026#34; \u0026lt;\u0026lt; \u0026#34;command\\n\u0026#34;; exit(1); } // 3. handle the command switch (cmd.command) { case kaitai_make_symbolic: { bool success = handlemakesymbolic(state, cmd); cmd.makesymbolic.result = success ? 0 : 1; // write the result back to the guest if (!state-\u0026gt;mem()-\u0026gt;write(guestdataptr, cmd, guestdatasize)) { getwarningsstream(state) \u0026lt;\u0026lt; \u0026#34;s2e_kaitai_command: failed to \u0026#34; \u0026lt;\u0026lt; \u0026#34; write result to guest\\n\u0026#34;; exit(1); } } break; default: { getwarningsstream(state) \u0026lt;\u0026lt; \u0026#34;s2e_kaitai_command: invalid command \u0026#34; \u0026lt;\u0026lt; hexval(cmd.command) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; exit(1); } } } } // namespace plugins } // namespace s2e our plugin has only one dependency: the luabindings plugin. this plugin configures s2e\u0026rsquo;s lua interpreter and allows us to call lua code in the s2e configuration file.\nthe handleopcodeinvocation method follows a similar pattern to other plugins that implement iplugininvoker (e.g. functionmodels and linuxmonitor):\nvalidate the received command by checking its size. read the command. since the command is issued by the guest, it resides in guest memory. nothing in our command should be symbolic (remember it only contains the input file\u0026rsquo;s start address and size), so we can read this memory concretely. handle the command. in this case we call another function (that we\u0026rsquo;ll discuss shortly) to invoke the lua interpreter to parse the input file. indicate success/failure to the guest. we do this by setting a \u0026ldquo;return code\u0026rdquo; in the command structure and writing the command back into guest memory. let\u0026rsquo;s finish handlemakesymbolic. since we are working with lua code we must include some extra header files:\n#include \u0026lt;vector\u0026gt; #include \u0026lt;s2e/plugins/lua/lua.h\u0026gt; #include \u0026lt;s2e/plugins/lua/luas2eexecutionstate.h\u0026gt; and finally the function implementation:\nbool kaitaistruct::handlemakesymbolic(s2eexecutionstate *state, const s2e_kaitai_command \u0026amp;command) { uint64_t addr = command.makesymbolic.inputfile; uint64_t size = command.makesymbolic.filesize; std::vector\u0026lt;uint8_t\u0026gt; data(size); // read the input file\u0026#39;s contents from guest memory if (!state-\u0026gt;mem()-\u0026gt;read(addr, data.data(), sizeof(uint8_t) * size)) { return false; } // get the lua interpreter\u0026#39;s state lua_state *l = s2e()-\u0026gt;getconfig()-\u0026gt;getstate(); // wrap the current s2e execution state luas2eexecutionstate luas2estate(state); // turn the input file into a lua string lual_buffer luabuff; lual_buffinit(l, \u0026amp;luabuff); lual_addlstring(\u0026amp;luabuff, (char*) data.data(), sizeof(uint8_t) * size); // set up our function call on lua\u0026#39;s virtual stack lua_getglobal(l, m_kaitaiparserfunc.c_str()); lunar\u0026lt;luas2eexecutionstate\u0026gt;::push(l, \u0026amp;luas2estate); lua_pushinteger(l, addr); lual_pushresult(\u0026amp;luabuff); // call our kaitai struct parser function lua_call(l, 3, 0); return true; } hopefully this is relatively easy to understand (see here for more information on lua\u0026rsquo;s c api). first we read the input file into a lua string for the kaitai struct parser. then, we call the kaitai struct parser function (which we\u0026rsquo;ll define in the following section).\nwe must set up the parser function\u0026rsquo;s arguments before we can call it. a virtual stack is used to pass values to lua functions. the first item pushed onto this stack is always the function name. our parser function will be defined in lua\u0026rsquo;s global namespace (for simplicity), so we can use lua_getglobal to retrieve this function from the s2e configuration file and push it onto the stack. we then push:\nthe current s2e execution state; the input file\u0026rsquo;s start address (in guest memory); and the contents of the input file (as a string). now all that\u0026rsquo;s left to do is to implement this parser in the s2e configuration file.\nlua scripts first, we need to compile a kaitai struct format definition into a lua parser. since we are going to be experimenting with readelf, let\u0026rsquo;s create our readelf project now and get the elf definition from the kaitai struct gallery:\n# create the s2e project s2e new_project -n readelf_kaitai readelf -h @@ cd projects/readelf_kaitai # get the elf kaitai struct definition and compile it wget https://raw.githubusercontent.com/kaitai-io/kaitai_struct_formats/master/executable/elf.ksy ksc -t lua elf.ksy this will generate elf.lua. now let\u0026rsquo;s try it out on a testcase from afl. if you don\u0026rsquo;t already have it, you\u0026rsquo;ll also need kaitai struct\u0026rsquo;s lua runtime:\n# get kaitai struct\u0026#39;s lua runtime git clone https://github.com/kaitai-io/kaitai_struct_lua_runtime lua_runtime # get the elf testcase wget https://raw.githubusercontent.com/mirrorer/afl/master/testcases/others/elf/small_exec.elf # parse the testcase lua5.3 - \u0026lt;\u0026lt; eof package.path = package.path .. \u0026#34;;./lua_runtime/?.lua\u0026#34; require(\u0026#34;elf\u0026#34;) inp = assert(io.open(\u0026#34;small_exec.elf\u0026#34;, \u0026#34;rb\u0026#34;)) testcase = elf(kaitaistream(inp)) print(\u0026#34;testcase e_ehsize: \u0026#34; .. testcase.header.e_ehsize) eof you should see a header size of 52 bytes (you can run readelf -h small_exec.elf to confirm).\ni originally stated that we\u0026rsquo;d be using kaitai struct\u0026rsquo;s processing spec to target specific file attributes to make symbolic. let\u0026rsquo;s define this processing spec in lua_runtime/s2e_make_symbolic.lua:\nlocal class = require(\u0026#34;class\u0026#34;) s2emakesymbolic = class.class() function s2emakesymbolic:_init(s2e_state, start_addr, curr_pos, name) self._state = s2e_state self._addr = start_addr + curr_pos self._name = name end function s2emakesymbolic:decode(data) local mem = self._state:mem() local size = data:len() -- the decode routine is called after the data has already been read, so we -- must return to the start of the data in order to make it symbolic local addr = self._addr - size mem:makeconcolic(addr, size, self._name) -- return the data unchanged return data end all we\u0026rsquo;ve done here is define a new class, s2emakesymbolic, with a constructor (_init) and a decode method. the constructor takes the following arguments:\nthe current s2e execution state; the input file\u0026rsquo;s start address (in guest memory); the current position of the parser. this plus the start address tell us the absolute memory address to make symbolic; and the name of the symbolic variable. the elf parser will automatically call decode when it encounters an attribute with the s2e_make_symbolic processing spec applied. however, the decode method is called after the data has been read from the input file, so we must compensate for this when we make the data symbolic (by subtracting the size of the memory region we just read).\nlet\u0026rsquo;s make something symbolic. we\u0026rsquo;ll choose something simple for now — the elf header\u0026rsquo;s e_machine field. in elf.ksy the e_machine field is defined under the endian_elf type:\n# the original definition of the e_machine field - id: machine type: u2 enum: machine processing specs can only be applied to byte arrays, so we must replace the type specification with a byte array\u0026rsquo;s size specification. because the original type was an unsigned 2-byte value, we can simply treat the machine as a byte array of size 2. we must also remove the enum mapping, otherwise ksc will raise a compilation error when it tries to apply an enum to a byte array.\n# redefinition of the e_machine field to make it symbolic - id: machine size: 2 process: s2e_make_symbolic(s2e_state, start_addr, _io.pos, \u0026#34;machine\u0026#34;) finally, we must propagate two additional arguments — the s2e execution state and the input file\u0026rsquo;s start address — from the parser\u0026rsquo;s constructor to s2e_make_symbolic. we do this with the \u0026ldquo;params spec\u0026rdquo;. the machine attribute is nested under the endian_elf and top-level elf types, so the following params spec must be defined under both.\nparams: - id: s2e_state - id: start_addr we must also modify the header\u0026rsquo;s type from endian_elf to endian_elf(s2e_state, start_addr). this ensures that the two arguments are passed to endian_elf\u0026rsquo;s constructor. (if this is all getting a bit confusing, remember that the full source code is available here).\n# the original header\u0026#39;s type - id: header type: endian_elf # redefined to propagate the s2e execution state and input file\u0026#39;s start address # to the endian_elf type - id: header type: endian_elf(s2e_state, start_addr) now recompile elf.ksy. if you open elf.lua you should see that the constructor (elf:_init) now takes s2e_state and start_addr as its first two arguments. these arguments are saved and later propagated to the s2emakesymbolic constructor via the elf.endianelf constructor.\nall that\u0026rsquo;s left to do is write a small function in our s2e configuration file that will instantiate and run our parser. this function is invoked by the handlemakesymbolic method in the kaitaistruct plugin.\npackage.path = package.path .. \u0026#34;;./lua_runtime/?.lua\u0026#34; local stringstream = require(\u0026#34;string_stream\u0026#34;) require(\u0026#34;elf\u0026#34;) function make_symbolic_elf(state, start_addr, buffer) local ss = stringstream(buffer) -- this will kick-start the parser. we don\u0026#39;t care about the final result elf(state, start_addr, kaitaistream(ss)) end -- enable and configure the necessary plugins add_plugin(\u0026#34;luabindings\u0026#34;) add_plugin(\u0026#34;kaitaistruct\u0026#34;) pluginsconfig.kaitaistruct = { parser = \u0026#34;make_symbolic_elf\u0026#34;, } and we\u0026rsquo;re done!\nexperimenting with readelf we\u0026rsquo;re finally ready to experiment with readelf. before we do, modify the s2e configuration file so that only the following plugins are enabled:\nbaseinstructions hostfiles vmi translationblockcoverage moduleexecutiondetector forklimiter processexecutiondetector linuxmonitor we\u0026rsquo;ll also have to modify bootstrap.sh. under ${s2eget} \u0026quot;readelf\u0026quot; add ${s2eget} \u0026quot;small_exec.elf\u0026quot; to copy our testcase to the guest. in the prepare_inputs function replace truncate -s 256 ${symb_file} with cp small_exec.elf ${symb_file} to use our testcase. we won\u0026rsquo;t replace the symbfile command yet; let\u0026rsquo;s get an initial idea of how readelf performs on a fully symbolic file.\nrun s2e for a minute or so before killing it. you should see many forked states (i forked 136 states). let\u0026rsquo;s generate code coverage information:\n# the actual disassembler isn\u0026#39;t important s2e coverage basic_block --disassembler=binaryninja readelf_kaitai where are these forks occurring? many are in libc, due to readelf calling printf on symbolic data. what about the forks that occur in readelf? the following images show snippets of two functions from readelf: process_section_headers and init_dwarf_regnames. green basic blocks indicate blocks that were executed by s2e. fork points have also been annotated with their constraints (in klee\u0026rsquo;s kquery format):\nreadelf\u0026rsquo;s process_section_headers code coverage\nreadelf\u0026rsquo;s init_dwarf_regnames code coverage\nforking also occurs when checking:\nif the input file is an archive the data encoding (little endian or big endian) the section header table\u0026rsquo;s file offset if each section\u0026rsquo;s sh_link and sh_info values are valid and at many other locations! now let\u0026rsquo;s try and reduce forking to only those program paths that relate to the elf header\u0026rsquo;s e_machine field. edit bootstrap.sh and replace ${s2ecmd} symbfile ${symb_file} with ./s2e_kaitai_cmd ${symb_file}. now rerun s2e for a minute. during my run, forking was limited to the get_machine_name and init_dwarf_regnames functions, both of which have switch statements based on the value of e_machine. success!\nlet\u0026rsquo;s try and target a different field in the elf file — the section header\u0026rsquo;s sh_type. unlike the e_machine field, which only occurs once in the elf file, the sh_type can occur multiple times throughout the file (depending on the number of sections in the elf file).\nonce again, we must propagate the s2e execution state and input file\u0026rsquo;s start address to the appropriate attribute in the elf declaration. this time we must add the params spec to the section_header type. the type attribute is defined as an unsigned 4-byte enum, so we must change this to a 4 byte array so that we can apply s2e_make_symbolic:\n# elf(32|64)_shdr section_header: params: - id: s2e_state - id: start_addr seq: # sh_name - id: name_offset type: u4 # sh_type - id: type size: 4 process: s2e_make_symbolic(s2e_state, start_addr, _io.pos, \u0026#34;sh_type\u0026#34;) # ... we must also ensure that these two arguments are passed to the sectionheader\u0026rsquo;s constructor. the section header can be found under the section_headers instance:\n# the original section_headers section_headers: pos: section_header_offset repeat: expr repeat-expr: qty_section_header size: section_header_entry_size type: section_header # redefined for symbolic execution section_headers: pos: section_header_offset repeat: expr repeat-expr: qty_section_header size: section_header_entry_size type: section_header(s2e_state, start_addr) notice that section_headers is declared as an \u0026ldquo;instance spec\u0026rdquo;. this means that section_headers compiles to a function that will only parse the section header on demand. therefore we must access the section_headers to force them to be parsed. to do this we must modify the make_elf_symbolic function in s2e-config.lua:\nfunction make_symbolic_elf(state, start_addr, buffer) -- ... -- this will kick-start the parser. however, now we do care about the final -- result, because we must access the section headers to force them to be -- parsed local elf_file = elf(state, start_addr, kaitaistream(ss)) -- this will kick-start the section header parser _ = elf_file.header.section_headers end run ksc to regenerate elf.lua. before we rerun s2e, let\u0026rsquo;s take a look at elf.lua. in particular, the parsing of the section headers in the section_headers\u0026rsquo; get method:\nfunction elf.endianelf.property.section_headers:get() -- ... for i = 1, self.qty_section_header do self._raw__m_section_headers[i] = \\ self._io:read_bytes(self.section_header_entry_size) local _io = kaitaistream(stringstream(self._raw__m_section_headers[i])) self._m_section_headers[i] = elf.endianelf.sectionheader(self.s2e_state, self.start_addr, _io, self, self._root, self._is_le) end -- ... end notice that ksc creates a local variable, _io, that gets passed to the sectionheader constructor. this _io variable contains the raw data that will eventually be transformed into a sectionheader object. unfortunately, this causes a problem for the s2e_make_symbolic processing spec.\nrecall that the parser\u0026rsquo;s current position (_io.pos) is passed to the s2e_make_symbolic processing spec. unfortunately, when the local _io stream is created, this position is reset to zero, so using this position would result in an incorrect memory address being made symbolic. fortunately, we can fix this with a small change to the lua code:\nfor i = 1, self.qty_section_header do -- get the absolute start address of the section header before it is parsed local _sec_hdr_start_addr = self.start_addr + self._io:pos() self._raw__m_section_headers[i] = \\ self._io:read_bytes(self.section_header_entry_size) local _io = kaitaistream(stringstream(self._raw__m_section_headers[i])) -- use the section header\u0026#39;s start address instead of the elf\u0026#39;s start address self._m_section_headers[i] = elf.endianelf.sectionheader(self.s2e_state, _sec_hdr_start_addr, _io, self, self._root, self._is_le) end yes, hacking the generated lua code is kind of disgusting. however, it ensures that the correct memory address is made symbolic. when i reran s2e, forking was limited to sh_type comparisons in the process_section_headers function. success again!\nconclusions and future work in this post i\u0026rsquo;ve looked at how we can perform more targeted symbolic execution of file parsers. rather than giving the parser a fully-symbolic input file (which quickly leads to path explosion), we can use kaitai struct to target specific parts of the input file to make symbolic. while this approach seems to work, there are a few problems associated with it.\nfirst, it relies on the user having a valid seed file to perform symbolic execution with. this seed file must also contain data for the part of the parser that we wish to exercise. for example, let\u0026rsquo;s assume that we wanted to apply this technique to a png parser. if we took this definition of a png file and wanted to see what happened when the bkgd_truecolor attribute was made symbolic, our png seed would also have to contain a background color chunk. otherwise our parser would have nothing to make symbolic.\nfor similar reasons, we cannot just use the \u0026ldquo;empty\u0026rdquo; symbolic file that the s2e bootstrap script creates. why? because when the kaitai struct parser executes, it runs on concrete data contained in the file. the default symbolic file that s2e creates is filled with null characters, so the parser would fail instantly. wouldn\u0026rsquo;t it be cool if we could pull files out of thin air?\nother issues stem from how we are using kaitai struct. this is not the fault of kaitai struct; in fact the kaitai struct faq explicitly states that the generated parsers are not designed for this model of \u0026ldquo;event-based\u0026rdquo; parsing. we could have modified ksc to generate code that required fewer manual modifications (e.g. automatically generate the params spec, use non-lazy instance specs, always keep track of the parser\u0026rsquo;s absolute position, etc.), however for simplicity i wanted to leave kaitai struct \u0026ldquo;as is\u0026rdquo;.\nwhat about non file-based symbolic execution? for example, in my previous post i showed how to use s2e to solve a ctf challenge that used a command-line string as input. the approach described in this post would not help in solving this ctf challenge. however, there is no reason why the kaitaistruct plugin could not be extended to work on command-line strings. for example, we could define the ctf challenge\u0026rsquo;s input string in kaitai struct as follows:\nmeta: id: ctf-input title: google ctf input format ks-version: 0.8 seq: - id: prefix size: 4 contents: \u0026#34;ctf{\u0026#34; - id: to_solve size: 63 # total length of 67 bytes minus the 4 byte prefix process: s2e_make_symbolic(s2e_state, start_addr, _io.pos, \u0026#34;to_solve\u0026#34;) params: - id: s2e_state - id: start_addr with some additional code we could run this parser on the input string to make only the last 63 bytes symbolic. this would allow us to remove the onsymbolicvariablecreation method from the s2e plugin.\ndespite these problems, combining s2e and kaitai struct seemed to work fairly well for the work that i was doing (although your mileage may vary!). we could probably get around these problems with a bit more work (and a lot more code). however, i think i\u0026rsquo;ll save that for a future post :)\n","title":"\"Targeting\" File Parsers with S2E and Kaitai Struct"},{"date":"2017-08-08","image":"","imageAlt":"","link":"https://adrianherrera.github.io/posts/google-ctf-2016/","summary":"Introduction Symbolic execution tools such as Angr and Manticore have become increasingly popular for analyzing binaries in Capture the Flag (CTF) challenges.\nIn this blog post I will show that we can do the same with S2E, using it to solve a reverse engineering challenge from the 2016 Google CTF. This post walks through the process of writing an S2E plugin \u0026ldquo;from first principles\u0026rdquo; to solve this challenge.\nFor comparison, solutions for the challenge using Angr and Manticore are also available.","tags":[],"text":"introduction symbolic execution tools such as angr and manticore have become increasingly popular for analyzing binaries in capture the flag (ctf) challenges.\nin this blog post i will show that we can do the same with s2e, using it to solve a reverse engineering challenge from the 2016 google ctf. this post walks through the process of writing an s2e plugin \u0026ldquo;from first principles\u0026rdquo; to solve this challenge.\nfor comparison, solutions for the challenge using angr and manticore are also available. if you want to cheat and skip straight to the end, the final plugin code is available here.\ngetting started as usual, i use s2e-env to organize my s2e environment. the challenge binary is a 64-bit elf, so i will use s2e\u0026rsquo;s debian x86_64 image. for those playing along at home, the instructions on how to use s2e-env can be found here.\ninitial analysis the challenge binary is available here. as other writeups have discussed, an initial static analysis reveals that the binary (a 64-bit elf executable) accepts a single command line argument (the product activation code). if this argument is not provided the program will print a usage message and exit.\nif the product activation code is provided, the argument is copied into the global buffer dest. the strncpy operation (at address 0x4005b8) copies 67 characters, so we can assume that the product activation code is 67 characters long. we are also told that the product activation code starts with \u0026ldquo;ctf{\u0026rdquo;.\nfurther analysis reveals that the function at 0x400850 is called when an incorrect product activation code is given. the correct product activation call will result in the function at 0x400830 being called and the message \u0026ldquo;thank you — product activated!\u0026rdquo; printed. therefore, when exploring the program we want to focus on states that will lead to 0x400830 and avoid those that lead to 0x400850. with this information, we can develop an s2e plugin to solve the challenge.\ncreating the s2e project we can use s2e-env\u0026rsquo;s new_project command to create a new analysis project for the challenge. we can also use our knowledge about the product activation code to automatically add the command line argument to the bootstrap script. create the project using the following command:\ns2e new_project --image debian-8.7.1-x86_64 --sym-args=\u0026#34;1\u0026#34; unbreakable \\ `python -c \u0026#34;print(\u0026#39;ctf{%s\u0026#39; % (\u0026#39;x\u0026#39; * (67 - 4)))\u0026#34;` the python code will generate a 67 character string starting with \u0026ldquo;ctf{\u0026rdquo;. --sym-args=\u0026quot;1\u0026quot; makes the first argument (i.e. the product activation code) symbolic. note that the actual contents of the string are not important.\nthe astute observer might also notice that the printed instructions contain a message regarding s2e\u0026rsquo;s functionmodels plugin. i will discuss how we can use this plugin later.\nwriting the s2e plugin we will develop a custom plugin to solve the challenge. note that this is probably the more complex and time-consuming approach — you could also use s2e\u0026rsquo;s lua annotations to avoid having to write c++ code. however, i think that developing a plugin from scratch is a better way to understand how s2e works.\nlet\u0026rsquo;s start with the standard s2e plugin template. create libs2eplugins/src/plugins/googlectfunbreakable.h:\n#ifndef s2e_plugins_google_ctf_unbreakable_h #define s2e_plugins_google_ctf_unbreakable_h #include \u0026lt;s2e/coreplugin.h\u0026gt; #include \u0026lt;s2e/plugin.h\u0026gt; #include \u0026lt;s2e/s2e.h\u0026gt; namespace s2e { namespace plugins { class googlectfunbreakable : public plugin { // declares an s2e plugin s2e_plugin public: // our constructor doesn\u0026#39;t need to do anything googlectfunbreakable(s2e *s2e) : plugin(s2e) { } // this will be called by s2e when registering and configuring the different plugins void initialize(); private: // we will add some more methods later }; } // namespace plugins } // namespace s2e #endif and in libs2eplugins/src/plugins/googlectfunbreakable.cpp:\n#include \u0026lt;s2e/s2e.h\u0026gt; #include \u0026#34;googlectfunbreakable.h\u0026#34; namespace s2e { namespace plugins { s2e_define_plugin( googlectfunbreakable, // plugin class \u0026#34;solve the google ctf unbreakable product activation code\u0026#34;, // plugin description \u0026#34;\u0026#34;, // unused ); // plugin dependencies (currently there are none) void googlectfunbreakable::initialize() { } } // namespace plugins } // namespace s2e this is a perfectly valid s2e plugin, it just doesn\u0026rsquo;t do anything useful. we need to tell the plugin what events we are interested in and how to react to them during runtime. coreplugin.h gives an idea of what events are available. events can also be generated by other plugins. for example, the osmonitor plugin generates events for process creation, module loading/unloading, etc.\nso what events are we interested in? from our initial analysis we know the function addresses that indicate success or failure. we can therefore use the ontranslateinstructionstart event to notify us when the code at these addresses is translated by qemu. declare an event handler in googlectfunbreakable.h:\nprivate: // the method signature corresponds to the ontranslateinstructionstart signal template in coreplugin.h void ontranslateinstruction(executionsignal *signal, s2eexecutionstate *state, translationblock *tb, uint64_t pc); we also need to register our interest in this event, which we do in the plugin\u0026rsquo;s initialize method.\nvoid googlectfunbreakable::initialize() { s2e()-\u0026gt;getcoreplugin()-\u0026gt;ontranslateinstructionstart.connect( sigc::mem_fun(*this, \u0026amp;googlectfunbreakable::ontranslateinstruction)); } this event occurs when code is translated by qemu. we need to register another event listener to notify our plugin when the code is actually executed. we do this using the executionsignal that is generated by the ontranslateinstructionstart event. in googlectfunbreakable.cpp (don\u0026rsquo;t forget to add the method declarations to googlectfunbreakable.h):\n// we found these addresses during our initial analysis in ida pro. // note that we assume non-pie addresses static const uint64_t success_address = 0x400724; static const uint64_t failure_address = 0x400850; void googlectfunbreakable::ontranslateinstruction(executionsignal *signal, s2eexecutionstate *state, translationblock *tb, uint64_t pc) { if (pc == success_address) { // register a handler for when the \u0026#34;success\u0026#34; code is executed signal-\u0026gt;connect(sigc::mem_fun(*this, \u0026amp;googlectfunbreakable::onsuccess)); } else if (pc == failure_address) { // register a handler for when the \u0026#34;failure\u0026#34; code is executed signal-\u0026gt;connect(sigc::mem_fun(*this, \u0026amp;googlectfunbreakable::onfailure)); } } void googlectfunbreakable::onsuccess(s2eexecutionstate *state, uint64_t pc) { // we will return to this later } void googlectfunbreakable::onfailure(s2eexecutionstate *state, uint64_t pc) { // there is no reason to continue execution any further. so kill the state s2e()-\u0026gt;getexecutor()-\u0026gt;terminatestateearly(*state, \u0026#34;invalid path\u0026#34;); } once execution reaches either the success or failure code, there is no reason to continue. we therefore kill the state to avoid wasting resources.\nnote that we use absolute addresses for our success and failure code. for position independent code (pie), you will need to register for module load events, record the load address of the module you are interested in (in this case unbreakable) and calculate the success and failure addresses via offsets at run time.\nunfortunately, there is a problem with our plugin. remember that s2e performs full-system emulation, meaning other processes may be executing at the same time that we are analyzing unbreakable. virtual addressing also means that there may be other processes that have code at success_address and failure_address. if this code is executed, our plugin\u0026rsquo;s onsuccess and onfailure methods will execute, potentially interfering with our analysis. we will avoid this problem with the processexecutiondetector plugin.\nthe processexecutiondetector tracks the execution of processes in the system. it is configurable so that only processes of interest are tracked. to add this plugin as a dependency, in googlectfunbreakable.cpp:\n#include \u0026lt;s2e/plugins/osmonitors/support/processexecutiondetector.h\u0026gt; s2e_define_plugin( googlectfunbreakable, \u0026#34;solve the google ctf unbreakable product activation code\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;processexecutiondetector\u0026#34; ); // plugin dependency void googlectfunbreakable::initialize() { m_procdetector = s2e()-\u0026gt;getplugin\u0026lt;processexecutiondetector\u0026gt;(); // ... } and add the processexecutiondetector as a private member of the googlectfunbreakable class:\n// in googlectfunbreakable.h class googlectfunbreakable : public plugin { // ... private: processexecutiondetector *m_procdetector; // ... }; now we can filter out all other processes except the unbreakable process. the following code should be added to the beginning of the ontranslateinstruction event handler:\nvoid googlectfunbreakable::ontranslateinstruction(executionsignal *signal, s2eexecutionstate *state, translationblock *tb, uint64_t pc) { // the processes to track are declared in the s2e lua configuration file if (!m_procdetector-\u0026gt;istracked(state)) { return; } // ... } this takes care of our success and failure paths. what about the rest of our initial analysis? remember that we were told that the activation code begins with \u0026ldquo;ctf{\u0026rdquo;. how can we encode this knowledge in our plugin?\nbecause we made the product activation string symbolic, we can use the onsymbolicvariablecreation event to wait for the product activation code to become symbolic, and then constrain this variable with our existing knowledge. in googlectfunbreakable.cpp:\n#include \u0026lt;klee/util/exprtemplatees.h\u0026gt; // register our onsymbolicvariablecreation event handler void googlectfunbreakable::initialize() { s2e()-\u0026gt;getcoreplugin()-\u0026gt;onsymbolicvariablecreation.connect( sigc::mem_fun(*this, \u0026amp;googlectfunbreakable::onsymbolicvariablecreation)); // ... } void googlectfunbreakable::onsymbolicvariablecreation(s2eexecutionstate *state, const std::string \u0026amp;name, const std::vector\u0026lt;klee::ref\u0026lt;klee::expr\u0026gt;\u0026gt; \u0026amp;expr, const klee::memoryobject *mo, const klee::array *array) { // this check is not strictly required, because we only have one symbolic // variable in the analysis. // // the first program argument made symbolic with the s2e_sym_args // environment variable will have the name \u0026#34;arg1\u0026#34;. if (name != \u0026#34;arg1\u0026#34;) { return; } // we know that the product activation key starts with \u0026#34;ctf{\u0026#34;. we encode // this information as klee constraints state-\u0026gt;constraints.addconstraint(e_eq(expr[0], e_const(\u0026#39;c\u0026#39;, klee::expr::int8))); state-\u0026gt;constraints.addconstraint(e_eq(expr[1], e_const(\u0026#39;t\u0026#39;, klee::expr::int8))); state-\u0026gt;constraints.addconstraint(e_eq(expr[2], e_const(\u0026#39;f\u0026#39;, klee::expr::int8))); state-\u0026gt;constraints.addconstraint(e_eq(expr[3], e_const(\u0026#39;{\u0026#39;, klee::expr::int8))); } encoding this information in the form of additional constraints helps to speed up symbolic execution. now the constraint solver will not waste time generating solutions which we know are not viable (e.g. activation codes beginning with \u0026ldquo;abcd\u0026rdquo;, \u0026ldquo;1337\u0026rdquo;, etc.).\nwe could have also encoded additional constraints for our solution. for example, we can assume that none of the remaining characters is a null terminator.\nfor (unsigned i = 4; i \u0026lt; expr.size(); ++i) { state-\u0026gt;constraints.addconstraint(e_neq(expr[i], e_const(\u0026#39;\\0\u0026#39;, klee::expr::int8))); } an alternate set of constraints could be that the other remaining characters are printable ascii characters.\nfor (unsigned i = 4; i \u0026lt; expr.size(); ++i) { state-\u0026gt;constraints.addconstraint(e_ge(expr[i], e_const(\u0026#39; \u0026#39;, klee::expr::int8))); state-\u0026gt;constraints.addconstraint(e_le(expr[i], e_const(\u0026#39;~\u0026#39;, klee::expr::int8))); } in practice i found that these additional constraints had a significant impact on performance. i will discuss this later.\nthe final step is to complete the onsuccess method. this involves solving the constraints accumulated during symbolic execution and displaying the result.\n#include \u0026lt;cctype\u0026gt; #include \u0026lt;sstream\u0026gt; void googlectfunbreakable::onsuccess(s2eexecutionstate *state, uint64_t pc) { // `results` is a vector containing pairs of strings and a vector of bytes. // the string corresponds to the symbolic variable\u0026#39;s name while the vector // of bytes is the actual solution std::vector\u0026lt;std::pair\u0026lt;std::string, std::vector\u0026lt;unsigned char\u0026gt;\u0026gt;\u0026gt; results; // invoke the constraint solver if (!s2e()-\u0026gt;getexecutor()-\u0026gt;getsymbolicsolution(*state, results)) { getwarningsstream(state) \u0026lt;\u0026lt; \u0026#34;unable to generate a solution for the product activation code\\n\u0026#34;; exit(1); } // since we only have a single symbolic variable, we will only have a single // result. we then iterate over the bytes in this result to print the solution std::stringstream ss; for (auto c : results[0].second) { if (!std::isprint(c)) { break; } ss \u0026lt;\u0026lt; (char) c; } getinfostream(state) \u0026lt;\u0026lt; \u0026#34;product activation code = \u0026#34; \u0026lt;\u0026lt; ss.str() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // no need to continue running s2e — terminate exit(0); } with the plugin complete, we need to ensure that it is compiled with the other s2e plugins. to do this, add the following to libs2eplugins/src/cmakelists.txt:\nsrc/plugins/googlectfunbreakable.cpp s2e will need to be rebuilt to ensure that our plugin is compiled and available for the analysis. finally, we need to rebuild s2e with our plugin.\ns2e build --clean-target libs2e capturing the flag with the plugin complete, we can use it to solve the challenge. first, the plugin must be enabled in our project\u0026rsquo;s s2e config file. by default, s2e new_project will generate a s2e-config.lua file with a standard set of plugins enabled and configured. however, most of them are not needed for this challenge. at a minimum the following plugins must be enabled:\ngooglectfunbreakable baseinstructions hostfiles linuxmonitor processexecutiondetector finally, we can run s2e with the launch-s2e.sh script. after a short while s2e will terminate and the following message will be displayed:\nproduct activation code = ctf{0the1quick2brown3fox4jumped5over6the7lazy8fox9} performance let\u0026rsquo;s return to the discussion on (1) the functionmodels plugin and (2) the performance impact caused by enforcing additional constraints on the product activation code.\nusing the functionmodels plugin the functionmodels plugin attempts to reduce path explosion. s2e-env analyzes the binary when the new_project command is executed and determines that the binary imports the strncpy function, for which a model exists.\nstrncpy is typically implemented as a loop over the input string until either a null terminator is found or n characters have been copied. by analyzing the binary in a disassembler we can see that this input string is the product activation key, which we made symbolic. looping over a symbolic string will result in a greater number of states forked, because any of the 63 characters following the \u0026ldquo;ctf{\u0026rdquo; prefix could contain a null terminator.\nby enabling the functionmodels plugin, the strncpy loop will be replaced by a single symbolic expression, reducing the total number of states forked. however, this comes with some performance trade-offs that i will discuss later.\nto enable the functionmodels plugin, add the following to s2e-config.lua:\nadd_plugin(\u0026#34;functionmodels\u0026#34;) measuring performance with the flag under our belt, we can now explore the various performance trade-offs that must be taken into account when we (1) apply various constraints to the product activation code and (2) use the functionmodels plugin. results are given in the tables below — one for execution time and one for the number of states forked.\nfor the \u0026ldquo;explore all states\u0026rdquo; results i removed the call to exit in the onsuccess method, even after capturing the flag (in practice this is unnecessary). for reference i also give the angr results (as quoted from their source code) and manticore results (from running it myself).\nexecution times description terminate on solution (secs) explore all states (secs) no additional constraints on the input string 12 240 no null terminator within the input string 12 12 all characters must be printable ascii 3,180 3,180 using functionmodels 13 13 angr 4.5 n/a manticore 60 n/a no. of states forked description terminate on solution (no. states) explore all states (no. states) no additional constraints on the input string 111 1720 no null terminator within the input string 49 49 all characters must be printable ascii 44 44 using functionmodels 49 49 angr n/a n/a manticore n/a n/a the first set of results are our baseline. the only constraints that we impose are that the product activation code begins with \u0026ldquo;ctf{\u0026rdquo;; the remaining 63 characters are unconstrained. of the 111 states forked before the solution is found, 62 of them occurred within strncpy. these 62 states correspond to the null terminator being located within one of the remaining 63 characters (e.g. \u0026ldquo;ctf{\\0\u0026rdquo;, \u0026ldquo;ctf{x\\0\u0026rdquo;, \u0026ldquo;ctf{xxxxxxxx\\0\u0026rdquo;, etc.). however, the depth-first search (dfs) strategy means that none of these 62 states is scheduled for execution before the solution is found. the total number of states quickly explodes otherwise.\nnow look at the performance after we constrain the remaining 63 characters of the product activation code to exclude the null terminator. the total number of states is reduced to 49. while this has negligible impact on execution time (when we terminate after the solution is found — again due to dfs), the total number of states no longer explodes.\nperformance degrades significantly when we over-constrain the product activation code to only contain printable ascii characters. while the total number of states is reduced, the bottleneck is simply transferred from state exploration to the constraint solver.\nnote: to view the symbolic formulae during execution the --verbose-fork-info can be added to the kleeargs table in s2e-config.lua.\nfinally, we find that the functionmodels plugin reduces the state space to the same levels as when we excluded null terminators from the product activation code. however, like when we over-constrain, the formula that the constraint solver must solve grows increasingly complex after the strncpy model is applied and the constraint solver once again becomes the bottleneck.\ni personally find this trade-off between state space and constraint formulae complexity quite interesting. afaik there are no automatic ways to determine this trade-off; it can only be found through experimentation.\nconclusion compared to the angr and manticore solutions, solving this challenge with s2e may seem overly complex. there are a variety of reasons for this: s2e runs a full-system emulator, so the user must handle the full software stack (os kernel, libraries, drivers, etc.); s2e is written in c++; and s2e is built on top of many different tools and frameworks (klee, qemu, llvm, etc.), each with their own apis.\nultimately it is a matter of selecting the correct tool for the job. for ctf-style challenges, where the program is largely self-contained and has very little interaction with the rest of the system (e.g. the os, libraries such as libc, etc.), using full-system emulation is probably overkill (however, as i\u0026rsquo;ve hopefully demonstrated, it can be done!). however for more complex software (e.g. device drivers, software with more complex interaction with the system, etc.), s2e may be the more suitable choice.\n","title":"Solving a CTF Challenge with S2E"},{"date":"2017-08-07","image":"","imageAlt":"","link":"https://adrianherrera.github.io/pages/about/","summary":"Hi there! 👋\nMy name is Adrian. I am a security researcher interested in applying program analysis techniques to reverse engineering and software security problems. I have a penchant for functional programming languages. This blog is mainly about those things.\nIn addition to my day job as a researcher at Interrupt Labs I also teach software security to undergraduates at the Australian National University (ANU). ANU is also where I completed my PhD, under the supervision of Tony Hosking (ANU), Michael Norrish (ANU), and Mathias Payer (EPFL).","tags":[],"text":"hi there! 👋\nmy name is adrian. i am a security researcher interested in applying program analysis techniques to reverse engineering and software security problems. i have a penchant for functional programming languages. this blog is mainly about those things.\nin addition to my day job as a researcher at interrupt labs i also teach software security to undergraduates at the australian national university (anu). anu is also where i completed my phd, under the supervision of tony hosking (anu), michael norrish (anu), and mathias payer (epfl).\nin a previous life i undertook software security research at the defence science and technology group (dstg) and hacked on the s2e symbolic execution engine. i regularly contribute to open-source software (mostly focused around program analysis and software security. unsurprisingly) and speak at both \u0026ldquo;hacker\u0026rdquo; and academic conferences in australia. my cv is available here.\nwhen i\u0026rsquo;m not breaking software i like to run, climb, and take photos of things (generally not at the same time).\ncontact my twitter dms are open. start there.\n","title":"About"}]
}

