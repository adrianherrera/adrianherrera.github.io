<!DOCTYPE html>
<html lang="en-us">

<head>
<meta charset="utf-8" />
<meta name="author" content="Adrian Herrera" />
<meta name="description" content="" />
<meta name="keywords" content="reverse engineering, symbolic execution, s2e" />
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.73.0" />

<link rel="canonical" href="https://adrianherrera.github.io/post/malware-s2e/">
<base href="https://adrianherrera.github.io/" />
<meta property="og:title" content="Analysing &#34;Trigger-based&#34; Malware with S2E" />
<meta property="og:description" content="Introduction This blog post is a quick brain-dump of the work that I was doing during my last month in the Dependable Systems Lab at EPFL. At the time I was working on malware analysis with S2E. While not anything earth-shatteringly novel, I&rsquo;m hopeful that this post will help others who want to use symbolic execution/S2E to analyse malware behaviour.
What makes malware analysis different? My previous blog posts have looked at solving a CTF challenge and analysing file parsers." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://adrianherrera.github.io/post/malware-s2e/" />
<meta property="article:published_time" content="2018-09-02T12:08:25+11:00" />
<meta property="article:modified_time" content="2018-09-02T12:08:25+11:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Analysing &#34;Trigger-based&#34; Malware with S2E"/>
<meta name="twitter:description" content="Introduction This blog post is a quick brain-dump of the work that I was doing during my last month in the Dependable Systems Lab at EPFL. At the time I was working on malware analysis with S2E. While not anything earth-shatteringly novel, I&rsquo;m hopeful that this post will help others who want to use symbolic execution/S2E to analyse malware behaviour.
What makes malware analysis different? My previous blog posts have looked at solving a CTF challenge and analysing file parsers."/>


<meta itemprop="name" content="Analysing &#34;Trigger-based&#34; Malware with S2E">
<meta itemprop="description" content="Introduction This blog post is a quick brain-dump of the work that I was doing during my last month in the Dependable Systems Lab at EPFL. At the time I was working on malware analysis with S2E. While not anything earth-shatteringly novel, I&rsquo;m hopeful that this post will help others who want to use symbolic execution/S2E to analyse malware behaviour.
What makes malware analysis different? My previous blog posts have looked at solving a CTF challenge and analysing file parsers.">
<meta itemprop="datePublished" content="2018-09-02T12:08:25&#43;11:00" />
<meta itemprop="dateModified" content="2018-09-02T12:08:25&#43;11:00" />
<meta itemprop="wordCount" content="4371">



<meta itemprop="keywords" content="" />

<link rel="stylesheet" href="css/layout.css" />
<link rel="stylesheet" href="css/color-dark.css" />



<title>


     Analysing &#34;Trigger-based&#34; Malware with S2E 

</title>

<script src="js/highlight.min.js"></script>
<link rel="stylesheet" href="css/tomorrow-night.min.css" />
<script>hljs.initHighlightingOnLoad();</script>

</head>


<body>
<div class="main">
<header>

<div class="header-bar">

  <nav>
    <div class="siteTitle">
      <a href="https://adrianherrera.github.io/">Adrian&#39;s Blog: from ⊤ to ⊥</a>
    </div> 

    
    
    <a class="nav-item" href="/post/"><div class="nav-item-title">Posts</div></a>
    
    <a class="nav-item" href="/about/"><div class="nav-item-title">About</div></a>
    

  </nav>
</div>

  
<div class="social-links-header">

  

  
  <a href="https://github.com/adrianherrera" target="_blank"><div class="social-link">GitHub</div></a>
  

  

  
  <a href="https://twitter.com/0xadr1an" target="_blank"><div class="social-link">Twitter</div></a>
  

  

</div>


</header>


<article class="post">
    <h1 class="title"> Analysing &#34;Trigger-based&#34; Malware with S2E </h1>
    <div class="content"> <h2 id="introduction">Introduction</h2>
<p>This blog post is a quick brain-dump of the work that I was doing during my
last month in the <a href="http://dslab.epfl.ch">Dependable Systems Lab</a> at
<a href="https://epfl.ch">EPFL</a>. At the time I was working on malware analysis with
S2E. While not anything earth-shatteringly novel, I&rsquo;m hopeful that this post
will help others who want to use symbolic execution/S2E to analyse malware
behaviour.</p>
<h2 id="what-makes-malware-analysis-different">What makes malware analysis different?</h2>
<p>My previous blog posts have looked at solving a <a href="https://adrianherrera.github.io/post/google-ctf-2016/">CTF challenge</a> and analysing <a href="https://adrianherrera.github.io/post/kaitai-s2e/">file parsers</a>. These programs had two things in common:</p>
<ol>
<li>They were Linux ELF executables; and</li>
<li>Program input was specified by the user — either via STDIN or from a file
that was read from disk.</li>
</ol>
<p>In contrast, <em>most</em> malware:</p>
<ol>
<li>Targets Windows (while some
<a href="https://www.av-test.org/fileadmin/pdf/security_report/AV-TEST_Security_Report_2016-2017.pdf">reports</a>
suggest that Android malware is on the rise, Windows remains the primary target
for malware authors); and</li>
<li>Does not have a well defined input source. Input <em>could</em> come from
command-line arguments, but this is uncommon. Input is more likely to come from
registry keys, network data, etc.</li>
</ol>
<p>For these reasons, analysing malware in S2E is not as simple as making
command-line arguments symbolic, or feeding the program a symbolic file. This
blog post will walk through the S2E-based tools that we developed for malware
analysis, followed by two &ldquo;case studies&rdquo;. As usual, if you wish to play along
at home you can find all of the code on
<a href="https://github.com/adrianherrera/malware-s2e">Github</a>.</p>
<h2 id="analysing-windows-software-in-s2e">Analysing Windows software in S2E</h2>
<p>Up until now, we have only analysed Linux programs. Fortunately, S2E also
supports the analysis of Windows programs. So what&rsquo;s the difference?</p>
<ol>
<li>When building a Windows guest image, a Windows ISO must be provided to
the <code>image_build</code> command. ISOs for all versions of Windows supported by S2E
(listed <a href="https://github.com/S2E/guest-images/blob/master/images.json">here</a>)
can be downloaded from <a href="https://msdn.microsoft.com/">MSDN</a>. It is also possible
to <a href="https://github.com/S2E/guest-tools/tree/master/windows#adding-support-for-new-kernels">add support for other
versions</a>
if required. For this post we&rsquo;ll use Windows 7 Professional 32-bit.</li>
<li>There is no equivalent to
<a href="https://github.com/S2E/guest-tools/blob/master/linux/s2e.so/s2e.c"><code>s2e.so</code></a>
on Windows. Therefore, we&rsquo;ll need an alternative approach to inject symbolic
data into our malware. We could write an S2E plugin to do this, but this is
complex. Instead, we&rsquo;ll use DLL injection in the guest to hook Windows API
calls and inject symbolic data through these hooks.</li>
</ol>
<h2 id="hooking-the-windows-api">Hooking the Windows API</h2>
<p>There are many different techniques for hooking the Windows API. We&rsquo;ll use an
&ldquo;off the shelf&rdquo; solution rather than (re)inventing a new one. When I first
started this work, I wanted to reuse <a href="https://cuckoosandbox.org/">Cuckoo
Sandbox</a>&rsquo;s
<a href="http://cuckoo-monitor.readthedocs.io/en/latest/">Monitor</a> for API hooking (as
it was designed for malware analysis). However, we decided to use
<a href="https://easyhook.github.io/">EasyHook</a> instead, primarily because it
required less work to get started with.</p>
<p>Before we dive into some code, here&rsquo;s an overview of what we are going to
build:</p>
<ul>
<li><code>malware-inject</code>: A program that will start other programs (e.g. malware) and
inject a DLL into the newly-started process&rsquo; address space; and</li>
<li><code>malware-hook</code>: A DLL that is injected into a process&rsquo; address space via
<code>malware-inject</code>. This DLL will hook key functions from the Windows API,
providing us with a mechanism to inject symbolic data.</li>
</ul>
<p>Now let&rsquo;s dive into some code!</p>
<p>We&rsquo;ll start by opening <code>$S2EDIR/source/s2e/guest/windows/s2e.sln</code> in Visual
Studio and creating two new projects:</p>
<ul>
<li><code>malware-inject</code>: A Win32 console application; and</li>
<li><code>malware-hook</code>: A Win32 DLL.</li>
</ul>
<p>Both projects require the EasyHook native package, installable via
<a href="https://www.nuget.org/">Nuget</a>. Note that in the Github repo the
<code>malware-hook</code> project is split into <code>GetLocalTime-hook</code> and <code>wannacry-hook</code>
projects (our two case studies).</p>
<h2 id="malware-inject"><code>malware-inject</code></h2>
<p><code>malware-inject</code> is based on EasyHook&rsquo;s example
<a href="https://easyhook.github.io/tutorials/nativeremotehook.html">injector</a>
application. However, instead of using <code>RhInjectLibrary</code> (which injects a DLL
into an already-running process), we&rsquo;ll use <code>RhCreateAndInject</code>. This function
starts an application in a suspended state, injects a DLL and then resumes the
suspended process. <code>malware-inject</code> will also wait for the injected process to
complete before returning. This is useful because it prevents S2E killing
states when the <code>malware-inject</code> process exits.</p>
<p>Create <code>inject.c</code> and add the following code to it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Shlwapi.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;easyhook.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// We must add this header file to support writing to S2E&#39;s logs. s2e.h resides
</span><span style="color:#75715e">// in the libcommon project, so the libcommon project must be added as a
</span><span style="color:#75715e">// dependency to the malware-inject project
</span><span style="color:#75715e"></span><span style="color:#75715e">#define USER_APP
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/s2e.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define S2E_MSG_LEN 512
</span><span style="color:#75715e">#define MAX_PATH_LEN 256
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> INT s2eVersion <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Message</span>(LPCSTR fmt, ...) {
    CHAR message[S2E_MSG_LEN];
    va_list args;

    va_start(args, fmt);
    vsnprintf(message, S2E_MSG_LEN, fmt, args);
    va_end(args);

    <span style="color:#66d9ef">if</span> (s2eVersion) {
        S2EMessageFmt(<span style="color:#e6db74">&#34;[malware-inject] %s&#34;</span>, message);
    } <span style="color:#66d9ef">else</span> {
        printf(<span style="color:#e6db74">&#34;[malware-inject] %s&#34;</span>, message);
    }
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">GetFullPath</span>(LPCWSTR path, PWCHAR fullPath) {
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>path) {
        Message(<span style="color:#e6db74">&#34;Path has not been provided</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        exit(<span style="color:#ae81ff">1</span>);
    }

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>PathFileExistsW(path)) {
        Message(<span style="color:#e6db74">&#34;Invalid path %S has been provided</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, path);
        exit(<span style="color:#ae81ff">1</span>);
    }

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>GetFullPathNameW(path, MAX_PATH_LEN, fullPath, NULL)) {
        Message(<span style="color:#e6db74">&#34;Unable to get full path of %S</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, path);
        exit(<span style="color:#ae81ff">1</span>);
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    INT argc;
    LPWSTR <span style="color:#f92672">*</span>argv <span style="color:#f92672">=</span> CommandLineToArgvW(GetCommandLineW(), <span style="color:#f92672">&amp;</span>argc);

    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>) {
        printf(<span style="color:#e6db74">&#34;Usage: %S [options..]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
            <span style="color:#e6db74">&#34;   --dll &lt;dll&gt;       Path to DLL to inject into the application</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
            <span style="color:#e6db74">&#34;   --app &lt;target&gt;    Path to application to start</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
            <span style="color:#e6db74">&#34;   --timeout &lt;time&gt;  Timeout value in milliseconds &#34;</span>
            <span style="color:#e6db74">&#34;(infinite if not provided)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
        exit(<span style="color:#ae81ff">1</span>);
    }

    <span style="color:#75715e">// Used by the Message function to decide where to write output to
</span><span style="color:#75715e"></span>    s2eVersion <span style="color:#f92672">=</span> S2EGetVersion();

    LPWSTR dllPath <span style="color:#f92672">=</span> NULL;
    WCHAR fullDllPath[MAX_PATH_LEN];

    LPWSTR appPath <span style="color:#f92672">=</span> NULL;
    WCHAR fullAppPath[MAX_PATH_LEN];

    DWORD timeout <span style="color:#f92672">=</span> INFINITE;

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> argc; <span style="color:#f92672">++</span>i) {
        <span style="color:#66d9ef">if</span> (wcscmp(argv[i], <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;--dll&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            dllPath <span style="color:#f92672">=</span> argv[<span style="color:#f92672">++</span>i];
            <span style="color:#66d9ef">continue</span>;
        }

        <span style="color:#66d9ef">if</span> (wcscmp(argv[i], <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;--app&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            appPath <span style="color:#f92672">=</span> argv[<span style="color:#f92672">++</span>i];
            <span style="color:#66d9ef">continue</span>;
        }

        <span style="color:#66d9ef">if</span> (wcscmp(argv[i], <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;--timeout&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            timeout <span style="color:#f92672">=</span> wcstoul(argv[<span style="color:#f92672">++</span>i], NULL, <span style="color:#ae81ff">10</span>);
            <span style="color:#66d9ef">continue</span>;
        }

        Message(<span style="color:#e6db74">&#34;Unsupported argument: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[i]);
        exit(<span style="color:#ae81ff">1</span>);
    }

    <span style="color:#75715e">// Check that the given paths are valid
</span><span style="color:#75715e"></span>    GetFullPath(dllPath, fullDllPath);
    GetFullPath(appPath, fullAppPath);

    <span style="color:#75715e">// Start the target application (in a suspended state) and inject the given
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// DLL
</span><span style="color:#75715e"></span>    ULONG pid;
    NTSTATUS result <span style="color:#f92672">=</span> RhCreateAndInject(appPath, <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;&#34;</span>, CREATE_SUSPENDED,
        EASYHOOK_INJECT_DEFAULT,
<span style="color:#75715e">#if defined(_M_IX86)
</span><span style="color:#75715e"></span>        dllPath, NULL,
<span style="color:#75715e">#elif defined(_M_X64)
</span><span style="color:#75715e"></span>        NULL, dllPath,
<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>        <span style="color:#75715e">#error &#34;Platform not supported&#34;
</span><span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>        NULL, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>pid);

    <span style="color:#66d9ef">if</span> (FAILED(result)) {
        Message(<span style="color:#e6db74">&#34;RhCreateAndInject failed: %S</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, RtlGetLastErrorString());
        exit(<span style="color:#ae81ff">1</span>);
    }

    Message(<span style="color:#e6db74">&#34;Successfully injected %S into %S (PID=0x%x)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, fullDllPath,
        fullAppPath, pid);

    DWORD exitCode <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#75715e">// Get a handle to the newly-created process and wait for it to terminate.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Once the process has terminated, get its return code and return that as
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// our return code
</span><span style="color:#75715e"></span>    HANDLE hProcess <span style="color:#f92672">=</span> OpenProcess(SYNCHRONIZE <span style="color:#f92672">|</span> PROCESS_QUERY_INFORMATION,
        FALSE, pid);
    <span style="color:#66d9ef">if</span> (hProcess) {
        WaitForSingleObject(hProcess, timeout);
        GetExitCodeProcess(hProcess, <span style="color:#f92672">&amp;</span>exitCode);
        CloseHandle(hProcess);
    } <span style="color:#66d9ef">else</span> {
        Message(<span style="color:#e6db74">&#34;Unable to open process 0x%x: 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pid, GetLastError());
    }

    <span style="color:#66d9ef">return</span> exitCode;
}
</code></pre></div><p>Of course, it is entirely possible that the malware will be watching for API
hooks (we are dealing with malicious software after all!). Whilst an important
issue, we won&rsquo;t deal with it in this post.</p>
<p>Now that we&rsquo;ve written the tool to run our malware with an injected DLL, let&rsquo;s
turn our attention to what this DLL actually does.</p>
<h2 id="malware-hook"><code>malware-hook</code></h2>
<p>Likewise, we&rsquo;ll base <code>malware-hook</code> on EasyHook&rsquo;s example
<a href="https://easyhook.github.io/tutorials/nativeremotehook.html">BeepHook</a> DLL.
Here is the skeleton of our hook DLL, which we&rsquo;ll put in <code>malware-hook.cpp</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;strsafe.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;easyhook.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define USER_APP
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> {
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/s2e.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">#define S2E_MSG_LEN 512
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> INT s2eVersion <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Message</span>(LPCSTR fmt, ...) {
    CHAR message[S2E_MSG_LEN];
    va_list args;

    va_start(args, fmt);
    vsnprintf(message, S2E_MSG_LEN, fmt, args);
    va_end(args);

    <span style="color:#66d9ef">if</span> (s2eVersion) {
        S2EMessageFmt(<span style="color:#e6db74">&#34;[0x%x|malware-hook] %s&#34;</span>, GetCurrentProcessId(),
            message);
    } <span style="color:#66d9ef">else</span> {
        printf(<span style="color:#e6db74">&#34;[0x%x|malware-hook] %s&#34;</span>, GetCurrentProcessId(), message);
    }
}

<span style="color:#75715e">// EasyHook will be looking for this export to support DLL injection. If not
</span><span style="color:#75715e">// found then DLL injection will fail
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__declspec</span>(dllexport) <span style="color:#66d9ef">__stdcall</span> NativeInjectionEntryPoint(REMOTE_ENTRY_INFO <span style="color:#f92672">*</span>);

<span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__stdcall</span> <span style="color:#a6e22e">NativeInjectionEntryPoint</span>(REMOTE_ENTRY_INFO <span style="color:#f92672">*</span>inRemoteInfo) {
    <span style="color:#75715e">// Unused
</span><span style="color:#75715e"></span>    (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>) inRemoteInfo;

    <span style="color:#75715e">// Used by the Message function to decide where to write output to
</span><span style="color:#75715e"></span>    s2eVersion <span style="color:#f92672">=</span> S2EGetVersion();

    <span style="color:#75715e">// TODO initialize hooks
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// The process was started in a suspended state. Wake it up...
</span><span style="color:#75715e"></span>    RhWakeUpProcess();
}
</code></pre></div><p>So, what are we going to hook? Let&rsquo;s take some inspiration from two great
papers on this topic: David Brumley&rsquo;s &ldquo;<a href="http://www.keylogger.org/articles/botnet_book-2007.pdf">Automatically Identifying Trigger-based
Behaviour in Malware</a>&rdquo;
and Andreas Moser&rsquo;s &ldquo;<a href="http://analysis.seclab.tuwien.ac.at/papers/explore.pdf">Exploring Multiple Execution Paths for Malware
Analysis</a>&rdquo;. Both of
these papers look at &ldquo;trigger-based malware&rdquo;, which is malware whose malicious
actions only occur under specific circumstances; i.e. when certain <em>trigger
conditions</em> are met. For example, malware may only launch its payload on a
specific date (as the <a href="https://en.wikipedia.org/wiki/Mydoom">MyDoom</a> worm did),
or upon receiving specific data from a command &amp; control server. In these two
examples, the <em>trigger sources</em> are the current date/time and data read from a
network. Other trigger sources include (as listed in Moser&rsquo;s paper):</p>
<ul>
<li>Internet connectivity;</li>
<li>Mutex objects;</li>
<li>Existence of files;</li>
<li>Existence of Registry entries; and</li>
<li>Data read from a file.</li>
</ul>
<p>How can we analyse trigger-based malware? Brumley&rsquo;s paper proposed Minesweeper,
a tool designed to detect the existence of trigger-based behaviours and to find
inputs that exercise these behaviours. As far as I can tell, Minesweeper was
never publicly released. However, we can build a very similar system in S2E
using our <code>malware-hook</code> DLL! So let&rsquo;s go ahead and create hooks for some of
the trigger sources discussed in these two papers.</p>
<h2 id="case-study-1-getlocaltime-test">Case study 1: <code>GetLocalTime-test</code></h2>
<p>The first trigger source that Brumley&rsquo;s paper explores is
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724338">GetLocalTime</a>.
<code>GetLocalTime</code> has the following prototype:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> WINAPI <span style="color:#a6e22e">GetLocalTime</span>(
  _Out_ LPSYSTEMTIME lpSystemTime
  );
</code></pre></div><p>In Minesweeper, the user was required to specify where in memory the trigger
inputs will be stored. This was so the symbolic execution engine could properly
assign symbolic variables during execution. In the case of <code>GetLocalTime</code>, this
would require specifying that <code>GetLocalTime</code> stores its result in a 16-byte
structure pointed to by a stack value when <code>GetLocalTime</code> is called.
Fortunately, we don&rsquo;t have to worry about these low-level details. Instead, we
can just call <code>S2EMakeSymbolic</code> on the variable we pass to <code>GetLocalTime</code>.
Here&rsquo;s how we do this in <code>malware-hook</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// Function hooks
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> WINAPI <span style="color:#a6e22e">GetLocalTimeHook</span>(LPSYSTEMTIME lpSystemTime) {
    Message(<span style="color:#e6db74">&#34;Intercepted GetLocalTime</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);

    <span style="color:#75715e">// Call the original GetLocalTime to get a concrete value
</span><span style="color:#75715e"></span>    GetLocalTime(lpSystemTime);

    <span style="color:#75715e">// Make the value concolic
</span><span style="color:#75715e"></span>    S2EMakeSymbolic(lpSystemTime, <span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>lpSystemTime), <span style="color:#e6db74">&#34;SystemTime&#34;</span>);
}

<span style="color:#75715e">// The names of the functions to hook (and the library they belong to)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> LPCSTR functionsToHook[][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> {
    { <span style="color:#e6db74">&#34;kernel32&#34;</span>, <span style="color:#e6db74">&#34;GetLocalTime&#34;</span>} ,
    { NULL, NULL },
};

<span style="color:#75715e">// The function hooks that we will install
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> PVOID hookFunctions[] <span style="color:#f92672">=</span> {
    GetLocalTimeHook,
};

<span style="color:#75715e">// The actual hooks
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> HOOK_TRACE_INFO hooks[] <span style="color:#f92672">=</span> {
    { NULL },
};

<span style="color:#75715e">// This function was defined previously
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__stdcall</span> <span style="color:#a6e22e">NativeInjectionEntryPoint</span>(REMOTE_ENTRY_INFO <span style="color:#f92672">*</span>inRemoteInfo) {
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// Replace the previous TODO with the following code to install the
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// GetLocalTime hook
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; functionsToHook[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> NULL; <span style="color:#f92672">++</span>i) {
        LPCSTR moduleName <span style="color:#f92672">=</span> functionsToHook[i][<span style="color:#ae81ff">0</span>];
        LPCSTR functionName <span style="color:#f92672">=</span> functionsToHook[i][<span style="color:#ae81ff">1</span>];

        <span style="color:#75715e">// Install the hook
</span><span style="color:#75715e"></span>        NTSTATUS result <span style="color:#f92672">=</span> LhInstallHook(
            GetProcAddress(GetModuleHandleA(moduleName), functionName),
            hookFunctions[i],
            NULL,
            <span style="color:#f92672">&amp;</span>hooks[i]);

        <span style="color:#66d9ef">if</span> (FAILED(result)) {
            Message(<span style="color:#e6db74">&#34;Failed to hook %s.%s: %S</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, moduleName, functionName,
                RtlGetLastErrorString());
        } <span style="color:#66d9ef">else</span> {
            Message(<span style="color:#e6db74">&#34;Successfully hooked %s.%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, moduleName, functionName);
        }

        <span style="color:#75715e">// Ensure that all threads _except_ the injector thread will be hooked
</span><span style="color:#75715e"></span>        ULONG ACLEntries[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
        LhSetExclusiveACL(ACLEntries, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>hooks[i]);
    }

    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><p>Let&rsquo;s implement the running example that Brumley et al. used in their paper
(Fig. 1.1) to test that everything works as expected.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ddos</span> (LPCSTR target) {
    <span style="color:#75715e">// DDOS code goes here :)
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    SYSTEMTIME systime;
    LPCSTR site <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;www.usenix.org&#34;</span>;

    GetLocalTime(<span style="color:#f92672">&amp;</span>systime);

    <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">9</span> <span style="color:#f92672">==</span> systime.wDay) {
        <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">10</span> <span style="color:#f92672">==</span> systime.wHour) {
            <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">11</span> <span style="color:#f92672">==</span> systime.wMonth) {
                <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">6</span> <span style="color:#f92672">==</span> systime.wMinute) {
                    ddos(site);
                }
            }
        }
    }

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Ensure that you compile everything for the x86 platform (since we&rsquo;ll be using
a 32-bit Windows 7 VM). Once everything is built (including the VM!), we can
create a new project:</p>
<pre><code class="language-console" data-lang="console">s2e new_project -i windows-7sp1pro-i386 /path/to/malware-s2e/GetLocalTime-test/Debug/GetLocalTime-test.exe
</code></pre><p>Note that this will create a <code>bootstrap.sh</code> that executes
<code>GetLocalTime-test.exe</code> directly. We must modify <code>bootstrap.sh</code> to have
<code>malware-inject.exe</code> execute <code>GetLocalTime-test.exe</code> instead. To do this we&rsquo;ll
need access to our hooking tools from within the VM. We can do this by
executing the following command in our S2E environment to create the necessary
symbolic links in our project directory:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cd $S2EDIR/projects/GetLocalTime-test
HOOK_FILES<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;EasyHook32.dll malware-hook.dll malware-inject.exe&#34;</span>
<span style="color:#66d9ef">for</span> FILE in $HOOK_FILES; <span style="color:#66d9ef">do</span>
    ln -s $S2EDIR/source/s2e/guest/windows/Debug/$FILE $FILE
<span style="color:#66d9ef">done</span>
</code></pre></div><p>And then edit <code>bootstrap.sh</code> as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># ...</span>

<span style="color:#75715e"># The target does not get executed directly - we execute it via malware-inject</span>
<span style="color:#66d9ef">function</span> execute_target <span style="color:#f92672">{</span>
    local TARGET
    TARGET<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span>

    ./malware-inject.exe --dll <span style="color:#e6db74">&#34;./malware-hook.dll&#34;</span> --app <span style="color:#e6db74">${</span>TARGET<span style="color:#e6db74">}</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e"># ...</span>

<span style="color:#75715e"># We also need to download the files required for hooking</span>

<span style="color:#75715e"># Download the target file to analyze</span>
<span style="color:#e6db74">${</span>S2EGET<span style="color:#e6db74">}</span> <span style="color:#e6db74">&#34;GetLocalTime-test.exe&#34;</span>

<span style="color:#e6db74">${</span>S2EGET<span style="color:#e6db74">}</span> <span style="color:#e6db74">&#34;EasyHook32.dll&#34;</span>
<span style="color:#e6db74">${</span>S2EGET<span style="color:#e6db74">}</span> <span style="color:#e6db74">&#34;malware-hook.dll&#34;</span>
<span style="color:#e6db74">${</span>S2EGET<span style="color:#e6db74">}</span> <span style="color:#e6db74">&#34;malware-inject.exe&#34;</span>

<span style="color:#75715e"># ...</span>
</code></pre></div><p>Finally, we can disable the following plugins in <code>s2e-config.lua</code> (they are not
required):</p>
<ul>
<li><code>WebServiceInterface</code></li>
<li><code>KeyValueStore</code></li>
<li><code>MultiSearcher</code></li>
<li><code>CUPASearcher</code></li>
<li><code>StaticFunctionModels</code></li>
</ul>
<p>We are now ready to run our analysis!</p>
<h3 id="results">Results</h3>
<p>We should see S2E fork four times during our analysis. If we enable the
<code>--verbose-fork-info</code> KLEE argument (in <code>s2e-config.lua</code>) we can see the
constraints generated at each of these four fork points. The following image
shows a disassembly with these points highlighted.</p>
<figure><a href="/img/getlocaltime_test-binja.png">
    <img src="/img/getlocaltime_test-binja.png"
         alt="GetLocalTime-test fork points"/> </a>
</figure>

<p><code>ReadLSB w16 X SystemTime</code> can be understood as &ldquo;read 16 bits (i.e. one <code>WORD</code>)
at offset <code>X</code> in the symbolic <code>SystemTime</code> variable. If we look up the
<code>SYSTEMTIME</code> struct on
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724950">MSDN</a> we
will see that each <code>WORD</code> at these offsets (<code>0x6</code>, <code>0x8</code>, <code>0x2</code>, <code>0xA</code>)
corresponds with the <code>wDay</code>, <code>wHour</code>, <code>wMonth</code> and <code>wMinute</code> fields
respectively - just as expected. Finally, we should find a line in <code>debug.txt</code>
containing the following test case (I&rsquo;ve reformatted the line and added the
field names to make it easier to read):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">TestCaseGenerator:  v0_SystemTime_0 <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wYear */</span>
                                       <span style="color:#ae81ff">0xb</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wMonth */</span>
                                       <span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wDayOfWeek */</span>
                                       <span style="color:#ae81ff">0x9</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wDay */</span>
                                       <span style="color:#ae81ff">0xa</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wHour */</span>
                                       <span style="color:#ae81ff">0x6</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wMinute */</span>
                                       <span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wSecond */</span>
                                       <span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">0x0</span>} <span style="color:#75715e">/* wMilliseconds */</span>
</code></pre></div><p>If we cross-reference this against <code>GetLocalTime-test/test.c</code> we can see that
this is the time to launch the DDOS. Success!</p>
<h2 id="case-study-2-wannacry">Case study 2: WannaCry</h2>
<p>That was nice, but malware has moved on since the Minesweeper paper was written
in 2007. Let&rsquo;s look at something a bit more recent - the
<a href="https://en.wikipedia.org/wiki/WannaCry_ransomware_attack">WannaCry</a>
ransomware. WannaCry famously contained a &ldquo;killswitch&rdquo; that stopped the
ransomware from encrypting the target&rsquo;s data. This killswitch was a check for
whether a gibberish URL led to a live webpage. WannaCry would shut down if this
URL could be reached (this check was probably done to fool dynamic analysis
tools, which are typically configured to return valid, dummy responses to all
network queries). With this in mind, let&rsquo;s use S2E to explore WannaCry&rsquo;s
behaviour when this trigger condition is <strong>and</strong> isn&rsquo;t satisfied. We&rsquo;ll focus
on the sample discussed in Amanda Rousseau&rsquo;s excellent
<a href="https://www.endgame.com/blog/technical-blog/wcrywanacry-ransomware-technical-analysis">writeup</a>
(SHA1 hash 24d004a104d4d54034dbcffc2a4b19a11f39008a575aa614ea04703480b1022c).</p>
<h3 id="disassembly">Disassembly</h3>
<p>Let&rsquo;s take a quick look at the WannaCry killswitch in a disassembler.</p>
<figure><a href="/img/wannacry-killswitch.png">
    <img src="/img/wannacry-killswitch.png"
         alt="WannaCry killswitch"/> </a>
</figure>

<p>We can see that the
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa385331">WinINet</a>
API is used to open a connection to the killswitch URL
(hxxp://www[.]iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea[.]com). The following
functions are called to do this:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/windows/desktop/api/wininet/nf-wininet-internetopena">InternetOpenA</a>:
Initializes the WinINet system. Returns an <code>HINTERNET</code> handle on success, or
<code>NULL</code> on failure.</li>
<li><a href="https://docs.microsoft.com/en-us/windows/desktop/api/wininet/nf-wininet-internetopenurla">InternetOpenUrlA</a>:
Using the handle returned by <code>InternetOpenA</code>, open a resource specified by the
given URL. Returns an <code>HINTERNET</code> handle on success, or <code>NULL</code> on failure.</li>
<li><a href="https://docs.microsoft.com/en-us/windows/desktop/api/wininet/nf-wininet-internetclosehandle">InternetCloseHandle</a>:
Close the handles opened by <code>InternetOpenA</code> and <code>InternetOpenUrlA</code>.</li>
</ul>
<p>At a minimum we must hook <code>InternetOpenUrlA</code> and force a fork to explore both
paths at <code>0x4081a5</code>. What about <code>InternetOpenA</code>? We can see in the WannaCry
code that the <code>HINTERNET</code> handle returned by <code>InternetOpenA</code> is never checked,
so we don&rsquo;t have to worry about this function. If the returned handle was
(properly) checked, we may have needed to hook <code>InternetOpenA</code> and force it to
return some dummy, non-<code>NULL</code> value. Similarly, if we were interested in the
code executed when <code>InternetOpenA</code> fails, we could also force a fork on some
symbolic value. However, for simplicity we&rsquo;ll just focus on <code>InternetOpenUrlA</code>.
Let&rsquo;s write some more code!</p>
<h3 id="wininet-hooks">WinINet hooks</h3>
<p>First, replace the hooked functions in <code>malware-hook.cpp</code> with the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">static</span> LPCSTR functionsToHook[][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> {
    { <span style="color:#e6db74">&#34;wininet&#34;</span>, <span style="color:#e6db74">&#34;InternetOpenUrlA&#34;</span> },
    { <span style="color:#e6db74">&#34;wininet&#34;</span>, <span style="color:#e6db74">&#34;InternetCloseHandle&#34;</span> },
    { NULL, NULL },
};

<span style="color:#66d9ef">static</span> PVOID hookFunctions[] <span style="color:#f92672">=</span> {
    InternetOpenUrlAHook,
    InternetCloseHandleHook,
};

<span style="color:#66d9ef">static</span> HOOK_TRACE_INFO hooks[] <span style="color:#f92672">=</span> {
    { NULL },
    { NULL },
}
</code></pre></div><p>Then write the actual hook functions:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/// Keep track of dummy Internet handles that we&#39;ve created
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>HINTERNET<span style="color:#f92672">&gt;</span> dummyHandles;

<span style="color:#66d9ef">static</span> HINTERNET WINAPI <span style="color:#a6e22e">InternetOpenUrlAHook</span>(
    HINTERNET hInternet,
    LPCSTR lpszUrl,
    LPCSTR lpszHeaders,
    DWORD dwHeadersLength,
    DWORD dwFlags,
    DWORD_PTR dwContext
) {
    Message(<span style="color:#e6db74">&#34;Intercepted InternetOpenUrlA(%p, %s, %s, 0x%x, 0x%x, %p)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
        hInternet, lpszUrl, lpszHeaders, dwHeadersLength, dwFlags, dwContext);

    <span style="color:#75715e">// Force a fork via a symbolic variable. Since both branches are feasible,
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// both paths are taken
</span><span style="color:#75715e"></span>    UINT8 returnResource <span style="color:#f92672">=</span> S2ESymbolicChar(<span style="color:#e6db74">&#34;hInternet&#34;</span>, <span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">if</span> (returnResource) {
        <span style="color:#75715e">// Explore the program when InternetOpenUrlA &#34;succeeds&#34; by returning a
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// dummy resource handle. Because we know that the resource handle is
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// never used, we don&#39;t have to do anything fancy to create it.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// However, we will need to keep track of it so we can free it when the
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// handle is closed.
</span><span style="color:#75715e"></span>        HINTERNET resourceHandle <span style="color:#f92672">=</span> (HINTERNET) malloc(<span style="color:#66d9ef">sizeof</span>(HINTERNET));

        <span style="color:#75715e">// Record the dummy handle so we can clean up afterwards
</span><span style="color:#75715e"></span>        dummyHandles.insert(resourceHandle);

        <span style="color:#66d9ef">return</span> resourceHandle;
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// Explore the program when InternetOpenUrlA &#34;fails&#34;
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> NULL;
    }
}

<span style="color:#66d9ef">static</span> BOOL WINAPI <span style="color:#a6e22e">InternetCloseHandleHook</span>(HINTERNET hInternet) {
    Message(<span style="color:#e6db74">&#34;Intercepted InternetCloseHandle(%p)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, hInternet);

    std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>HINTERNET<span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> dummyHandles.find(hInternet);

    <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">==</span> dummyHandles.end()) {
        <span style="color:#75715e">// The handle is not one of our dummy handles, so call the original
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// InternetCloseHandle function
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> InternetCloseHandle(hInternet);
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// The handle is a dummy handle. Free it
</span><span style="color:#75715e"></span>        free(<span style="color:#f92672">*</span>it);
        dummyHandles.erase(it);

        <span style="color:#66d9ef">return</span> TRUE;
    }
}
</code></pre></div><p>Here we follow the approach taken in S2E&rsquo;s <a href="https://github.com/S2E/docs/blob/master/src/Tutorials/WindowsDrivers/FaultInjection.rst">multi-path fault injection
tutorial</a>.
The <code>returnResource</code> symbolic variable forces a fork, resulting in one state
where <code>InternetOpenUrlA</code> succeeds (by returning a dummy resource) and another
state where <code>InternetOpenUrlA</code> fails (by returning <code>NULL</code>). We can return a
dummy resource handle because the <code>InternetOpenUrlA</code> handle is never actually
used: remember, WannCry only checks if it is <code>NULL</code>. The <code>InternetCloseHandle</code>
hook then cleans up the allocated memory. Now let&rsquo;s hook and run WannaCry in
S2E.</p>
<h3 id="initial-results">Initial results</h3>
<p>We can follow the same procedure that we used for <code>GetLocalTime-test</code> to set up
an S2E project for WannaCry. Remember to make symbolic links to EasyHook32.dll,
malware-hook.dll and malware-inject.exe and <code>s2eget</code> them in the bootstrap
script.</p>
<p>Before running S2E, enable the <code>LibraryCallMonitor</code> plugin in <code>s2e-config.lua</code>.
This plugin monitors and logs external library function calls, which gives us a
better picture of what WannaCry is doing. When you run S2E, you should see a
fork in <code>malware-hook</code>'s address space (likely hidden amongst <strong>a lot</strong> of
debug output produced by <code>LibraryCallMonitor</code>). If you follow the library calls
made by the WannaCry executable (instead of all the other DLLs loaded in its
address space), you should see the following library calls in state 0:</p>
<table>
<thead>
<tr>
<th>Address</th>
<th>DLL</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x4081bc</td>
<td>wininet</td>
<td>InternetCloseHandle</td>
</tr>
<tr>
<td>0x4081bf</td>
<td>wininet</td>
<td>InternetCloseHandle</td>
</tr>
<tr>
<td>0x409b4e</td>
<td>msvcrt</td>
<td>exit</td>
</tr>
</tbody>
</table>
<p>While in state 1 you should see:</p>
<table>
<thead>
<tr>
<th>Address</th>
<th>DLL</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x4081a7</td>
<td>wininet</td>
<td>InternetCloseHandle</td>
</tr>
<tr>
<td>0x4081ab</td>
<td>wininet</td>
<td>InternetCloseHandle</td>
</tr>
<tr>
<td>0x40809f</td>
<td>kernel32</td>
<td>GetModuleFileNameA</td>
</tr>
<tr>
<td>0x4080a5</td>
<td>msvcrt</td>
<td>__p___argc</td>
</tr>
<tr>
<td>0x407c56</td>
<td>msvcrt</td>
<td>sprintf</td>
</tr>
<tr>
<td>0x407c68</td>
<td>advapi32</td>
<td>OpenSCManagerA</td>
</tr>
<tr>
<td>0x407c9b</td>
<td>advapi32</td>
<td>CreateServiceA</td>
</tr>
<tr>
<td>0x407cb2</td>
<td>advapi32</td>
<td>StartServiceA</td>
</tr>
<tr>
<td>&hellip;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>0x407d74</td>
<td>kernel32</td>
<td>FindResourceA</td>
</tr>
<tr>
<td>0x407d86</td>
<td>kernel32</td>
<td>LoadResource</td>
</tr>
<tr>
<td>0x407d95</td>
<td>kernel32</td>
<td>LockResource</td>
</tr>
<tr>
<td>0x407da9</td>
<td>kernel32</td>
<td>SizeofResource</td>
</tr>
<tr>
<td>&hellip;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>0x407ee8</td>
<td>kernel32</td>
<td>CreateProcessA</td>
</tr>
<tr>
<td>&hellip;</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>This looks good: we have successfully explored WannaCry&rsquo;s behaviour when the
killswitch was <strong>and</strong> wasn&rsquo;t triggered. Rousseau&rsquo;s writeup outlines WannaCry&rsquo;s
execution flow, and if we follow state 1&rsquo;s library calls we should see that the
execution flows match.</p>
<h3 id="hooking-process-creation">Hooking process creation</h3>
<p>Let&rsquo;s write one last hook. What happens if our hooked process spawns a new
process? This is pretty common for  &ldquo;dropper&rdquo; malware, and indeed WannaCry does
this by loading an executable (<code>tasksche.exe</code>) from a resource, writing it to
disk and then running it (via <code>CreateProcessA</code>). When this happens, we are
totally blind to what this new process is doing: both in terms of injecting
symbolic data via our hooks and tracking its behaviour with S2E (e.g. via the
<code>LibraryCallMonitor</code> plugin).</p>
<p>We can solve the former (losing our ability to inject symbolic data into the
new process) by hooking <code>CreateProcessA</code> and using the EasyHook API to inject
<code>malware-hook</code> into this new process. The following code achieves this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// Don&#39;t forget to add CreateProcessA to the functionsToHook, hookFunctions and
</span><span style="color:#75715e">// hooks arrays
</span><span style="color:#75715e"></span>
BOOL WINAPI <span style="color:#a6e22e">CreateProcessAHook</span>(
    LPCSTR                lpApplicationName,
    LPSTR                 lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL                  bInheritHandles,
    DWORD                 dwCreationFlags,
    LPVOID                lpEnvironment,
    LPCSTR                lpCurrentDirectory,
    LPSTARTUPINFOA        lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
) {
    Message(<span style="color:#e6db74">&#34;Intercepted CreateProcessA(%s, %s, %p, %p, %d, %d, %p, %s, %p, %p)&#34;</span>,
        lpApplicationName, lpCommandLine, lpProcessAttributes,
        lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment,
        lpCurrentDirectory, lpStartupInfo, lpProcessInformation);

    <span style="color:#75715e">// Get this DLL&#39;s path
</span><span style="color:#75715e"></span>    HMODULE hDll <span style="color:#f92672">=</span> NULL;
    DWORD hModFlags <span style="color:#f92672">=</span> GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS <span style="color:#f92672">|</span>
        GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT;
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>GetModuleHandleEx(hModFlags, (LPCTSTR)<span style="color:#f92672">&amp;</span>Message, <span style="color:#f92672">&amp;</span>hDll)) {
        Message(<span style="color:#e6db74">&#34;Failed to retrive DLL handle: 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLastError());
        <span style="color:#66d9ef">goto</span> default_create_process;
    }

    WCHAR dllPath[MAX_PATH_LEN];
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>GetModuleFileNameW(hDll, dllPath, MAX_PATH_LEN)) {
        Message(<span style="color:#e6db74">&#34;Failed to retrive DLL path: 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLastError());
        <span style="color:#66d9ef">goto</span> default_create_process;
    }

    <span style="color:#75715e">// Create the new process, but force it to be created in a suspended state
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>CreateProcessA(lpApplicationName, lpCommandLine, lpProcessAttributes,
        lpThreadAttributes, bInheritHandles, dwCreationFlags <span style="color:#f92672">|</span> CREATE_SUSPENDED,
        lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation)) {
        Message(<span style="color:#e6db74">&#34;Failed to create suspended process: 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLastError());
        <span style="color:#66d9ef">goto</span> default_create_process;
    }

    <span style="color:#75715e">// Inject ourselves into the new, suspended process.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// NativeInjectionEntryPoint will call RhWakeupProcess, which will kick
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// ourselves out of the suspended state
</span><span style="color:#75715e"></span>    NTSTATUS result <span style="color:#f92672">=</span> RhInjectLibrary(lpProcessInformation<span style="color:#f92672">-&gt;</span>dwProcessId,
        lpProcessInformation<span style="color:#f92672">-&gt;</span>dwThreadId, EASYHOOK_INJECT_DEFAULT,
<span style="color:#75715e">#if defined(_M_IX86)
</span><span style="color:#75715e"></span>        dllPath, NULL,
<span style="color:#75715e">#elif defined(_M_X64)
</span><span style="color:#75715e"></span>        NULL, dllPath,
<span style="color:#75715e">#else
</span><span style="color:#75715e">#error &#34;Platform not supported&#34;
</span><span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>        NULL, <span style="color:#ae81ff">0</span>);

    <span style="color:#66d9ef">if</span> (FAILED(result)) {
        Message(<span style="color:#e6db74">&#34;RhInjectLibrary failed: %S</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, RtlGetLastErrorString());
        <span style="color:#66d9ef">goto</span> default_create_process;
    }

    Message(<span style="color:#e6db74">&#34;Successfully injected %S into %s %s (PID=0x%x)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dllPath,
        lpApplicationName, lpCommandLine, lpProcessInformation<span style="color:#f92672">-&gt;</span>dwProcessId);

    <span style="color:#66d9ef">return</span> TRUE;

default_create_process:
    <span style="color:#66d9ef">return</span> CreateProcessA(lpApplicationName, lpCommandLine, lpProcessAttributes,
        lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment,
        lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
}
</code></pre></div><p>This hook will start the new process in a suspended state and inject itself
into the new process. <code>malware-hook</code>'s <code>NativeInjectionEntryPoint</code> function
is then responsible for waking the process up.</p>
<p>This solves the problem of injecting symbolic data into a new process started
by WannaCry. What about tracking this new process&rsquo; behaviour in S2E?
Unfortunately, this requires a bit more work. One approach could be to write an
S2E plugin that listened for <a href="https://github.com/S2E/libs2eplugins/blob/master/src/s2e/Plugins/OSMonitors/OSMonitor.h">OSMonitor</a>&rsquo;s
<code>onProcessLoad</code> signal. If a new process was found to originate from the
WannaCry process, we could add the new child process to
<a href="https://github.com/S2E/libs2eplugins/blob/master/src/s2e/Plugins/OSMonitors/Support/ProcessExecutionDetector.h">ProcessExecutionDetector</a>&rsquo;s
tracked modules. <code>LibraryCallMonitor</code> would then start emitting <code>onLibraryCall</code>
events for this new process, allowing us to track its behaviour too. Because I
wanted to avoid writing S2E plugins in this post, I&rsquo;ll leave this &ldquo;as an
exercise for the reader&rdquo;.</p>
<p>One last problem exists: The original WannaCry process terminates after it
starts <code>tasksche.exe</code>. This causes <code>malware-inject</code> to also terminate (remember
it calls <code>WaitForSingleObject</code>), leading to <code>bootstrap.sh</code> killing the current
(and only active) state. Unfortunately, this means that S2E will terminate
before we get to see WannaCry do something interesting (like encrypt our data).
The hacky way to fix this: add a <code>sleep</code> command after the call to <code>execute</code> in
<code>bootstrap.sh</code> (don&rsquo;t forget to set an appropriate amount of time to sleep
for). This is hacky because it means that we&rsquo;ll waste time sleeping in state 0
after WannaCry exits (and does nothing interesting). A better approach is to
wait for <code>tasksche.exe</code> (and any other child processes) to terminate. Let&rsquo;s add
a function to do this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// Set a sensible timeout value (in milliseconds). Can also be INFINITE
</span><span style="color:#75715e"></span><span style="color:#75715e">#define CHILD_PROCESS_TIMEOUT 10 * 1000
</span><span style="color:#75715e"></span>
<span style="color:#75715e">/// Keep track of child proceses (such as tasksche.exe)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>DWORD<span style="color:#f92672">&gt;</span> childPids;

<span style="color:#66d9ef">static</span> BOOL <span style="color:#a6e22e">WaitForChildProcesses</span>(DWORD timeout) {
    <span style="color:#66d9ef">bool</span> retCode <span style="color:#f92672">=</span> TRUE;

    <span style="color:#66d9ef">if</span> (childPids.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#75715e">// Convert the set of PIDS to a list of handles with the appropriate
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// permissions
</span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>HANDLE<span style="color:#f92672">&gt;</span> childHandles;
        <span style="color:#66d9ef">for</span> (DWORD pid : childPids) {
            Message(<span style="color:#e6db74">&#34;Getting handle to process 0x%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pid);
            HANDLE childHandle <span style="color:#f92672">=</span> OpenProcess(SYNCHRONIZE <span style="color:#f92672">|</span> PROCESS_QUERY_INFORMATION,
                FALSE, pid);
            <span style="color:#66d9ef">if</span> (childHandle) {
                childHandles.push_back(childHandle);
            } <span style="color:#66d9ef">else</span> {
                Message(<span style="color:#e6db74">&#34;Unable to open child process 0x%x: 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pid,
                    GetLastError());
                <span style="color:#66d9ef">return</span> FALSE;
            }
        }

        <span style="color:#75715e">// Wait for the processes to terminate
</span><span style="color:#75715e"></span>        Message(<span style="color:#e6db74">&#34;Waiting %d ms for %d children processes to terminate...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
            timeout, childHandles.size());
        DWORD waitRes <span style="color:#f92672">=</span> WaitForMultipleObjects(childHandles.size(),
            childHandles.data(), TRUE, timeout);
        <span style="color:#66d9ef">switch</span> (waitRes) {
        <span style="color:#66d9ef">case</span> WAIT_FAILED:
            Message(<span style="color:#e6db74">&#34;Failed to wait for child processes: 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLastError());
            retCode <span style="color:#f92672">=</span> FALSE;
            <span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">case</span> WAIT_TIMEOUT:
            Message(<span style="color:#e6db74">&#34;Timeout - not all child processes may have terminated</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
            <span style="color:#66d9ef">break</span>;
        }

        <span style="color:#75715e">// Close all handles
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (HANDLE handle : childHandles) {
            CloseHandle(handle);
        }
    }

    <span style="color:#66d9ef">return</span> retCode;
}
</code></pre></div><p><code>WaitForChildProcesses</code> should be called when the hooked WannaCry process
exits. We can do this by adding <code>DLLMain</code> and checking for reason code
<code>DLL_PROCESS_DETACH</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">BOOL WINAPI <span style="color:#a6e22e">DllMain</span>(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    <span style="color:#66d9ef">switch</span> (fdwReason) {
    <span style="color:#75715e">// Don&#39;t exit until all child processes have terminated (or a timeout is
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// reached)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">case</span> DLL_PROCESS_DETACH:
        <span style="color:#66d9ef">return</span> WaitForChildProcesses(CHILD_PROCESS_TIMEOUT);
    }

    <span style="color:#66d9ef">return</span> TRUE;
}
</code></pre></div><p>Finally, don&rsquo;t forget to add the following code to <code>CreateProcessAHook</code> to
track child processes. The child process should only be saved if it is
successfully hooked (i.e. before returning <code>TRUE</code>).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// This function was defined previously
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> BOOL WINAPI <span style="color:#a6e22e">CreateProcessAHook</span>(
    LPCSTR                lpApplicationName,
    LPSTR                 lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL                  bInheritHandles,
    DWORD                 dwCreationFlags,
    LPVOID                lpEnvironment,
    LPCSTR                lpCurrentDirectory,
    LPSTARTUPINFOA        lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
) {
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// Save the newly-created process&#39; PID
</span><span style="color:#75715e"></span>    childPids.insert(lpProcessInformation<span style="color:#f92672">-&gt;</span>dwProcessId);

    <span style="color:#66d9ef">return</span> TRUE;

    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><p>If you comment out <code>GRAPHICS=-nographic</code> in <code>launch-s2e.sh</code> (to enable the QEMU
GUI), you&rsquo;ll eventually be rewarded with the following (depending on the value
chosen for <code>CHILD_PROCESS_TIMEOUT</code>):</p>
<figure><a href="/img/wannacry-s2e.png">
    <img src="/img/wannacry-s2e.png"
         alt="WannaCry infection"/> </a>
</figure>

<h2 id="conclusion-and-next-steps">Conclusion and next steps</h2>
<p>In this post we&rsquo;ve looked at analysing Windows malware with S2E, essentially
recreating David Brumley&rsquo;s Minesweeper tool in S2E. Unlike programs we&rsquo;ve
looked at in previous posts, we had to come up with some new techniques to
inject symbolic data into our Windows programs. We used EasyHook to hook
&ldquo;trigger&rdquo; functions that are commonly used by malware to hide their behaviour.
While this approach worked well for our two case studies (which were admittedly
highly contrived), there are many avenues for improvement. These avenues
include:</p>
<ul>
<li>Hooking more of the Windows API. Brumley and Moser describe a number of
different trigger sources (e.g. network data, registry keys, etc.) that aren&rsquo;t
covered in this post.</li>
<li>Building more complex hooks. For example, our <code>InternetOpenUrlA</code> hook was
overly simplistic - it just returned a dummy handle allocated on the heap. If
this handle was later passed to a function like <code>InternetReadFile</code>, we&rsquo;d have
to hook this function as well. This is essentially the &ldquo;environment modelling&rdquo;
problem inherit in most symbolic execution engines.</li>
<li>Hiding our hooks from the malware being analysed. Some ideas including
porting Cuckoo Monitor to S2E or doing everything in an S2E plugin.</li>
<li>A broader study on real malware. Is this type of symbolic execution even
helpful for malware analysis? How common is trigger-based malware - can we get
away with just doing a dynamic analysis in Cuckoo Sandbox? Are the
obfuscation techniques discussed in Banescu&rsquo;s work on <a href="https://mediatum.ub.tum.de/doc/1343173/1343173.pdf">Code Obfuscation
Against Symbolic Execution Attacks</a>
used by malware authors, and if so how do they affect our analysis?</li>
</ul>
<p>Hopefully this post gives you the necessary background and tools to go and
look at some of these improvements. Maybe one day I&rsquo;ll even find the time to
look at some of them myself!</p>
<h2 id="edit">Edit</h2>
<p><strong>21/10/2018</strong>: I&rsquo;ve updated this post with a less-hacky way of waiting for
WannaCry&rsquo;s <code>tasksche.exe</code> to start encrypting data.</p>
 </div>
    <footer class="post-footer">

  <div class="post-footer-data">
    
<div class="tags">
    
</div>

    
      <a href="https://twitter.com/share" class="twitter-share-button"
         data-related="0xadr1an" data-show-count="false">Tweet</a>
         <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
    
    <div class="date"> Sep 2, 2018 </div>
  </div>

</footer>


  



</article>

  <footer>

  <div class="social-links-footer">

  

  
  <a href="https://github.com/adrianherrera" target="_blank"><div class="social-link">GitHub</div></a>
  

  

  
  <a href="https://twitter.com/0xadr1an" target="_blank"><div class="social-link">Twitter</div></a>
  

  

  <div class="social-link">
  <a href="https://adrianherrera.github.io/index.xml" target="_blank">RSS</a>
  </div>

</div>


  <div class="copyright"> Copyright (c) 2017, all rights reserved. </div>

  <div class="poweredby">
    Powered by <a href="https://gohugo.io/">Hugo</a>.
  </div>

  </footer>

</body>
</html>

