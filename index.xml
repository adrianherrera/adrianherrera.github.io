<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet href="/feed_style.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="https://www.rssboard.org/media-rss">
  <channel>
    <title>Program Analysis from ⊤ to ⊥</title>
    <link>https://adrianherrera.github.io/</link>
    <description>Recent content on Program Analysis from ⊤ to ⊥</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Copyright (c) 2023, all rights reserved.</copyright>
    <lastBuildDate>Sun, 05 Mar 2023 09:44:19 +1100</lastBuildDate><atom:link href="https://adrianherrera.github.io/index.xml" rel="self" type="application/rss+xml" /><icon>https://adrianherrera.github.io/img/logo.png</icon>
    
    
    <item>
      <title>Publications</title>
      <link>https://adrianherrera.github.io/pages/publications/</link>
      <pubDate>Sun, 05 Mar 2023 09:44:19 +1100</pubDate>
      
      <guid>https://adrianherrera.github.io/pages/publications/</guid>
      <description><![CDATA[<h2 id="conference-proceedings">Conference Proceedings</h2>
<ul>
<li>
<p><a href="/publications/evocatio.pdf">Evocatio: Conjuring Bug Capabilities from a Single PoC</a>.
Zhiyuan Jiang, Shuitao Gan, <strong>Adrian Herrera</strong>, Flavio Toffalini, Lucio Romerio, Chaojing Tang, Manuel Egele, Chao Zhang, and Mathias Payer.
In <strong>CCS'22</strong>: Computer and Communications Security.</p>
</li>
<li>
<p><a href="/publications/seed-selection.pdf">Seed Selection for Successful Fuzzing</a>.
<strong>Adrian Herrera</strong>, Hendra Gunadi, Shane Magrath, Michael Norrish, Mathias Payer, and Antony L. Hosking.
In <strong>ISSTA'21</strong>: International Symposium on Software Testing and Analysis.</p>
</li>
<li>
<p><a href="/publications/magma.pdf">Magma: A Ground-Truth Fuzzing Benchmark</a>.
Ahmad Hazimeh, <strong>Adrian Herrera</strong>, and Mathias Payer.
In <strong>SIGMETRICS'21</strong>: SIGMETRICS.</p>
</li>
<li>
<p><a href="/publications/jmd.pdf">JMD: A Hybrid Approach for Detecting Java Malware</a>.
<strong>Adrian Herrera</strong> and Ben Cheney.
In <strong>AISC'2015</strong>: Australiasian Information Security Conference.</p>
</li>
<li>
<p><a href="/publications/key-distro-wsn.pdf">A Key Distribution Protocol for Wireless Sensor Networks</a>.
<strong>Adrian Herrera</strong> and Wen Hu.
In <strong>LCN'12</strong>: Local Computer Networks.</p>
</li>
</ul>
<h2 id="workshop-proceedings">Workshop Proceedings</h2>
<ul>
<li>
<p><a href="/publications/dataflow-rr.pdf">Registered Report: datAFLow - Towards a Data-Flow-Guided Fuzzer</a>.
<strong>Adrian Herrera</strong>, Mathias Payer, and Antony L. Hosking.
In <strong>FUZZING'22</strong>: International Fuzzing Workshop.</p>
</li>
<li>
<p><a href="/publications/safe-deobs.pdf">Optimizing Away JavaScript Obfuscation</a>.
<strong>Adrian Herrera</strong>.
In <strong>SCAM'20</strong>: Source Code Analysis and Manipulation.</p>
</li>
</ul>
<h2 id="journal-publications">Journal Publications</h2>
<ul>
<li><strong>datAFLow: Toward a Data-Flow-Guided Fuzzer</strong>.
<strong>Adrian Herrera</strong>, Mathias Payer, and Antony L. Hosking.
In <strong>TOSEM'23</strong>: Transactions on Software Engineering Methodologies.</li>
</ul>
<h2 id="technical-reports">Technical Reports</h2>
<ul>
<li><a href="/publications/ipv6.pdf">How Secure is the Next-Generation Internet? An Examination of IPv6</a>.
<strong>Adrian Herrera</strong>.
Defence Science and Technology Group (DSTG) Technical Report.</li>
</ul>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Analysing &#34;Trigger-based&#34; Malware with S2E</title>
      <link>https://adrianherrera.github.io/posts/malware-s2e/</link>
      <pubDate>Sun, 02 Sep 2018 12:08:25 +1100</pubDate>
      
      <guid>https://adrianherrera.github.io/posts/malware-s2e/</guid>
      <description><![CDATA[<h2 id="introduction">Introduction</h2>
<p>This blog post is a quick brain-dump of the work that I was doing during my
last month in the <a href="http://dslab.epfl.ch">Dependable Systems Lab</a> at
<a href="https://epfl.ch">EPFL</a>. At the time I was working on malware analysis with
S2E. While not anything earth-shatteringly novel, I&rsquo;m hopeful that this post
will help others who want to use symbolic execution/S2E to analyse malware
behaviour.</p>
<h2 id="what-makes-malware-analysis-different">What makes malware analysis different?</h2>
<p>My previous blog posts have looked at solving a <a href="https://adrianherrera.github.io/posts/google-ctf-2016/">CTF challenge</a> and analysing <a href="https://adrianherrera.github.io/posts/kaitai-s2e/">file parsers</a>. These programs had two things in common:</p>
<ol>
<li>They were Linux ELF executables; and</li>
<li>Program input was specified by the user — either via STDIN or from a file
that was read from disk.</li>
</ol>
<p>In contrast, <em>most</em> malware:</p>
<ol>
<li>Targets Windows (while some
<a href="https://www.av-test.org/fileadmin/pdf/security_report/AV-TEST_Security_Report_2016-2017.pdf">reports</a>
suggest that Android malware is on the rise, Windows remains the primary target
for malware authors); and</li>
<li>Does not have a well defined input source. Input <em>could</em> come from
command-line arguments, but this is uncommon. Input is more likely to come from
registry keys, network data, etc.</li>
</ol>
<p>For these reasons, analysing malware in S2E is not as simple as making
command-line arguments symbolic, or feeding the program a symbolic file. This
blog post will walk through the S2E-based tools that we developed for malware
analysis, followed by two &ldquo;case studies&rdquo;. As usual, if you wish to play along
at home you can find all of the code on
<a href="https://github.com/adrianherrera/malware-s2e">Github</a>.</p>
<h2 id="analysing-windows-software-in-s2e">Analysing Windows software in S2E</h2>
<p>Up until now, we have only analysed Linux programs. Fortunately, S2E also
supports the analysis of Windows programs. So what&rsquo;s the difference?</p>
<ol>
<li>When building a Windows guest image, a Windows ISO must be provided to
the <code>image_build</code> command. ISOs for all versions of Windows supported by S2E
(listed <a href="https://github.com/S2E/guest-images/blob/master/images.json">here</a>)
can be downloaded from <a href="https://msdn.microsoft.com/">MSDN</a>. It is also possible
to <a href="https://github.com/S2E/guest-tools/tree/master/windows#adding-support-for-new-kernels">add support for other
versions</a>
if required. For this post we&rsquo;ll use Windows 7 Professional 32-bit.</li>
<li>There is no equivalent to
<a href="https://github.com/S2E/guest-tools/blob/master/linux/s2e.so/s2e.c"><code>s2e.so</code></a>
on Windows. Therefore, we&rsquo;ll need an alternative approach to inject symbolic
data into our malware. We could write an S2E plugin to do this, but this is
complex. Instead, we&rsquo;ll use DLL injection in the guest to hook Windows API
calls and inject symbolic data through these hooks.</li>
</ol>
<h2 id="hooking-the-windows-api">Hooking the Windows API</h2>
<p>There are many different techniques for hooking the Windows API. We&rsquo;ll use an
&ldquo;off the shelf&rdquo; solution rather than (re)inventing a new one. When I first
started this work, I wanted to reuse <a href="https://cuckoosandbox.org/">Cuckoo
Sandbox</a>&rsquo;s
<a href="http://cuckoo-monitor.readthedocs.io/en/latest/">Monitor</a> for API hooking (as
it was designed for malware analysis). However, we decided to use
<a href="https://easyhook.github.io/">EasyHook</a> instead, primarily because it
required less work to get started with.</p>
<p>Before we dive into some code, here&rsquo;s an overview of what we are going to
build:</p>
<ul>
<li><code>malware-inject</code>: A program that will start other programs (e.g. malware) and
inject a DLL into the newly-started process&rsquo; address space; and</li>
<li><code>malware-hook</code>: A DLL that is injected into a process&rsquo; address space via
<code>malware-inject</code>. This DLL will hook key functions from the Windows API,
providing us with a mechanism to inject symbolic data.</li>
</ul>
<p>Now let&rsquo;s dive into some code!</p>
<p>We&rsquo;ll start by opening <code>$S2EDIR/source/s2e/guest/windows/s2e.sln</code> in Visual
Studio and creating two new projects:</p>
<ul>
<li><code>malware-inject</code>: A Win32 console application; and</li>
<li><code>malware-hook</code>: A Win32 DLL.</li>
</ul>
<p>Both projects require the EasyHook native package, installable via
<a href="https://www.nuget.org/">Nuget</a>. Note that in the Github repo the
<code>malware-hook</code> project is split into <code>GetLocalTime-hook</code> and <code>wannacry-hook</code>
projects (our two case studies).</p>
<h2 id="malware-inject"><code>malware-inject</code></h2>
<p><code>malware-inject</code> is based on EasyHook&rsquo;s example
<a href="https://easyhook.github.io/tutorials/nativeremotehook.html">injector</a>
application. However, instead of using <code>RhInjectLibrary</code> (which injects a DLL
into an already-running process), we&rsquo;ll use <code>RhCreateAndInject</code>. This function
starts an application in a suspended state, injects a DLL and then resumes the
suspended process. <code>malware-inject</code> will also wait for the injected process to
complete before returning. This is useful because it prevents S2E killing
states when the <code>malware-inject</code> process exits.</p>
<p>Create <code>inject.c</code> and add the following code to it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Shlwapi.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;easyhook.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// We must add this header file to support writing to S2E&#39;s logs. s2e.h resides
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// in the libcommon project, so the libcommon project must be added as a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// dependency to the malware-inject project
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define USER_APP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/s2e.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define S2E_MSG_LEN 512
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX_PATH_LEN 256
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> INT s2eVersion <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Message</span>(LPCSTR fmt, ...) {
</span></span><span style="display:flex;"><span>  CHAR message[S2E_MSG_LEN];
</span></span><span style="display:flex;"><span>  va_list args;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">va_start</span>(args, fmt);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">vsnprintf</span>(message, S2E_MSG_LEN, fmt, args);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">va_end</span>(args);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (s2eVersion) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">S2EMessageFmt</span>(<span style="color:#e6db74">&#34;[malware-inject] %s&#34;</span>, message);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[malware-inject] %s&#34;</span>, message);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">GetFullPath</span>(LPCWSTR path, PWCHAR fullPath) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>path) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Message</span>(<span style="color:#e6db74">&#34;Path has not been provided</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">PathFileExistsW</span>(path)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Message</span>(<span style="color:#e6db74">&#34;Invalid path %S has been provided</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, path);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">GetFullPathNameW</span>(path, MAX_PATH_LEN, fullPath, NULL)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Message</span>(<span style="color:#e6db74">&#34;Unable to get full path of %S</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, path);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  INT argc;
</span></span><span style="display:flex;"><span>  LPWSTR <span style="color:#f92672">*</span>argv <span style="color:#f92672">=</span> <span style="color:#a6e22e">CommandLineToArgvW</span>(<span style="color:#a6e22e">GetCommandLineW</span>(), <span style="color:#f92672">&amp;</span>argc);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Usage: %S [options..]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>           <span style="color:#e6db74">&#34;   --dll &lt;dll&gt;       Path to DLL to inject into the application</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>           <span style="color:#e6db74">&#34;   --app &lt;target&gt;    Path to application to start</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>           <span style="color:#e6db74">&#34;   --timeout &lt;time&gt;  Timeout value in milliseconds &#34;</span>
</span></span><span style="display:flex;"><span>           <span style="color:#e6db74">&#34;(infinite if not provided)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Used by the Message function to decide where to write output to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  s2eVersion <span style="color:#f92672">=</span> <span style="color:#a6e22e">S2EGetVersion</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  LPWSTR dllPath <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  WCHAR fullDllPath[MAX_PATH_LEN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  LPWSTR appPath <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  WCHAR fullAppPath[MAX_PATH_LEN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  DWORD timeout <span style="color:#f92672">=</span> INFINITE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> argc; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">wcscmp</span>(argv[i], <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;--dll&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>      dllPath <span style="color:#f92672">=</span> argv[<span style="color:#f92672">++</span>i];
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">wcscmp</span>(argv[i], <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;--app&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>      appPath <span style="color:#f92672">=</span> argv[<span style="color:#f92672">++</span>i];
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">wcscmp</span>(argv[i], <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;--timeout&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>      timeout <span style="color:#f92672">=</span> <span style="color:#a6e22e">wcstoul</span>(argv[<span style="color:#f92672">++</span>i], NULL, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Message</span>(<span style="color:#e6db74">&#34;Unsupported argument: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[i]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Check that the given paths are valid
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">GetFullPath</span>(dllPath, fullDllPath);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">GetFullPath</span>(appPath, fullAppPath);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Start the target application (in a suspended state) and inject the given DLL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ULONG pid;
</span></span><span style="display:flex;"><span>  NTSTATUS result <span style="color:#f92672">=</span> <span style="color:#a6e22e">RhCreateAndInject</span>(appPath, <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;&#34;</span>, CREATE_SUSPENDED,
</span></span><span style="display:flex;"><span>    EASYHOOK_INJECT_DEFAULT,
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(_M_IX86)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    dllPath, NULL,
</span></span><span style="display:flex;"><span><span style="color:#75715e">#elif defined(_M_X64)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    NULL, dllPath,
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#error &#34;Platform not supported&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    NULL, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>pid);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">FAILED</span>(result)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Message</span>(<span style="color:#e6db74">&#34;RhCreateAndInject failed: %S</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">RtlGetLastErrorString</span>());
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Message</span>(<span style="color:#e6db74">&#34;Successfully injected %S into %S (PID=0x%x)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, fullDllPath,
</span></span><span style="display:flex;"><span>    fullAppPath, pid);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  DWORD exitCode <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Get a handle to the newly-created process and wait for it to terminate.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Once the process has terminated, get its return code and return that as
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// our return code
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  HANDLE hProcess <span style="color:#f92672">=</span> <span style="color:#a6e22e">OpenProcess</span>(SYNCHRONIZE <span style="color:#f92672">|</span> PROCESS_QUERY_INFORMATION,
</span></span><span style="display:flex;"><span>    FALSE, pid);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (hProcess) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">WaitForSingleObject</span>(hProcess, timeout);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">GetExitCodeProcess</span>(hProcess, <span style="color:#f92672">&amp;</span>exitCode);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">CloseHandle</span>(hProcess);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Message</span>(<span style="color:#e6db74">&#34;Unable to open process 0x%x: 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pid, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> exitCode;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Of course, it is entirely possible that the malware will be watching for API
hooks (we are dealing with malicious software after all!). Whilst an important
issue, we won&rsquo;t deal with it in this post.</p>
<p>Now that we&rsquo;ve written the tool to run our malware with an injected DLL, let&rsquo;s
turn our attention to what this DLL actually does.</p>
<h2 id="malware-hook"><code>malware-hook</code></h2>
<p>Likewise, we&rsquo;ll base <code>malware-hook</code> on EasyHook&rsquo;s example
<a href="https://easyhook.github.io/tutorials/nativeremotehook.html">BeepHook</a> DLL.
Here is the skeleton of our hook DLL, which we&rsquo;ll put in <code>malware-hook.cpp</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;strsafe.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;easyhook.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define USER_APP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/s2e.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define S2E_MSG_LEN 512
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> INT s2eVersion <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Message</span>(LPCSTR fmt, ...) {
</span></span><span style="display:flex;"><span>  CHAR message[S2E_MSG_LEN];
</span></span><span style="display:flex;"><span>  va_list args;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  va_start(args, fmt);
</span></span><span style="display:flex;"><span>  vsnprintf(message, S2E_MSG_LEN, fmt, args);
</span></span><span style="display:flex;"><span>  va_end(args);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (s2eVersion) {
</span></span><span style="display:flex;"><span>    S2EMessageFmt(<span style="color:#e6db74">&#34;[0x%x|malware-hook] %s&#34;</span>, GetCurrentProcessId(), message);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;[0x%x|malware-hook] %s&#34;</span>, GetCurrentProcessId(), message);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// EasyHook will be looking for this export to support DLL injection. If not
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// found then DLL injection will fail
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__declspec</span>(dllexport) <span style="color:#66d9ef">__stdcall</span> NativeInjectionEntryPoint(REMOTE_ENTRY_INFO <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__stdcall</span> <span style="color:#a6e22e">NativeInjectionEntryPoint</span>(REMOTE_ENTRY_INFO <span style="color:#f92672">*</span>inRemoteInfo) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Unused
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>) inRemoteInfo;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Used by the Message function to decide where to write output to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  s2eVersion <span style="color:#f92672">=</span> S2EGetVersion();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// TODO initialize hooks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The process was started in a suspended state. Wake it up...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  RhWakeUpProcess();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So, what are we going to hook? Let&rsquo;s take some inspiration from two great
papers on this topic: David Brumley&rsquo;s &ldquo;<a href="http://www.keylogger.org/articles/botnet_book-2007.pdf">Automatically Identifying Trigger-based
Behaviour in Malware</a>&rdquo;
and Andreas Moser&rsquo;s &ldquo;<a href="http://analysis.seclab.tuwien.ac.at/papers/explore.pdf">Exploring Multiple Execution Paths for Malware
Analysis</a>&rdquo;. Both of
these papers look at &ldquo;trigger-based malware&rdquo;, which is malware whose malicious
actions only occur under specific circumstances; i.e. when certain <em>trigger
conditions</em> are met. For example, malware may only launch its payload on a
specific date (as the <a href="https://en.wikipedia.org/wiki/Mydoom">MyDoom</a> worm did),
or upon receiving specific data from a command &amp; control server. In these two
examples, the <em>trigger sources</em> are the current date/time and data read from a
network. Other trigger sources include (as listed in Moser&rsquo;s paper):</p>
<ul>
<li>Internet connectivity;</li>
<li>Mutex objects;</li>
<li>Existence of files;</li>
<li>Existence of Registry entries; and</li>
<li>Data read from a file.</li>
</ul>
<p>How can we analyse trigger-based malware? Brumley&rsquo;s paper proposed Minesweeper,
a tool designed to detect the existence of trigger-based behaviours and to find
inputs that exercise these behaviours. As far as I can tell, Minesweeper was
never publicly released. However, we can build a very similar system in S2E
using our <code>malware-hook</code> DLL! So let&rsquo;s go ahead and create hooks for some of
the trigger sources discussed in these two papers.</p>
<h2 id="case-study-1-getlocaltime-test">Case study 1: <code>GetLocalTime-test</code></h2>
<p>The first trigger source that Brumley&rsquo;s paper explores is
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724338">GetLocalTime</a>.
<code>GetLocalTime</code> has the following prototype:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> WINAPI <span style="color:#a6e22e">GetLocalTime</span>(
</span></span><span style="display:flex;"><span>  _Out_ LPSYSTEMTIME lpSystemTime
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>In Minesweeper, the user was required to specify where in memory the trigger
inputs will be stored. This was so the symbolic execution engine could properly
assign symbolic variables during execution. In the case of <code>GetLocalTime</code>, this
would require specifying that <code>GetLocalTime</code> stores its result in a 16-byte
structure pointed to by a stack value when <code>GetLocalTime</code> is called.
Fortunately, we don&rsquo;t have to worry about these low-level details. Instead, we
can just call <code>S2EMakeSymbolic</code> on the variable we pass to <code>GetLocalTime</code>.
Here&rsquo;s how we do this in <code>malware-hook</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Function hooks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> WINAPI <span style="color:#a6e22e">GetLocalTimeHook</span>(LPSYSTEMTIME lpSystemTime) {
</span></span><span style="display:flex;"><span>  Message(<span style="color:#e6db74">&#34;Intercepted GetLocalTime</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Call the original GetLocalTime to get a concrete value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  GetLocalTime(lpSystemTime);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Make the value concolic
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  S2EMakeSymbolic(lpSystemTime, <span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>lpSystemTime), <span style="color:#e6db74">&#34;SystemTime&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The names of the functions to hook (and the library they belong to)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> LPCSTR functionsToHook[][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  { <span style="color:#e6db74">&#34;kernel32&#34;</span>, <span style="color:#e6db74">&#34;GetLocalTime&#34;</span>} ,
</span></span><span style="display:flex;"><span>  { NULL, NULL },
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The function hooks that we will install
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> PVOID hookFunctions[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  GetLocalTimeHook,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The actual hooks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> HOOK_TRACE_INFO hooks[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  { NULL },
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// This function was defined previously
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__stdcall</span> <span style="color:#a6e22e">NativeInjectionEntryPoint</span>(REMOTE_ENTRY_INFO <span style="color:#f92672">*</span>inRemoteInfo) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Replace the previous TODO with the following code to install the GetLocalTime hook
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; functionsToHook[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> NULL; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    LPCSTR moduleName <span style="color:#f92672">=</span> functionsToHook[i][<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    LPCSTR functionName <span style="color:#f92672">=</span> functionsToHook[i][<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Install the hook
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    NTSTATUS result <span style="color:#f92672">=</span> LhInstallHook(
</span></span><span style="display:flex;"><span>      GetProcAddress(GetModuleHandleA(moduleName), functionName),
</span></span><span style="display:flex;"><span>      hookFunctions[i],
</span></span><span style="display:flex;"><span>      NULL,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&amp;</span>hooks[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (FAILED(result)) {
</span></span><span style="display:flex;"><span>      Message(<span style="color:#e6db74">&#34;Failed to hook %s.%s: %S</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, moduleName, functionName,
</span></span><span style="display:flex;"><span>              RtlGetLastErrorString());
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      Message(<span style="color:#e6db74">&#34;Successfully hooked %s.%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, moduleName, functionName);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Ensure that all threads _except_ the injector thread will be hooked
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ULONG ACLEntries[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>    LhSetExclusiveACL(ACLEntries, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>hooks[i]);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Let&rsquo;s implement the running example that Brumley et al. used in their paper
(Fig. 1.1) to test that everything works as expected.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ddos</span> (LPCSTR target) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// DDOS code goes here :)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  SYSTEMTIME systime;
</span></span><span style="display:flex;"><span>  LPCSTR site <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;www.usenix.org&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">GetLocalTime</span>(<span style="color:#f92672">&amp;</span>systime);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">9</span> <span style="color:#f92672">==</span> systime.wDay) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">10</span> <span style="color:#f92672">==</span> systime.wHour) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">11</span> <span style="color:#f92672">==</span> systime.wMonth) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">6</span> <span style="color:#f92672">==</span> systime.wMinute) {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">ddos</span>(site);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Ensure that you compile everything for the x86 platform (since we&rsquo;ll be using
a 32-bit Windows 7 VM). Once everything is built (including the VM!), we can
create a new project:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>s2e new_project -i windows-7sp1pro-i386 /path/to/malware-s2e/GetLocalTime-test/Debug/GetLocalTime-test.exe
</span></span></code></pre></div><p>Note that this will create a <code>bootstrap.sh</code> that executes
<code>GetLocalTime-test.exe</code> directly. We must modify <code>bootstrap.sh</code> to have
<code>malware-inject.exe</code> execute <code>GetLocalTime-test.exe</code> instead. To do this we&rsquo;ll
need access to our hooking tools from within the VM. We can do this by
executing the following command in our S2E environment to create the necessary
symbolic links in our project directory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cd $S2EDIR/projects/GetLocalTime-test
</span></span><span style="display:flex;"><span>HOOK_FILES<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;EasyHook32.dll malware-hook.dll malware-inject.exe&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> FILE in $HOOK_FILES; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  ln -s $S2EDIR/source/s2e/guest/windows/Debug/$FILE $FILE
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span></code></pre></div><p>And then edit <code>bootstrap.sh</code> as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># ...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># The target does not get executed directly - we execute it via malware-inject</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> execute_target <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  local TARGET
</span></span><span style="display:flex;"><span>  TARGET<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  ./malware-inject.exe --dll <span style="color:#e6db74">&#34;./malware-hook.dll&#34;</span> --app <span style="color:#e6db74">${</span>TARGET<span style="color:#e6db74">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># We also need to download the files required for hooking</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Download the target file to analyze</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">${</span>S2EGET<span style="color:#e6db74">}</span> <span style="color:#e6db74">&#34;GetLocalTime-test.exe&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">${</span>S2EGET<span style="color:#e6db74">}</span> <span style="color:#e6db74">&#34;EasyHook32.dll&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">${</span>S2EGET<span style="color:#e6db74">}</span> <span style="color:#e6db74">&#34;malware-hook.dll&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">${</span>S2EGET<span style="color:#e6db74">}</span> <span style="color:#e6db74">&#34;malware-inject.exe&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ...</span>
</span></span></code></pre></div><p>Finally, we can disable the following plugins in <code>s2e-config.lua</code> (they are not
required):</p>
<ul>
<li><code>WebServiceInterface</code></li>
<li><code>KeyValueStore</code></li>
<li><code>MultiSearcher</code></li>
<li><code>CUPASearcher</code></li>
<li><code>StaticFunctionModels</code></li>
</ul>
<p>We are now ready to run our analysis!</p>
<h3 id="results">Results</h3>
<p>We should see S2E fork four times during our analysis. If we enable the
<code>--verbose-fork-info</code> KLEE argument (in <code>s2e-config.lua</code>) we can see the
constraints generated at each of these four fork points. The following image
shows a disassembly with these points highlighted.</p>
<figure><a href="/img/getlocaltime_test-binja.png"><img src="/img/getlocaltime_test-binja.png"
         alt="GetLocalTime-test fork points"/></a>
</figure>

<p><code>ReadLSB w16 X SystemTime</code> can be understood as &ldquo;read 16 bits (i.e. one <code>WORD</code>)
at offset <code>X</code> in the symbolic <code>SystemTime</code> variable. If we look up the
<code>SYSTEMTIME</code> struct on
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724950">MSDN</a> we
will see that each <code>WORD</code> at these offsets (<code>0x6</code>, <code>0x8</code>, <code>0x2</code>, <code>0xA</code>)
corresponds with the <code>wDay</code>, <code>wHour</code>, <code>wMonth</code> and <code>wMinute</code> fields
respectively - just as expected. Finally, we should find a line in <code>debug.txt</code>
containing the following test case (I&rsquo;ve reformatted the line and added the
field names to make it easier to read):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>TestCaseGenerator:  v0_SystemTime_0 <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wYear */</span>
</span></span><span style="display:flex;"><span>                                       <span style="color:#ae81ff">0xb</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wMonth */</span>
</span></span><span style="display:flex;"><span>                                       <span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wDayOfWeek */</span>
</span></span><span style="display:flex;"><span>                                       <span style="color:#ae81ff">0x9</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wDay */</span>
</span></span><span style="display:flex;"><span>                                       <span style="color:#ae81ff">0xa</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wHour */</span>
</span></span><span style="display:flex;"><span>                                       <span style="color:#ae81ff">0x6</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wMinute */</span>
</span></span><span style="display:flex;"><span>                                       <span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wSecond */</span>
</span></span><span style="display:flex;"><span>                                       <span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">0x0</span>} <span style="color:#75715e">/* wMilliseconds */</span>
</span></span></code></pre></div><p>If we cross-reference this against <code>GetLocalTime-test/test.c</code> we can see that
this is the time to launch the DDOS. Success!</p>
<h2 id="case-study-2-wannacry">Case study 2: WannaCry</h2>
<p>That was nice, but malware has moved on since the Minesweeper paper was written
in 2007. Let&rsquo;s look at something a bit more recent - the
<a href="https://en.wikipedia.org/wiki/WannaCry_ransomware_attack">WannaCry</a>
ransomware. WannaCry famously contained a &ldquo;killswitch&rdquo; that stopped the
ransomware from encrypting the target&rsquo;s data. This killswitch was a check for
whether a gibberish URL led to a live webpage. WannaCry would shut down if this
URL could be reached (this check was probably done to fool dynamic analysis
tools, which are typically configured to return valid, dummy responses to all
network queries). With this in mind, let&rsquo;s use S2E to explore WannaCry&rsquo;s
behaviour when this trigger condition is <strong>and</strong> isn&rsquo;t satisfied. We&rsquo;ll focus
on the sample discussed in Amanda Rousseau&rsquo;s excellent
<a href="https://www.endgame.com/blog/technical-blog/wcrywanacry-ransomware-technical-analysis">writeup</a>
(MD5 hash db349b97c37d22f5ea1d1841e3c89eb4).</p>
<h3 id="disassembly">Disassembly</h3>
<p>Let&rsquo;s take a quick look at the WannaCry killswitch in a disassembler.</p>
<figure><a href="/img/wannacry-killswitch.png"><img src="/img/wannacry-killswitch.png"
         alt="WannaCry killswitch"/></a>
</figure>

<p>We can see that the
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa385331">WinINet</a>
API is used to open a connection to the killswitch URL
(hxxp://www[.]iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea[.]com). The following
functions are called to do this:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/windows/desktop/api/wininet/nf-wininet-internetopena">InternetOpenA</a>:
Initializes the WinINet system. Returns an <code>HINTERNET</code> handle on success, or
<code>NULL</code> on failure.</li>
<li><a href="https://docs.microsoft.com/en-us/windows/desktop/api/wininet/nf-wininet-internetopenurla">InternetOpenUrlA</a>:
Using the handle returned by <code>InternetOpenA</code>, open a resource specified by the
given URL. Returns an <code>HINTERNET</code> handle on success, or <code>NULL</code> on failure.</li>
<li><a href="https://docs.microsoft.com/en-us/windows/desktop/api/wininet/nf-wininet-internetclosehandle">InternetCloseHandle</a>:
Close the handles opened by <code>InternetOpenA</code> and <code>InternetOpenUrlA</code>.</li>
</ul>
<p>At a minimum we must hook <code>InternetOpenUrlA</code> and force a fork to explore both
paths at <code>0x4081a5</code>. What about <code>InternetOpenA</code>? We can see in the WannaCry
code that the <code>HINTERNET</code> handle returned by <code>InternetOpenA</code> is never checked,
so we don&rsquo;t have to worry about this function. If the returned handle was
(properly) checked, we may have needed to hook <code>InternetOpenA</code> and force it to
return some dummy, non-<code>NULL</code> value. Similarly, if we were interested in the
code executed when <code>InternetOpenA</code> fails, we could also force a fork on some
symbolic value. However, for simplicity we&rsquo;ll just focus on <code>InternetOpenUrlA</code>.
Let&rsquo;s write some more code!</p>
<h3 id="wininet-hooks">WinINet hooks</h3>
<p>First, replace the hooked functions in <code>malware-hook.cpp</code> with the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> LPCSTR functionsToHook[][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  { <span style="color:#e6db74">&#34;wininet&#34;</span>, <span style="color:#e6db74">&#34;InternetOpenUrlA&#34;</span> },
</span></span><span style="display:flex;"><span>  { <span style="color:#e6db74">&#34;wininet&#34;</span>, <span style="color:#e6db74">&#34;InternetCloseHandle&#34;</span> },
</span></span><span style="display:flex;"><span>  { NULL, NULL },
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> PVOID hookFunctions[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  InternetOpenUrlAHook,
</span></span><span style="display:flex;"><span>  InternetCloseHandleHook,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> HOOK_TRACE_INFO hooks[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  { NULL },
</span></span><span style="display:flex;"><span>  { NULL },
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Then write the actual hook functions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/// Keep track of dummy Internet handles that we&#39;ve created
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>HINTERNET<span style="color:#f92672">&gt;</span> dummyHandles;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> HINTERNET WINAPI <span style="color:#a6e22e">InternetOpenUrlAHook</span>(
</span></span><span style="display:flex;"><span>  HINTERNET hInternet,
</span></span><span style="display:flex;"><span>  LPCSTR lpszUrl,
</span></span><span style="display:flex;"><span>  LPCSTR lpszHeaders,
</span></span><span style="display:flex;"><span>  DWORD dwHeadersLength,
</span></span><span style="display:flex;"><span>  DWORD dwFlags,
</span></span><span style="display:flex;"><span>  DWORD_PTR dwContext
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Message</span>(<span style="color:#e6db74">&#34;Intercepted InternetOpenUrlA(%p, %s, %s, 0x%x, 0x%x, %p)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>    hInternet, lpszUrl, lpszHeaders, dwHeadersLength, dwFlags, dwContext);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Force a fork via a symbolic variable. Since both branches are feasible,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// both paths are taken
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UINT8 returnResource <span style="color:#f92672">=</span> <span style="color:#a6e22e">S2ESymbolicChar</span>(<span style="color:#e6db74">&#34;hInternet&#34;</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (returnResource) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Explore the program when InternetOpenUrlA &#34;succeeds&#34; by returning a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// dummy resource handle. Because we know that the resource handle is never
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// used, we don&#39;t have to do anything fancy to create it.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// However, we will need to keep track of it so we can free it when the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// handle is closed.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    HINTERNET resourceHandle <span style="color:#f92672">=</span> (HINTERNET) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(HINTERNET));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Record the dummy handle so we can clean up afterwards
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    dummyHandles.<span style="color:#a6e22e">insert</span>(resourceHandle);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> resourceHandle;
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Explore the program when InternetOpenUrlA &#34;fails&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> BOOL WINAPI <span style="color:#a6e22e">InternetCloseHandleHook</span>(HINTERNET hInternet) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Message</span>(<span style="color:#e6db74">&#34;Intercepted InternetCloseHandle(%p)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, hInternet);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>HINTERNET<span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> dummyHandles.<span style="color:#a6e22e">find</span>(hInternet);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">==</span> dummyHandles.<span style="color:#a6e22e">end</span>()) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The handle is not one of our dummy handles, so call the original
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// InternetCloseHandle function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">InternetCloseHandle</span>(hInternet);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The handle is a dummy handle. Free it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">free</span>(<span style="color:#f92672">*</span>it);
</span></span><span style="display:flex;"><span>    dummyHandles.<span style="color:#a6e22e">erase</span>(it);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here we follow the approach taken in S2E&rsquo;s <a href="https://github.com/S2E/docs/blob/master/src/Tutorials/WindowsDrivers/FaultInjection.rst">multi-path fault injection
tutorial</a>.
The <code>returnResource</code> symbolic variable forces a fork, resulting in one state
where <code>InternetOpenUrlA</code> succeeds (by returning a dummy resource) and another
state where <code>InternetOpenUrlA</code> fails (by returning <code>NULL</code>). We can return a
dummy resource handle because the <code>InternetOpenUrlA</code> handle is never actually
used: remember, WannCry only checks if it is <code>NULL</code>. The <code>InternetCloseHandle</code>
hook then cleans up the allocated memory. Now let&rsquo;s hook and run WannaCry in
S2E.</p>
<h3 id="initial-results">Initial results</h3>
<p>We can follow the same procedure that we used for <code>GetLocalTime-test</code> to set up
an S2E project for WannaCry. Remember to make symbolic links to EasyHook32.dll,
malware-hook.dll and malware-inject.exe and <code>s2eget</code> them in the bootstrap
script.</p>
<p>Before running S2E, enable the <code>LibraryCallMonitor</code> plugin in <code>s2e-config.lua</code>.
This plugin monitors and logs external library function calls, which gives us a
better picture of what WannaCry is doing. When you run S2E, you should see a
fork in <code>malware-hook</code>&rsquo;s address space (likely hidden amongst <strong>a lot</strong> of
debug output produced by <code>LibraryCallMonitor</code>). If you follow the library calls
made by the WannaCry executable (instead of all the other DLLs loaded in its
address space), you should see the following library calls in state 0:</p>
<table>
<thead>
<tr>
<th>Address</th>
<th>DLL</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x4081bc</td>
<td>wininet</td>
<td>InternetCloseHandle</td>
</tr>
<tr>
<td>0x4081bf</td>
<td>wininet</td>
<td>InternetCloseHandle</td>
</tr>
<tr>
<td>0x409b4e</td>
<td>msvcrt</td>
<td>exit</td>
</tr>
</tbody>
</table>
<p>While in state 1 you should see:</p>
<table>
<thead>
<tr>
<th>Address</th>
<th>DLL</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x4081a7</td>
<td>wininet</td>
<td>InternetCloseHandle</td>
</tr>
<tr>
<td>0x4081ab</td>
<td>wininet</td>
<td>InternetCloseHandle</td>
</tr>
<tr>
<td>0x40809f</td>
<td>kernel32</td>
<td>GetModuleFileNameA</td>
</tr>
<tr>
<td>0x4080a5</td>
<td>msvcrt</td>
<td>__p___argc</td>
</tr>
<tr>
<td>0x407c56</td>
<td>msvcrt</td>
<td>sprintf</td>
</tr>
<tr>
<td>0x407c68</td>
<td>advapi32</td>
<td>OpenSCManagerA</td>
</tr>
<tr>
<td>0x407c9b</td>
<td>advapi32</td>
<td>CreateServiceA</td>
</tr>
<tr>
<td>0x407cb2</td>
<td>advapi32</td>
<td>StartServiceA</td>
</tr>
<tr>
<td>&hellip;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>0x407d74</td>
<td>kernel32</td>
<td>FindResourceA</td>
</tr>
<tr>
<td>0x407d86</td>
<td>kernel32</td>
<td>LoadResource</td>
</tr>
<tr>
<td>0x407d95</td>
<td>kernel32</td>
<td>LockResource</td>
</tr>
<tr>
<td>0x407da9</td>
<td>kernel32</td>
<td>SizeofResource</td>
</tr>
<tr>
<td>&hellip;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>0x407ee8</td>
<td>kernel32</td>
<td>CreateProcessA</td>
</tr>
<tr>
<td>&hellip;</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>This looks good: we have successfully explored WannaCry&rsquo;s behaviour when the
killswitch was <strong>and</strong> wasn&rsquo;t triggered. Rousseau&rsquo;s writeup outlines WannaCry&rsquo;s
execution flow, and if we follow state 1&rsquo;s library calls we should see that the
execution flows match.</p>
<h3 id="hooking-process-creation">Hooking process creation</h3>
<p>Let&rsquo;s write one last hook. What happens if our hooked process spawns a new
process? This is pretty common for  &ldquo;dropper&rdquo; malware, and indeed WannaCry does
this by loading an executable (<code>tasksche.exe</code>) from a resource, writing it to
disk and then running it (via <code>CreateProcessA</code>). When this happens, we are
totally blind to what this new process is doing: both in terms of injecting
symbolic data via our hooks and tracking its behaviour with S2E (e.g. via the
<code>LibraryCallMonitor</code> plugin).</p>
<p>We can solve the former (losing our ability to inject symbolic data into the
new process) by hooking <code>CreateProcessA</code> and using the EasyHook API to inject
<code>malware-hook</code> into this new process. The following code achieves this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Don&#39;t forget to add CreateProcessA to the functionsToHook, hookFunctions and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// hooks arrays
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>BOOL WINAPI <span style="color:#a6e22e">CreateProcessAHook</span>(
</span></span><span style="display:flex;"><span>  LPCSTR                lpApplicationName,
</span></span><span style="display:flex;"><span>  LPSTR                 lpCommandLine,
</span></span><span style="display:flex;"><span>  LPSECURITY_ATTRIBUTES lpProcessAttributes,
</span></span><span style="display:flex;"><span>  LPSECURITY_ATTRIBUTES lpThreadAttributes,
</span></span><span style="display:flex;"><span>  BOOL                  bInheritHandles,
</span></span><span style="display:flex;"><span>  DWORD                 dwCreationFlags,
</span></span><span style="display:flex;"><span>  LPVOID                lpEnvironment,
</span></span><span style="display:flex;"><span>  LPCSTR                lpCurrentDirectory,
</span></span><span style="display:flex;"><span>  LPSTARTUPINFOA        lpStartupInfo,
</span></span><span style="display:flex;"><span>  LPPROCESS_INFORMATION lpProcessInformation
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>  Message(<span style="color:#e6db74">&#34;Intercepted CreateProcessA(%s, %s, %p, %p, %d, %d, %p, %s, %p, %p)&#34;</span>,
</span></span><span style="display:flex;"><span>    lpApplicationName, lpCommandLine, lpProcessAttributes,
</span></span><span style="display:flex;"><span>    lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment,
</span></span><span style="display:flex;"><span>    lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Get this DLL&#39;s path
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  HMODULE hDll <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  DWORD hModFlags <span style="color:#f92672">=</span> GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>    GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>GetModuleHandleEx(hModFlags, (LPCTSTR)<span style="color:#f92672">&amp;</span>Message, <span style="color:#f92672">&amp;</span>hDll)) {
</span></span><span style="display:flex;"><span>    Message(<span style="color:#e6db74">&#34;Failed to retrive DLL handle: 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLastError());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> default_create_process;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  WCHAR dllPath[MAX_PATH_LEN];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>GetModuleFileNameW(hDll, dllPath, MAX_PATH_LEN)) {
</span></span><span style="display:flex;"><span>    Message(<span style="color:#e6db74">&#34;Failed to retrive DLL path: 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLastError());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> default_create_process;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Create the new process, but force it to be created in a suspended state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>CreateProcessA(lpApplicationName, lpCommandLine, lpProcessAttributes,
</span></span><span style="display:flex;"><span>      lpThreadAttributes, bInheritHandles, dwCreationFlags <span style="color:#f92672">|</span> CREATE_SUSPENDED,
</span></span><span style="display:flex;"><span>      lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation)) {
</span></span><span style="display:flex;"><span>    Message(<span style="color:#e6db74">&#34;Failed to create suspended process: 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLastError());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> default_create_process;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Inject ourselves into the new, suspended process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// NativeInjectionEntryPoint will call RhWakeupProcess, which will kick
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// ourselves out of the suspended state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  NTSTATUS result <span style="color:#f92672">=</span> RhInjectLibrary(lpProcessInformation<span style="color:#f92672">-&gt;</span>dwProcessId,
</span></span><span style="display:flex;"><span>    lpProcessInformation<span style="color:#f92672">-&gt;</span>dwThreadId, EASYHOOK_INJECT_DEFAULT,
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(_M_IX86)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    dllPath, NULL,
</span></span><span style="display:flex;"><span><span style="color:#75715e">#elif defined(_M_X64)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    NULL, dllPath,
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#error &#34;Platform not supported&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    NULL, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (FAILED(result)) {
</span></span><span style="display:flex;"><span>    Message(<span style="color:#e6db74">&#34;RhInjectLibrary failed: %S</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, RtlGetLastErrorString());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> default_create_process;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Message(<span style="color:#e6db74">&#34;Successfully injected %S into %s %s (PID=0x%x)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dllPath,
</span></span><span style="display:flex;"><span>    lpApplicationName, lpCommandLine, lpProcessInformation<span style="color:#f92672">-&gt;</span>dwProcessId);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>default_create_process:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> CreateProcessA(lpApplicationName, lpCommandLine, lpProcessAttributes,
</span></span><span style="display:flex;"><span>    lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment,
</span></span><span style="display:flex;"><span>    lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This hook will start the new process in a suspended state and inject itself
into the new process. <code>malware-hook</code>&rsquo;s <code>NativeInjectionEntryPoint</code> function
is then responsible for waking the process up.</p>
<p>This solves the problem of injecting symbolic data into a new process started
by WannaCry. What about tracking this new process&rsquo; behaviour in S2E?
Unfortunately, this requires a bit more work. One approach could be to write an
S2E plugin that listened for <a href="https://github.com/S2E/libs2eplugins/blob/master/src/s2e/Plugins/OSMonitors/OSMonitor.h">OSMonitor</a>&rsquo;s
<code>onProcessLoad</code> signal. If a new process was found to originate from the
WannaCry process, we could add the new child process to
<a href="https://github.com/S2E/libs2eplugins/blob/master/src/s2e/Plugins/OSMonitors/Support/ProcessExecutionDetector.h">ProcessExecutionDetector</a>&rsquo;s
tracked modules. <code>LibraryCallMonitor</code> would then start emitting <code>onLibraryCall</code>
events for this new process, allowing us to track its behaviour too. Because I
wanted to avoid writing S2E plugins in this post, I&rsquo;ll leave this &ldquo;as an
exercise for the reader&rdquo;.</p>
<p>One last problem exists: The original WannaCry process terminates after it
starts <code>tasksche.exe</code>. This causes <code>malware-inject</code> to also terminate (remember
it calls <code>WaitForSingleObject</code>), leading to <code>bootstrap.sh</code> killing the current
(and only active) state. Unfortunately, this means that S2E will terminate
before we get to see WannaCry do something interesting (like encrypt our data).
The hacky way to fix this: add a <code>sleep</code> command after the call to <code>execute</code> in
<code>bootstrap.sh</code> (don&rsquo;t forget to set an appropriate amount of time to sleep
for). This is hacky because it means that we&rsquo;ll waste time sleeping in state 0
after WannaCry exits (and does nothing interesting). A better approach is to
wait for <code>tasksche.exe</code> (and any other child processes) to terminate. Let&rsquo;s add
a function to do this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Set a sensible timeout value (in milliseconds). Can also be INFINITE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define CHILD_PROCESS_TIMEOUT 10 * 1000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Keep track of child proceses (such as tasksche.exe)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>DWORD<span style="color:#f92672">&gt;</span> childPids;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> BOOL <span style="color:#a6e22e">WaitForChildProcesses</span>(DWORD timeout) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> retCode <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (childPids.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Convert the set of PIDS to a list of handles with the appropriate permissions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>HANDLE<span style="color:#f92672">&gt;</span> childHandles;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (DWORD pid : childPids) {
</span></span><span style="display:flex;"><span>      Message(<span style="color:#e6db74">&#34;Getting handle to process 0x%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pid);
</span></span><span style="display:flex;"><span>      HANDLE childHandle <span style="color:#f92672">=</span> OpenProcess(SYNCHRONIZE <span style="color:#f92672">|</span> PROCESS_QUERY_INFORMATION,
</span></span><span style="display:flex;"><span>        FALSE, pid);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (childHandle) {
</span></span><span style="display:flex;"><span>        childHandles.push_back(childHandle);
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        Message(<span style="color:#e6db74">&#34;Unable to open child process 0x%x: 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pid, GetLastError());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Wait for the processes to terminate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Message(<span style="color:#e6db74">&#34;Waiting %d ms for %d children processes to terminate...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>      timeout, childHandles.size());
</span></span><span style="display:flex;"><span>    DWORD waitRes <span style="color:#f92672">=</span> WaitForMultipleObjects(childHandles.size(),
</span></span><span style="display:flex;"><span>      childHandles.data(), TRUE, timeout);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (waitRes) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">case</span> WAIT_FAILED:
</span></span><span style="display:flex;"><span>        Message(<span style="color:#e6db74">&#34;Failed to wait for child processes: 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLastError());
</span></span><span style="display:flex;"><span>        retCode <span style="color:#f92672">=</span> FALSE;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">case</span> WAIT_TIMEOUT:
</span></span><span style="display:flex;"><span>        Message(<span style="color:#e6db74">&#34;Timeout - not all child processes may have terminated</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Close all handles
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (HANDLE handle : childHandles) {
</span></span><span style="display:flex;"><span>      CloseHandle(handle);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> retCode;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>WaitForChildProcesses</code> should be called when the hooked WannaCry process
exits. We can do this by adding <code>DLLMain</code> and checking for reason code
<code>DLL_PROCESS_DETACH</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>BOOL WINAPI <span style="color:#a6e22e">DllMain</span>(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> (fdwReason) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Don&#39;t exit until all child processes have terminated (or a timeout is reached)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">case</span> DLL_PROCESS_DETACH:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> WaitForChildProcesses(CHILD_PROCESS_TIMEOUT);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Finally, don&rsquo;t forget to add the following code to <code>CreateProcessAHook</code> to
track child processes. The child process should only be saved if it is
successfully hooked (i.e. before returning <code>TRUE</code>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// This function was defined previously
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> BOOL WINAPI <span style="color:#a6e22e">CreateProcessAHook</span>(
</span></span><span style="display:flex;"><span>  LPCSTR                lpApplicationName,
</span></span><span style="display:flex;"><span>  LPSTR                 lpCommandLine,
</span></span><span style="display:flex;"><span>  LPSECURITY_ATTRIBUTES lpProcessAttributes,
</span></span><span style="display:flex;"><span>  LPSECURITY_ATTRIBUTES lpThreadAttributes,
</span></span><span style="display:flex;"><span>  BOOL                  bInheritHandles,
</span></span><span style="display:flex;"><span>  DWORD                 dwCreationFlags,
</span></span><span style="display:flex;"><span>  LPVOID                lpEnvironment,
</span></span><span style="display:flex;"><span>  LPCSTR                lpCurrentDirectory,
</span></span><span style="display:flex;"><span>  LPSTARTUPINFOA        lpStartupInfo,
</span></span><span style="display:flex;"><span>  LPPROCESS_INFORMATION lpProcessInformation
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Save the newly-created process&#39; PID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  childPids.insert(lpProcessInformation<span style="color:#f92672">-&gt;</span>dwProcessId);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>If you comment out <code>GRAPHICS=-nographic</code> in <code>launch-s2e.sh</code> (to enable the QEMU
GUI), you&rsquo;ll eventually be rewarded with the following (depending on the value
chosen for <code>CHILD_PROCESS_TIMEOUT</code>):</p>
<figure><a href="/img/wannacry-s2e.png"><img src="/img/wannacry-s2e.png"
         alt="WannaCry infection"/></a>
</figure>

<h2 id="conclusion-and-next-steps">Conclusion and next steps</h2>
<p>In this post we&rsquo;ve looked at analysing Windows malware with S2E, essentially
recreating David Brumley&rsquo;s Minesweeper tool in S2E. Unlike programs we&rsquo;ve
looked at in previous posts, we had to come up with some new techniques to
inject symbolic data into our Windows programs. We used EasyHook to hook
&ldquo;trigger&rdquo; functions that are commonly used by malware to hide their behaviour.
While this approach worked well for our two case studies (which were admittedly
highly contrived), there are many avenues for improvement. These avenues
include:</p>
<ul>
<li>Hooking more of the Windows API. Brumley and Moser describe a number of
different trigger sources (e.g. network data, registry keys, etc.) that aren&rsquo;t
covered in this post.</li>
<li>Building more complex hooks. For example, our <code>InternetOpenUrlA</code> hook was
overly simplistic - it just returned a dummy handle allocated on the heap. If
this handle was later passed to a function like <code>InternetReadFile</code>, we&rsquo;d have
to hook this function as well. This is essentially the &ldquo;environment modelling&rdquo;
problem inherit in most symbolic execution engines.</li>
<li>Hiding our hooks from the malware being analysed. Some ideas including
porting Cuckoo Monitor to S2E or doing everything in an S2E plugin.</li>
<li>A broader study on real malware. Is this type of symbolic execution even
helpful for malware analysis? How common is trigger-based malware - can we get
away with just doing a dynamic analysis in Cuckoo Sandbox? Are the
obfuscation techniques discussed in Banescu&rsquo;s work on <a href="https://mediatum.ub.tum.de/doc/1343173/1343173.pdf">Code Obfuscation
Against Symbolic Execution Attacks</a>
used by malware authors, and if so how do they affect our analysis?</li>
</ul>
<p>Hopefully this post gives you the necessary background and tools to go and
look at some of these improvements. Maybe one day I&rsquo;ll even find the time to
look at some of them myself!</p>
<h2 id="edit">Edit</h2>
<p><strong>21/10/2018</strong>: I&rsquo;ve updated this post with a less-hacky way of waiting for
WannaCry&rsquo;s <code>tasksche.exe</code> to start encrypting data.</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>&#34;Targeting&#34; File Parsers with S2E and Kaitai Struct</title>
      <link>https://adrianherrera.github.io/posts/kaitai-s2e/</link>
      <pubDate>Mon, 23 Oct 2017 21:35:48 +1100</pubDate>
      
      <guid>https://adrianherrera.github.io/posts/kaitai-s2e/</guid>
      <description><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Recently I&rsquo;ve been playing around with file parsers in S2E. This typically
involves calling <code>s2ecmd symbfile</code> to make the parser&rsquo;s input symbolic and then
running S2E to explore different paths through the parser. However, this is a
relatively heavy-handed approach; it makes the entire input file one big
symbolic blob, which quickly causes
<a href="https://en.wikipedia.org/wiki/Symbolic_execution#Path_Explosion">path explosion</a>.
Additionally, we may only be interested in exploring paths that exercise
specific functionality.</p>
<p>So how can we achieve more targeted symbolic execution on file-based programs
such as parsers? One approach could be to write a custom S2E plugin that
handles the <code>onSymbolicVariableCreation</code> event and intercepts
<code>s2ecmd symbfile</code>. You could then write C++ code that iterated over the
symbolic data and adjusted what was symbolic/concrete. The downsides of this
approach should be evident: it is time consuming and error prone to write C++
code to do this; it requires knowledge of the input file format; and you would
have to repeat this process for different file formats. Can we do better?</p>
<h2 id="kaitai-struct">Kaitai Struct</h2>
<p>Let&rsquo;s briefly diverge from S2E and discuss <a href="http://kaitai.io">Kaitai Struct</a>.
Kaitai Struct is a tool for developing parsers for binary structures. It
provides a YAML-like language that allows for the concise definition of a
binary structure. The Kaitai Struct Compiler (<code>ksc</code>) then generates a parser
from this definition. This parser can be generated in a number of languages,
including C++, Python and Java.</p>
<p>Here is a partial definition of the ELF format in Kaitai Struct (taken from the
<a href="http://formats.kaitai.io/elf/index.html">format gallery</a>). It consists of a
number of &ldquo;attributes&rdquo; (e.g. <code>magic</code>, <code>abi_version</code>, etc.) which describe an
ELF file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">meta</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">id</span>: <span style="color:#ae81ff">elf</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">title</span>: <span style="color:#ae81ff">Executable and Linkable Format</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">application</span>: <span style="color:#ae81ff">SVR4 ABI and up, many *nix systems</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">license</span>: <span style="color:#ae81ff">CC0-1.0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ks-version</span>: <span style="color:#ae81ff">0.8</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">seq</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># e_ident[EI_MAG0]..e[EI_MAG3]</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">magic</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">size</span>: <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">contents</span>: [<span style="color:#ae81ff">0x7f</span>, <span style="color:#e6db74">&#34;ELF&#34;</span>]
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># e_ident[EI_CLASS]</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">bits</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">type</span>: <span style="color:#ae81ff">u1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">enum</span>: <span style="color:#ae81ff">bits</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># e_ident[EI_DATA]</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">endian</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">type</span>: <span style="color:#ae81ff">u1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">enum</span>: <span style="color:#ae81ff">endian</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># e_ident[EI_VERSION]</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">ei_version</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">type</span>: <span style="color:#ae81ff">u1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># e_ident[EI_OSABI]</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">abi</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">type</span>: <span style="color:#ae81ff">u1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">enum</span>: <span style="color:#ae81ff">os_abi</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">abi_version</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">type</span>: <span style="color:#ae81ff">u1</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">pad</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">size</span>: <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">header</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">type</span>: <span style="color:#ae81ff">endian_elf</span>
</span></span></code></pre></div><p>I strongly recommend reading the Kaitai Struct
<a href="http://doc.kaitai.io">documentation</a> to get the most out of this post, as I
will skip much of the detail here (mostly because I&rsquo;m not really an expert
myself!). Nevertheless, there is one feature that is worth singling out: the
&ldquo;<a href="http://doc.kaitai.io/ksy_reference.html#spec-process">processing spec</a>&rdquo;.</p>
<p>The processing spec allows you to apply a custom function that will &ldquo;process&rdquo;
an attribute in some way. For example, an attribute may be encrypted/encoded. A
processing spec can be applied to decrypt/decode this attribute at run time.</p>
<p>How is this relevant to symbolic execution? Suppose that we had an
<code>s2e_make_symbolic</code> processing spec, and by applying this spec to particular
attributes we would make <strong>only</strong> those parts of the input file symbolic. This
would give us more fine-grained control over S2E&rsquo;s state space and potentially
reduce the path explosion problem. All we need is a way to combine S2E and
Kaitai Struct to make this possible!</p>
<h2 id="combining-s2e-and-kaitai-struct">Combining S2E and Kaitai Struct</h2>
<p>We will use the <a href="https://www.lua.org">Lua</a> programming language to combine S2E
and Kaitai Struct. Using Lua allows us to reuse existing components — S2E
contains an embedded Lua interpreter (for parsing the S2E configuration file
and writing function/instruction
<a href="https://github.com/S2E/docs/blob/master/src/Plugins/Annotations.rst">annotations</a>),
while <code>ksc</code> is capable of generating Lua parsers. Thus, we can use <code>ksc</code> to
generate a Lua parser for our input file and embed this parser within the S2E
configuration file to make it accessible to S2E. (We could have used <code>ksc</code> to
generate a C++ parser, but this would require recompiling S2E every time we
wanted to use a different file format.) By selectively applying the
<code>s2e_make_symbolic</code> processing spec in our input definition, we can achieve
more targeted symbolic execution.</p>
<p>The remainder of this blog post will walk through how I combined S2E and Kaitai
Struct. I&rsquo;ll use the ELF definition (discussed previously) and
<a href="https://sourceware.org/binutils/docs/binutils/readelf.html">readelf</a> as a
practical example.</p>
<p>In an effort to make it easier for others to play with the code, I&rsquo;ve tried to
make it as stand-alone as possible — there are no modifications to S2E&rsquo;s core
engine or <code>ksc</code>. However, this means that the code is far from polished! The
code consists of the following components:</p>
<ul>
<li>A command-line tool (<code>s2e_kaitai_cmd</code>) that executes in the guest OS. This
tool reads the input file and invokes an S2E plugin to selectively make the
file symbolic;</li>
<li>An S2E plugin (<code>KaitaiStruct</code>) that invokes Lua code to run a parser
generated by <code>ksc</code>; and</li>
<li>A small amount of Lua glue between the S2E configuration file and the parser
generated by <code>ksc</code>.</li>
</ul>
<p>Each of these components are described below. The complete code is available
<a href="https://github.com/adrianherrera/kaitai-s2e">here</a>.</p>
<h3 id="the-s2e_kaitai_cmd-tool">The <code>s2e_kaitai_cmd</code> tool</h3>
<p>At the start of this post I mentioned that we would normally use
<code>s2ecmd symbfile</code> to make an input file symbolic. The <code>symbfile</code> command makes
an input file symbolic by:</p>
<ol>
<li>Opening the input file in read/write mode</li>
<li>Reading the input file into a buffer</li>
<li>Calling <code>s2e_make_symbolic</code> on the buffer</li>
<li>Writing the (now symbolic) buffer back to the original input file</li>
</ol>
<p>We&rsquo;ll take a similar approach, except we&rsquo;ll modify step (3) to:</p>
<ul>
<li>Invoke the <code>KaitaiStruct</code> plugin to selectively make the buffer symbolic</li>
</ul>
<p>To do this we&rsquo;ll add the following directories/files to our S2E environment:</p>
<ul>
<li><code>source/s2e/guest/common/s2e_kaitai_cmd/s2e_kaitai_cmd.c</code></li>
<li><code>source/s2e/guest/common/include/s2e/kaitai/commands.h</code></li>
</ul>
<p>I&rsquo;ll skip steps 1, 2 and 4 because they have already been implemented in
<a href="https://github.com/S2E/guest-tools/blob/master/common/s2ecmd/s2ecmd.c">s2ecmd</a>.
For step 3, we&rsquo;ll create a custom S2E command to invoke a plugin (described
later) that will selectively make the input file symbolic. The command
structure should be placed in
<code>source/s2e/guest/common/include/s2e/kaitai/commands.h</code>. It follows the
standard method for
<a href="https://github.com/S2E/guest-tools/blob/master/common/include/s2e/seed_searcher/commands.h">invoking</a>
<a href="https://github.com/S2E/guest-tools/blob/master/common/include/s2e/monitors/commands/linux.h">S2E</a>
<a href="https://github.com/S2E/guest-tools/blob/master/common/include/s2e/monitors/commands/raw.h">plugins</a>
from the guest:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> S2E_KAITAI_COMMANDS {
</span></span><span style="display:flex;"><span>  KAITAI_MAKE_SYMBOLIC,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> S2E_KAITAI_COMMAND_MAKE_SYMBOLIC {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Pointer to guest memory where the symbolic file has been loaded
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint64_t</span> InputFile;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Size of the input file (in bytes)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint64_t</span> FileSize;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 1 on success, 0 on failure
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint64_t</span> Result;
</span></span><span style="display:flex;"><span>} <span style="color:#a6e22e">__attribute__</span>((packed));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> S2E_KAITAI_COMMAND {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">enum</span> S2E_KAITAI_COMMANDS Command;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> S2E_KAITAI_COMMAND_MAKE_SYMBOLIC MakeSymbolic;
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>} <span style="color:#a6e22e">__attribute__</span>((packed));
</span></span></code></pre></div><p>We can then add the following function to <code>s2e_kaitai_cmd.c</code>. This function
takes a pointer to the file contents (which have been <code>read</code> into a buffer) and
the size of the buffer (determined with <code>lseek</code>), constructs the relevant
command and sends this command to S2E.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">s2e_kaitai_make_symbolic</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint8_t</span> <span style="color:#f92672">*</span>buffer, <span style="color:#66d9ef">unsigned</span> size) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> S2E_KAITAI_COMMAND cmd <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  cmd.Command <span style="color:#f92672">=</span> S2E_KAITAI_MAKE_SYMBOLIC;
</span></span><span style="display:flex;"><span>  cmd.MakeSymbolic.InputFile <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uintptr_t</span>) buffer;
</span></span><span style="display:flex;"><span>  cmd.MakeSymbolic.FileSize <span style="color:#f92672">=</span> size;
</span></span><span style="display:flex;"><span>  cmd.MakeSymbolic.Result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">s2e_invoke_plugin</span>(<span style="color:#e6db74">&#34;KaitaiStruct&#34;</span>, <span style="color:#f92672">&amp;</span>cmd, <span style="color:#66d9ef">sizeof</span>(cmd));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">int</span>) cmd.MakeSymbolic.Result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now we need an S2E plugin to handle this command.</p>
<h3 id="the-kaitaistruct-plugin">The <code>KaitaiStruct</code> plugin</h3>
<p>Let&rsquo;s start with a skeleton plugin (don&rsquo;t forget to add
<code>s2e/Plugins/KaitaiStruct.cpp</code> to the <code>add_library</code> command in
<code>source/s2e/libs2eplugins/src/CMakeLists.txt</code>).</p>
<p>The header file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#ifndef S2E_PLUGINS_KAITAI_STRUCT_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define S2E_PLUGINS_KAITAI_STRUCT_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/CorePlugin.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/Plugins/Core/BaseInstructions.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Forward declare the S2E command from s2e_kaitai_cmd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">S2E_KAITAI_COMMAND</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> s2e {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> plugins {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// In addition to extending the basic Plugin class, we must also implement the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// IPluginInvoker to handle custom S2E commands
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">KaitaiStruct</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Plugin, <span style="color:#66d9ef">public</span> IPluginInvoker {
</span></span><span style="display:flex;"><span>  S2E_PLUGIN
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  KaitaiStruct(S2E <span style="color:#f92672">*</span>s2e) <span style="color:#f92672">:</span> Plugin(s2e) { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">initialize</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The method from IPluginInvoker that we must implement to respond to a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// custom command. This method takes the current S2E state, a pointer to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// the custom command object and the size of the custom command object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">handleOpcodeInvocation</span>(S2EExecutionState <span style="color:#f92672">*</span>state,
</span></span><span style="display:flex;"><span>                                      <span style="color:#66d9ef">uint64_t</span> guestDataPtr,
</span></span><span style="display:flex;"><span>                                      <span style="color:#66d9ef">uint64_t</span> guestDataSize);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The name of the Lua function that will run the Kaitai Struct parser
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>string m_kaitaiParserFunc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// handleOpcodeInvocation will call this method to actually invoke the Lua function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">handleMakeSymbolic</span>(S2EExecutionState <span style="color:#f92672">*</span>state, <span style="color:#66d9ef">const</span> S2E_KAITAI_COMMAND <span style="color:#f92672">&amp;</span>command);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} <span style="color:#75715e">// namespace plugins
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#75715e">// namespace s2e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><p>And the CPP file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// From source/s2e/guest/common/include
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/kaitai/commands.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/ConfigFile.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/S2E.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/Utils.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;KaitaiStruct.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> s2e {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> plugins {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>S2E_DEFINE_PLUGIN(
</span></span><span style="display:flex;"><span>  KaitaiStruct,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Combine S2E and Kaitai Struct&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Dependencies
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#e6db74">&#34;LuaBindings&#34;</span>); <span style="color:#75715e">// Reuse the existing Lua binding code from the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                  <span style="color:#75715e">// function/instruction annotation plugins
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> KaitaiStruct<span style="color:#f92672">::</span>initialize() {
</span></span><span style="display:flex;"><span>  m_kaitaiParserFunc <span style="color:#f92672">=</span> s2e()<span style="color:#f92672">-&gt;</span>getConfig()<span style="color:#f92672">-&gt;</span>getString(
</span></span><span style="display:flex;"><span>    getConfigKey() <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;.parser&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> KaitaiStruct<span style="color:#f92672">::</span>handleMakeSymbolic(S2EExecutionState <span style="color:#f92672">*</span>state,
</span></span><span style="display:flex;"><span>                                      <span style="color:#66d9ef">const</span> S2E_KAITAI_COMMAND <span style="color:#f92672">&amp;</span>command) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// We&#39;ll finish this later
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> KaitaiStruct<span style="color:#f92672">::</span>handleOpcodeInvocation(S2EExecutionState <span style="color:#f92672">*</span>state,
</span></span><span style="display:flex;"><span>                                          <span style="color:#66d9ef">uint64_t</span> guestDataPtr,
</span></span><span style="display:flex;"><span>                                          <span style="color:#66d9ef">uint64_t</span> guestDataSize) {
</span></span><span style="display:flex;"><span>  S2E_KAITAI_COMMAND cmd;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 1. Validate the received command
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (guestDataSize <span style="color:#f92672">!=</span> <span style="color:#66d9ef">sizeof</span>(cmd)) {
</span></span><span style="display:flex;"><span>    getWarningsStream(state) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;S2E_KAITAI_COMMAND: Mismatched command &#34;</span>
</span></span><span style="display:flex;"><span>                             <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;structure size &#34;</span> <span style="color:#f92672">&lt;&lt;</span> guestDataSize <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 2. Read the command
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>state<span style="color:#f92672">-&gt;</span>mem()<span style="color:#f92672">-&gt;</span>read(guestDataPtr, <span style="color:#f92672">&amp;</span>cmd, guestDataSize)) {
</span></span><span style="display:flex;"><span>    getWarningsStream(state) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;S2E_KAITAI_COMMAND: Failed to read &#34;</span>
</span></span><span style="display:flex;"><span>                             <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;command</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 3. Handle the command
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">switch</span> (cmd.Command) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> KAITAI_MAKE_SYMBOLIC: {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">bool</span> success <span style="color:#f92672">=</span> handleMakeSymbolic(state, cmd);
</span></span><span style="display:flex;"><span>      cmd.MakeSymbolic.Result <span style="color:#f92672">=</span> success <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// Write the result back to the guest
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>state<span style="color:#f92672">-&gt;</span>mem()<span style="color:#f92672">-&gt;</span>write(guestDataPtr, cmd, guestDataSize)) {
</span></span><span style="display:flex;"><span>        getWarningsStream(State) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;S2E_KAITAI_COMMAND: Failed to &#34;</span>
</span></span><span style="display:flex;"><span>                                 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; write result to guest</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>        exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>      getWarningsStream(state) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;S2E_KAITAI_COMMAND: Invalid command &#34;</span>
</span></span><span style="display:flex;"><span>                               <span style="color:#f92672">&lt;&lt;</span> hexval(cmd.Command) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>      exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} <span style="color:#75715e">// namespace plugins
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#75715e">// namespace s2e
</span></span></span></code></pre></div><p>Our plugin has only one dependency: the <code>LuaBindings</code> plugin. This plugin
configures S2E&rsquo;s Lua interpreter and allows us to call Lua code in the S2E
configuration file.</p>
<p>The <code>handleOpcodeInvocation</code> method follows a similar pattern to other plugins
that implement <code>IPluginInvoker</code> (e.g.
<a href="https://github.com/S2E/libs2eplugins/blob/master/src/s2e/Plugins/Models/FunctionModels.cpp">FunctionModels</a>
and <a href="https://github.com/S2E/libs2eplugins/blob/master/src/s2e/Plugins/OSMonitors/Linux/BaseLinuxMonitor.h">LinuxMonitor</a>):</p>
<ol>
<li>Validate the received command by checking its size.</li>
<li>Read the command. Since the command is issued by the guest, it resides in
guest memory. Nothing in our command should be symbolic (remember it only
contains the input file&rsquo;s start address and size), so we can read this
memory concretely.</li>
<li>Handle the command. In this case we call another function (that we&rsquo;ll
discuss shortly) to invoke the Lua interpreter to parse the input file.</li>
<li>Indicate success/failure to the guest. We do this by setting a &ldquo;return code&rdquo;
in the command structure and writing the command back into guest memory.</li>
</ol>
<p>Let&rsquo;s finish <code>handleMakeSymbolic</code>. Since we are working with Lua code we must
include some extra header files:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/Plugins/Lua/Lua.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/Plugins/Lua/LuaS2EExecutionState.h&gt;</span><span style="color:#75715e">
</span></span></span></code></pre></div><p>And finally the function implementation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> KaitaiStruct<span style="color:#f92672">::</span>handleMakeSymbolic(S2EExecutionState <span style="color:#f92672">*</span>state,
</span></span><span style="display:flex;"><span>                                      <span style="color:#66d9ef">const</span> S2E_KAITAI_COMMAND <span style="color:#f92672">&amp;</span>command) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint64_t</span> addr <span style="color:#f92672">=</span> command.MakeSymbolic.InputFile;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint64_t</span> size <span style="color:#f92672">=</span> command.MakeSymbolic.FileSize;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span> data(size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Read the input file&#39;s contents from guest memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>state<span style="color:#f92672">-&gt;</span>mem()<span style="color:#f92672">-&gt;</span>read(addr, data.data(), <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">uint8_t</span>) <span style="color:#f92672">*</span> size)) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Get the Lua interpreter&#39;s state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  lua_State <span style="color:#f92672">*</span>L <span style="color:#f92672">=</span> s2e()<span style="color:#f92672">-&gt;</span>getConfig()<span style="color:#f92672">-&gt;</span>getState();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Wrap the current S2E execution state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  LuaS2EExecutionState <span style="color:#a6e22e">luaS2EState</span>(state);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Turn the input file into a Lua string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  luaL_Buffer luaBuff;
</span></span><span style="display:flex;"><span>  luaL_buffinit(L, <span style="color:#f92672">&amp;</span>luaBuff);
</span></span><span style="display:flex;"><span>  luaL_addlstring(<span style="color:#f92672">&amp;</span>luaBuff, (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>) data.data(), <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">uint8_t</span>) <span style="color:#f92672">*</span> size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Set up our function call on Lua&#39;s virtual stack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  lua_getglobal(L, m_kaitaiParserFunc.c_str());
</span></span><span style="display:flex;"><span>  Lunar<span style="color:#f92672">&lt;</span>LuaS2EExecutionState<span style="color:#f92672">&gt;::</span>push(L, <span style="color:#f92672">&amp;</span>luaS2EState);
</span></span><span style="display:flex;"><span>  lua_pushinteger(L, addr);
</span></span><span style="display:flex;"><span>  luaL_pushresult(<span style="color:#f92672">&amp;</span>luaBuff);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Call our Kaitai Struct parser function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  lua_call(L, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Hopefully this is relatively easy to understand (see
<a href="https://www.lua.org/manual/5.3/manual.html#4.8">here</a> for more information on
Lua&rsquo;s C API). First we read the input file into a Lua string for the Kaitai
Struct parser. Then, we call the Kaitai Struct parser function (which we&rsquo;ll
define in the following section).</p>
<p>We must set up the parser function&rsquo;s arguments before we can call it. A virtual
stack is used to pass values to Lua functions. The first item pushed onto this
stack is always the function name. Our parser function will be defined in Lua&rsquo;s
global namespace (for simplicity), so we can use <code>lua_getglobal</code> to retrieve
this function from the S2E configuration file and push it onto the stack. We
then push:</p>
<ol>
<li>The current S2E execution state;</li>
<li>The input file&rsquo;s start address (in guest memory); and</li>
<li>The contents of the input file (as a string).</li>
</ol>
<p>Now all that&rsquo;s left to do is to implement this parser in the S2E configuration
file.</p>
<h3 id="lua-scripts">Lua scripts</h3>
<p>First, we need to compile a Kaitai Struct format definition into a Lua parser.
Since we are going to be experimenting with readelf, let&rsquo;s create our readelf
project now and get the ELF definition from the Kaitai Struct gallery:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># Create the S2E project</span>
</span></span><span style="display:flex;"><span>s2e new_project -n readelf_kaitai readelf -h @@
</span></span><span style="display:flex;"><span>cd projects/readelf_kaitai
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Get the ELF Kaitai Struct definition and compile it</span>
</span></span><span style="display:flex;"><span>wget https://raw.githubusercontent.com/kaitai-io/kaitai_struct_formats/master/executable/elf.ksy
</span></span><span style="display:flex;"><span>ksc -t lua elf.ksy
</span></span></code></pre></div><p>This will generate <code>elf.lua</code>. Now let&rsquo;s try it out on a testcase from
<a href="http://lcamtuf.coredump.cx/afl/">AFL</a>. If you don&rsquo;t already have it, you&rsquo;ll
also need Kaitai Struct&rsquo;s <a href="https://github.com/kaitai-io/kaitai_struct_lua_runtime">Lua
runtime</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># Get Kaitai Struct&#39;s Lua runtime</span>
</span></span><span style="display:flex;"><span>git clone https://github.com/kaitai-io/kaitai_struct_lua_runtime lua_runtime
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Get the ELF testcase</span>
</span></span><span style="display:flex;"><span>wget https://raw.githubusercontent.com/mirrorer/afl/master/testcases/others/elf/small_exec.elf
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Parse the testcase</span>
</span></span><span style="display:flex;"><span>lua5.3 - <span style="color:#e6db74">&lt;&lt; EOF
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">package.path = package.path .. &#34;;./lua_runtime/?.lua&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">require(&#34;elf&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">inp = assert(io.open(&#34;small_exec.elf&#34;, &#34;rb&#34;))
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">testcase = Elf(KaitaiStream(inp))
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">print(&#34;testcase e_ehsize: &#34; .. testcase.header.e_ehsize)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EOF</span>
</span></span></code></pre></div><p>You should see a header size of 52 bytes (you can run
<code>readelf -h small_exec.elf</code> to confirm).</p>
<p>I originally stated that we&rsquo;d be using Kaitai Struct&rsquo;s processing spec to
target specific file attributes to make symbolic. Let&rsquo;s define this processing
spec in <code>lua_runtime/s2e_make_symbolic.lua</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">local</span> class <span style="color:#f92672">=</span> require(<span style="color:#e6db74">&#34;class&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>S2eMakeSymbolic <span style="color:#f92672">=</span> class.class()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">S2eMakeSymbolic</span>:<span style="color:#a6e22e">_init</span>(s2e_state, start_addr, curr_pos, name)
</span></span><span style="display:flex;"><span>  self._state <span style="color:#f92672">=</span> s2e_state
</span></span><span style="display:flex;"><span>  self._addr <span style="color:#f92672">=</span> start_addr <span style="color:#f92672">+</span> curr_pos
</span></span><span style="display:flex;"><span>  self._name <span style="color:#f92672">=</span> name
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">S2eMakeSymbolic</span>:<span style="color:#a6e22e">decode</span>(data)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> mem <span style="color:#f92672">=</span> self._state:mem()
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> size <span style="color:#f92672">=</span> data:len()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- The decode routine is called after the data has already been read, so we</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- must return to the start of the data in order to make it symbolic</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> addr <span style="color:#f92672">=</span> self._addr <span style="color:#f92672">-</span> size
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mem:makeConcolic(addr, size, self._name)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- Return the data unchanged</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> data
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>All we&rsquo;ve done here is define a new class, <code>S2eMakeSymbolic</code>, with a
constructor (<code>_init</code>) and a <code>decode</code> method. The constructor takes the
following arguments:</p>
<ol>
<li>The current S2E execution state;</li>
<li>The input file&rsquo;s start address (in guest memory);</li>
<li>The current position of the parser. This plus the start address tell us the
absolute memory address to make symbolic; and</li>
<li>The name of the symbolic variable.</li>
</ol>
<p>The ELF parser will automatically call <code>decode</code> when it encounters an attribute
with the <code>s2e_make_symbolic</code> processing spec applied. However, the <code>decode</code>
method is called <em>after</em> the data has been read from the input file, so we must
compensate for this when we make the data symbolic (by subtracting the size
of the memory region we just read).</p>
<p>Let&rsquo;s make something symbolic. We&rsquo;ll choose something simple for now — the ELF
header&rsquo;s <code>e_machine</code> field. In <code>elf.ksy</code> the <code>e_machine</code> field is defined under
the <code>endian_elf</code> type:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e"># The original definition of the e_machine field</span>
</span></span><span style="display:flex;"><span>- <span style="color:#f92672">id</span>: <span style="color:#ae81ff">machine</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">u2</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">enum</span>: <span style="color:#ae81ff">machine</span>
</span></span></code></pre></div><p>Processing specs can only be applied to byte arrays, so we must replace the
<code>type</code> specification with a byte array&rsquo;s <code>size</code> specification. Because the
original type was an unsigned 2-byte value, we can simply treat the <code>machine</code>
as a byte array of size 2. We must also remove the enum mapping, otherwise
<code>ksc</code> will raise a compilation error when it tries to apply an enum to a byte
array.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e"># Redefinition of the e_machine field to make it symbolic</span>
</span></span><span style="display:flex;"><span>- <span style="color:#f92672">id</span>: <span style="color:#ae81ff">machine</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">size</span>: <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">process</span>: <span style="color:#ae81ff">s2e_make_symbolic(s2e_state, start_addr, _io.pos, &#34;machine&#34;)</span>
</span></span></code></pre></div><p>Finally, we must propagate two additional arguments — the S2E execution state
and the input file&rsquo;s start address — from the parser&rsquo;s constructor to
<code>s2e_make_symbolic</code>. We do this with the &ldquo;params spec&rdquo;. The <code>machine</code> attribute
is nested under the <code>endian_elf</code> and top-level <code>elf</code> types, so the following
params spec must be defined under both.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">params</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">s2e_state</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">start_addr</span>
</span></span></code></pre></div><p>We must also modify the <code>header</code>&rsquo;s type from <code>endian_elf</code> to
<code>endian_elf(s2e_state, start_addr)</code>. This ensures that the two arguments are
passed to <code>endian_elf</code>&rsquo;s constructor. (If this is all getting a bit confusing,
remember that the full source code is available
<a href="https://github.com/adrianherrera/kaitai-s2e">here</a>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e"># The original header&#39;s type</span>
</span></span><span style="display:flex;"><span>- <span style="color:#f92672">id</span>: <span style="color:#ae81ff">header</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">endian_elf</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Redefined to propagate the S2E execution state and input file&#39;s start address</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># to the endian_elf type</span>
</span></span><span style="display:flex;"><span>- <span style="color:#f92672">id</span>: <span style="color:#ae81ff">header</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">endian_elf(s2e_state, start_addr)</span>
</span></span></code></pre></div><p>Now recompile <code>elf.ksy</code>. If you open <code>elf.lua</code> you should see that the
constructor (<code>Elf:_init</code>) now takes <code>s2e_state</code> and <code>start_addr</code> as its first
two arguments. These arguments are saved and later propagated to the
<code>S2eMakeSymbolic</code> constructor via the <code>Elf.EndianElf</code> constructor.</p>
<p>All that&rsquo;s left to do is write a small function in our S2E configuration file
that will instantiate and run our parser. This function is invoked by the
<code>handleMakeSymbolic</code> method in the <code>KaitaiStruct</code> plugin.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>package.path <span style="color:#f92672">=</span> package.path <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;;./lua_runtime/?.lua&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> stringstream <span style="color:#f92672">=</span> require(<span style="color:#e6db74">&#34;string_stream&#34;</span>)
</span></span><span style="display:flex;"><span>require(<span style="color:#e6db74">&#34;elf&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">make_symbolic_elf</span>(state, start_addr, buffer)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> ss <span style="color:#f92672">=</span> stringstream(buffer)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- This will kick-start the parser. We don&#39;t care about the final result</span>
</span></span><span style="display:flex;"><span>  Elf(state, start_addr, KaitaiStream(ss))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Enable and configure the necessary plugins</span>
</span></span><span style="display:flex;"><span>add_plugin(<span style="color:#e6db74">&#34;LuaBindings&#34;</span>)
</span></span><span style="display:flex;"><span>add_plugin(<span style="color:#e6db74">&#34;KaitaiStruct&#34;</span>)
</span></span><span style="display:flex;"><span>pluginsConfig.KaitaiStruct <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  parser <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;make_symbolic_elf&#34;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And we&rsquo;re done!</p>
<h2 id="experimenting-with-readelf">Experimenting with readelf</h2>
<p>We&rsquo;re finally ready to experiment with readelf. Before we do, modify the S2E
configuration file so that only the following plugins are enabled:</p>
<ul>
<li>BaseInstructions</li>
<li>HostFiles</li>
<li>Vmi</li>
<li>TranslationBlockCoverage</li>
<li>ModuleExecutionDetector</li>
<li>ForkLimiter</li>
<li>ProcessExecutionDetector</li>
<li>LinuxMonitor</li>
</ul>
<p>We&rsquo;ll also have to modify <code>bootstrap.sh</code>. Under <code>${S2EGET} &quot;readelf&quot;</code> add
<code>${S2EGET} &quot;small_exec.elf&quot;</code> to copy our testcase to the guest. In the
<code>prepare_inputs</code> function replace <code>truncate -s 256 ${SYMB_FILE}</code> with
<code>cp small_exec.elf ${SYMB_FILE}</code> to use our testcase. We won&rsquo;t replace the
<code>symbfile</code> command yet; let&rsquo;s get an initial idea of how readelf performs on a
fully symbolic file.</p>
<p>Run S2E for a minute or so before killing it. You should see many forked states
(I forked 136 states). Let&rsquo;s generate code coverage information:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># The actual disassembler isn&#39;t important</span>
</span></span><span style="display:flex;"><span>s2e coverage basic_block --disassembler<span style="color:#f92672">=</span>binaryninja readelf_kaitai
</span></span></code></pre></div><p>Where are these forks occurring? Many are in libc, due to readelf calling
<code>printf</code> on symbolic data. What about the forks that occur in readelf? The
following images show snippets of two functions from readelf:
<code>process_section_headers</code> and <code>init_dwarf_regnames</code>. Green basic blocks
indicate blocks that were executed by S2E. Fork points have also been annotated
with their constraints (in KLEE&rsquo;s
<a href="https://klee.github.io/docs/kquery/">KQuery</a> format):</p>
<figure><a href="/img/readelf-process_section_headers.png"><img src="/img/readelf-process_section_headers.png"
         alt="readelf proccess_section_headers code coverage"/></a><figcaption>
            <p>readelf&rsquo;s process_section_headers code coverage</p>
        </figcaption>
</figure>

<figure><a href="/img/readelf-init_dwarf_regnames.png"><img src="/img/readelf-init_dwarf_regnames.png"
         alt="readelf init_dwarf_regnames code coverage"/></a><figcaption>
            <p>readelf&rsquo;s init_dwarf_regnames code coverage</p>
        </figcaption>
</figure>

<p>Forking also occurs when checking:</p>
<ul>
<li>If the input file is an archive</li>
<li>The data encoding (little endian or big endian)</li>
<li>The section header table&rsquo;s file offset</li>
<li>If each section&rsquo;s <code>sh_link</code> and <code>sh_info</code> values are valid</li>
</ul>
<p>And at many other locations! Now let&rsquo;s try and reduce forking to only those
program paths that relate to the ELF header&rsquo;s <code>e_machine</code> field. Edit
<code>bootstrap.sh</code> and replace <code>${S2ECMD} symbfile ${SYMB_FILE}</code> with
<code>./s2e_kaitai_cmd ${SYMB_FILE}</code>. Now rerun S2E for a minute. During my run,
forking was limited to the <code>get_machine_name</code> and <code>init_dwarf_regnames</code>
functions, both of which have switch statements based on the value of
<code>e_machine</code>. Success!</p>
<p>Let&rsquo;s try and target a different field in the ELF file — the section header&rsquo;s
<code>sh_type</code>. Unlike the <code>e_machine</code> field, which only occurs once in the ELF
file, the <code>sh_type</code> can occur multiple times throughout the file (depending on
the number of sections in the ELF file).</p>
<p>Once again, we must propagate the S2E execution state and input file&rsquo;s start
address to the appropriate attribute in the ELF declaration. This time we must
add the params spec to the <code>section_header</code> type. The <code>type</code> attribute is
defined as an unsigned 4-byte enum, so we must change this to a 4 byte array so
that we can apply <code>s2e_make_symbolic</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e"># Elf(32|64)_Shdr</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">section_header</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">params</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">s2e_state</span>
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">start_addr</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">seq</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># sh_name</span>
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">name_offset</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">type</span>: <span style="color:#ae81ff">u4</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># sh_type</span>
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">type</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">size</span>: <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">process</span>: <span style="color:#ae81ff">s2e_make_symbolic(s2e_state, start_addr, _io.pos, &#34;sh_type&#34;)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ...</span>
</span></span></code></pre></div><p>We must also ensure that these two arguments are passed to the
<code>SectionHeader</code>&rsquo;s constructor. The section header can be found under the
<code>section_headers</code> instance:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e"># The original section_headers</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">section_headers</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">pos</span>: <span style="color:#ae81ff">section_header_offset</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">repeat</span>: <span style="color:#ae81ff">expr</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">repeat-expr</span>: <span style="color:#ae81ff">qty_section_header</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">size</span>: <span style="color:#ae81ff">section_header_entry_size</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">section_header</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Redefined for symbolic execution</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">section_headers</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">pos</span>: <span style="color:#ae81ff">section_header_offset</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">repeat</span>: <span style="color:#ae81ff">expr</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">repeat-expr</span>: <span style="color:#ae81ff">qty_section_header</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">size</span>: <span style="color:#ae81ff">section_header_entry_size</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">section_header(s2e_state, start_addr)</span>
</span></span></code></pre></div><p>Notice that <code>section_headers</code> is declared as an
&ldquo;<a href="http://doc.kaitai.io/ksy_reference.html#spec-instance">instance spec</a>&rdquo;. This
means that <code>section_headers</code> compiles to a function that will only parse the
section header on demand. Therefore we must access the <code>section_headers</code> to
force them to be parsed. To do this we must modify the <code>make_elf_symbolic</code>
function in <code>s2e-config.lua</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">make_symbolic_elf</span>(state, start_addr, buffer)
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- ...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- This will kick-start the parser. However, now we do care about the final</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- result, because we must access the section headers to force them to be</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- parsed</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> elf_file <span style="color:#f92672">=</span> Elf(state, start_addr, KaitaiStream(ss))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- This will kick-start the section header parser</span>
</span></span><span style="display:flex;"><span>  _ <span style="color:#f92672">=</span> elf_file.header.section_headers
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Run <code>ksc</code> to regenerate <code>elf.lua</code>. Before we rerun S2E, let&rsquo;s take a look at
<code>elf.lua</code>. In particular, the parsing of the section headers in the
<code>section_headers</code>&rsquo; <code>get</code> method:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Elf</span>.<span style="color:#a6e22e">EndianElf</span>.<span style="color:#a6e22e">property</span>.<span style="color:#a6e22e">section_headers</span>:<span style="color:#a6e22e">get</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- ...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, self.qty_section_header <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    self._raw__m_section_headers[i] <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">\</span>
</span></span><span style="display:flex;"><span>      self._io:read_bytes(self.section_header_entry_size)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> _io <span style="color:#f92672">=</span> KaitaiStream(stringstream(self._raw__m_section_headers[i]))
</span></span><span style="display:flex;"><span>    self._m_section_headers[i] <span style="color:#f92672">=</span> Elf.EndianElf.SectionHeader(self.s2e_state,
</span></span><span style="display:flex;"><span>                                                             self.start_addr,
</span></span><span style="display:flex;"><span>                                                             _io, self,
</span></span><span style="display:flex;"><span>                                                             self._root,
</span></span><span style="display:flex;"><span>                                                             self._is_le)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- ...</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Notice that <code>ksc</code> creates a local variable, <code>_io</code>, that gets passed to the
<code>SectionHeader</code> constructor. This <code>_io</code> variable contains the raw data that
will eventually be transformed into a <code>SectionHeader</code> object. Unfortunately,
this causes a problem for the <code>s2e_make_symbolic</code> processing spec.</p>
<p>Recall that the parser&rsquo;s current position (<code>_io.pos</code>) is passed to the
<code>s2e_make_symbolic</code> processing spec. Unfortunately, when the local <code>_io</code> stream
is created, this position is reset to zero, so using this position would result
in an incorrect memory address being made symbolic. Fortunately, we can fix
this with a small change to the Lua code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, self.qty_section_header <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- Get the absolute start address of the section header before it is parsed</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> _sec_hdr_start_addr <span style="color:#f92672">=</span> self.start_addr <span style="color:#f92672">+</span> self._io:pos()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  self._raw__m_section_headers[i] <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">\</span>
</span></span><span style="display:flex;"><span>    self._io:read_bytes(self.section_header_entry_size)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> _io <span style="color:#f92672">=</span> KaitaiStream(stringstream(self._raw__m_section_headers[i]))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- Use the section header&#39;s start address instead of the ELF&#39;s start address</span>
</span></span><span style="display:flex;"><span>  self._m_section_headers[i] <span style="color:#f92672">=</span> Elf.EndianElf.SectionHeader(self.s2e_state,
</span></span><span style="display:flex;"><span>                                                           _sec_hdr_start_addr,
</span></span><span style="display:flex;"><span>                                                           _io, self,
</span></span><span style="display:flex;"><span>                                                           self._root,
</span></span><span style="display:flex;"><span>                                                           self._is_le)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Yes, hacking the generated Lua code is kind of disgusting. However, it ensures
that the correct memory address is made symbolic. When I reran S2E, forking was
limited to <code>sh_type</code> comparisons in the <code>process_section_headers</code> function.
Success again!</p>
<h2 id="conclusions-and-future-work">Conclusions and future work</h2>
<p>In this post I&rsquo;ve looked at how we can perform more targeted symbolic execution
of file parsers. Rather than giving the parser a fully-symbolic input file
(which quickly leads to path explosion), we can use Kaitai Struct to target
specific parts of the input file to make symbolic. While this approach seems to
work, there are a few problems associated with it.</p>
<p>First, it relies on the user having a valid <em>seed</em> file to perform symbolic
execution with. This seed file must also contain data for the part of the
parser that we wish to exercise. For example, let&rsquo;s assume that we wanted to
apply this technique to a PNG parser. If we took
<a href="http://formats.kaitai.io/png/index.html">this</a> definition of a PNG file and
wanted to see what happened when the <code>bkgd_truecolor</code> attribute was made
symbolic, our PNG seed would also have to contain a <a href="http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.bKGD">background color
chunk</a>.
Otherwise  our parser would have nothing to make symbolic.</p>
<p>For similar reasons, we cannot just use the &ldquo;empty&rdquo; symbolic file that the S2E
bootstrap script creates. Why? Because when the Kaitai Struct parser executes,
it runs on concrete data contained in the file. The default symbolic file that
S2E creates is filled with <code>NULL</code> characters, so the parser would fail
instantly. Wouldn&rsquo;t it be cool if we could <a href="http://lcamtuf.blogspot.com.au/2014/11/pulling-jpegs-out-of-thin-air.html">pull files out of thin
air</a>?</p>
<p>Other issues stem from how we are using Kaitai Struct. This is not the fault of
Kaitai Struct; in fact the Kaitai Struct
<a href="http://doc.kaitai.io/faq.html">FAQ</a> explicitly states that the generated
parsers are not designed for this model of &ldquo;event-based&rdquo; parsing. We could have
modified <code>ksc</code> to generate code that required fewer manual modifications (e.g.
automatically generate the params spec, use non-lazy instance specs, always
keep track of the parser&rsquo;s absolute position, etc.), however for simplicity I
wanted to leave Kaitai Struct &ldquo;as is&rdquo;.</p>
<p>What about non file-based symbolic execution? For example, in my <a href="https://adrianherrera.github.io/posts/google-ctf-2016/">previous</a> post I showed how to use S2E to solve a CTF
challenge that used a command-line string as input. The approach described in
this post would not help in solving this CTF challenge. However, there is no
reason why the <code>KaitaiStruct</code> plugin could not be extended to work on
command-line strings. For example, we could define the CTF challenge&rsquo;s input
string in Kaitai Struct as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">meta</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">id</span>: <span style="color:#ae81ff">ctf-input</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">title</span>: <span style="color:#ae81ff">Google CTF input format</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ks-version</span>: <span style="color:#ae81ff">0.8</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">seq</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">prefix</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">size</span>: <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">contents</span>: <span style="color:#e6db74">&#34;CTF{&#34;</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">to_solve</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">size</span>: <span style="color:#ae81ff">63</span> <span style="color:#75715e"># total length of 67 bytes minus the 4 byte prefix</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">process</span>: <span style="color:#ae81ff">s2e_make_symbolic(s2e_state, start_addr, _io.pos, &#34;to_solve&#34;)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">params</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">s2e_state</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">start_addr</span>
</span></span></code></pre></div><p>With some additional code we could run this parser on the input string to make
only the last 63 bytes symbolic. This would allow us to remove the
<code>onSymbolicVariableCreation</code> method from the S2E
<a href="https://gist.github.com/adrianherrera/397dc68918374c81cf63e53e659bd083">plugin</a>.</p>
<p>Despite these problems, combining S2E and Kaitai Struct seemed to work fairly
well for the work that I was doing (although your mileage may vary!). We could
probably get around these problems with a bit more work (and a lot more code).
However, I think I&rsquo;ll save that for a future post :)</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Solving a CTF Challenge with S2E</title>
      <link>https://adrianherrera.github.io/posts/google-ctf-2016/</link>
      <pubDate>Tue, 08 Aug 2017 11:50:51 +0200</pubDate>
      
      <guid>https://adrianherrera.github.io/posts/google-ctf-2016/</guid>
      <description><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Symbolic execution tools such as <a href="http://angr.io">Angr</a> and
<a href="https://github.com/trailofbits/manticore">Manticore</a> have become increasingly
popular for analyzing binaries in Capture the Flag (CTF) challenges.</p>
<p>In this blog post I will show that we can do the same with S2E, using it to
solve a reverse engineering challenge from the 2016 Google CTF. This post
walks through the process of writing an S2E plugin &ldquo;from first principles&rdquo; to
solve this challenge.</p>
<p>For comparison, solutions for the challenge using
<a href="https://github.com/angr/angr-doc/blob/master/examples/google2016_unbreakable_0">Angr</a>
and <a href="https://github.com/trailofbits/manticore-examples/tree/master/google2016_unbreakable">Manticore</a>
are also available. If you want to cheat and skip straight to the end, the
final plugin code is available <a href="https://github.com/adrianherrera/unbreakable-ctf-s2e">here</a>.</p>
<h2 id="getting-started">Getting started</h2>
<p>As usual, I use <a href="https://github.com/S2E/s2e-env">s2e-env</a> to organize my S2E
environment. The challenge binary is a 64-bit ELF, so I will use S2E&rsquo;s Debian
x86_64 image. For those playing along at home, the instructions on how to
use s2e-env can be found
<a href="https://github.com/S2E/docs/blob/master/src/s2e-env.rst">here</a>.</p>
<h2 id="initial-analysis">Initial analysis</h2>
<p>The challenge binary is available
<a href="https://github.com/ctfs/write-ups-2016/tree/master/google-ctf-2016/reverse/unbreakable-enterprise-product-activation-150">here</a>.
As other
<a href="http://www.99cruster.com/blog/2016/05/02/google-ctf-2016-unbreakable-enterprise-product-activation-writeup-using-angr/">writeups</a>
have discussed, an initial static analysis reveals that the binary (a 64-bit
ELF executable) accepts a single command line argument (the product activation
code). If this argument is not provided the program will print a usage message
and exit.</p>
<figure><a href="/img/google-ctf-2016-binja.png"><img src="/img/google-ctf-2016-binja.png"
         alt="Disassembly view"/></a>
</figure>

<p>If the product activation code is provided, the argument is copied into the
global buffer <code>dest</code>. The <code>strncpy</code> operation (at address <code>0x4005B8</code>) copies 67
characters, so we can assume that the product activation code is 67 characters
long. We are also told that the product activation code starts with &ldquo;CTF{&rdquo;.</p>
<p>Further analysis reveals that the function at <code>0x400850</code> is called when an
incorrect product activation code is given. The correct product activation call
will result in the function at <code>0x400830</code> being called and the message &ldquo;Thank
you — product activated!&rdquo; printed. Therefore, when exploring the program we
want to focus on states that will lead to <code>0x400830</code> and avoid those that lead
to <code>0x400850</code>. With this information, we can develop an S2E plugin to solve the
challenge.</p>
<h2 id="creating-the-s2e-project">Creating the S2E project</h2>
<p>We can use s2e-env&rsquo;s <code>new_project</code> command to create a new analysis project for
the challenge. We can also use our knowledge about the product activation code
to automatically add the command line argument to the bootstrap script. Create
the project using the following command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>s2e new_project --image debian-8.7.1-x86_64 --sym-args<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1&#34;</span> unbreakable <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  <span style="color:#e6db74">`</span>python -c <span style="color:#e6db74">&#34;print(&#39;CTF{%s&#39; % (&#39;x&#39; * (67 - 4)))&#34;</span><span style="color:#e6db74">`</span>
</span></span></code></pre></div><p>The Python code will generate a 67 character string starting with &ldquo;CTF{&rdquo;.
<code>--sym-args=&quot;1&quot;</code> makes the first argument (i.e. the product activation code)
symbolic. Note that the actual contents of the string are not important.</p>
<p>The astute observer might also notice that the printed instructions contain a
message regarding S2E&rsquo;s <a href="https://github.com/S2E/docs/blob/master/src/Plugins/Linux/FunctionModels.rst">FunctionModels</a>
plugin. I will discuss how we can use this plugin later.</p>
<h2 id="writing-the-s2e-plugin">Writing the S2E plugin</h2>
<p>We will develop a custom plugin to solve the challenge. Note that this is
probably the more complex and time-consuming approach — you could also use
S2E&rsquo;s Lua annotations to avoid having to write C++ code. However, I think that
developing a plugin from scratch is a better way to understand how S2E works.</p>
<p>Let&rsquo;s start with the standard S2E plugin template. Create
<code>libs2eplugins/src/Plugins/GoogleCTFUnbreakable.h</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#ifndef S2E_PLUGINS_GOOGLE_CTF_UNBREAKABLE_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define S2E_PLUGINS_GOOGLE_CTF_UNBREAKABLE_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/CorePlugin.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/Plugin.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/S2E.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> s2e {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> plugins {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GoogleCTFUnbreakable</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Plugin {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Declares an S2E plugin
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  S2E_PLUGIN
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Our constructor doesn&#39;t need to do anything
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  GoogleCTFUnbreakable(S2E <span style="color:#f92672">*</span>s2e) <span style="color:#f92672">:</span> Plugin(s2e) { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// This will be called by S2E when registering and configuring the different plugins
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">initialize</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// We will add some more methods later
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} <span style="color:#75715e">// namespace plugins
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#75715e">// namespace s2e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><p>And in <code>libs2eplugins/src/Plugins/GoogleCTFUnbreakable.cpp</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/S2E.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;GoogleCTFUnbreakable.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> s2e {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> plugins {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>S2E_DEFINE_PLUGIN(
</span></span><span style="display:flex;"><span>  GoogleCTFUnbreakable, <span style="color:#75715e">// Plugin class
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#e6db74">&#34;Solve the Google CTF unbreakable product activation code&#34;</span>, <span style="color:#75715e">// Plugin description
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#75715e">// Unused
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>); <span style="color:#75715e">// Plugin dependencies (currently there are none)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> GoogleCTFUnbreakable<span style="color:#f92672">::</span>initialize() {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} <span style="color:#75715e">// namespace plugins
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#75715e">// namespace s2e
</span></span></span></code></pre></div><p>This is a perfectly valid S2E plugin, it just doesn&rsquo;t do anything useful. We
need to tell the plugin what events we are interested in and how to react to
them during runtime.
<a href="https://github.com/S2E/libs2ecore/blob/master/include/s2e/CorePlugin.h">CorePlugin.h</a>
gives an idea of what events are available. Events can also be generated by
other plugins. For example, the
<a href="https://github.com/S2E/libs2eplugins/blob/master/src/s2e/Plugins/OSMonitors/OSMonitor.h">OSMonitor</a>
plugin generates events for process creation, module loading/unloading, etc.</p>
<p>So what events are we interested in? From our initial analysis we know the
function addresses that indicate success or failure. We can therefore use the
<code>onTranslateInstructionStart</code> event to notify us when the code at these
addresses is translated by QEMU. Declare an event handler in
<code>GoogleCTFUnbreakable.h</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The method signature corresponds to the onTranslateInstructionStart signal template in CorePlugin.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> onTranslateInstruction(ExecutionSignal <span style="color:#f92672">*</span>signal,
</span></span><span style="display:flex;"><span>    S2EExecutionState <span style="color:#f92672">*</span>state, TranslationBlock <span style="color:#f92672">*</span>tb, <span style="color:#66d9ef">uint64_t</span> pc);
</span></span></code></pre></div><p>We also need to register our interest in this event, which we do in the
plugin&rsquo;s <code>initialize</code> method.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> GoogleCTFUnbreakable<span style="color:#f92672">::</span>initialize() {
</span></span><span style="display:flex;"><span>  s2e()<span style="color:#f92672">-&gt;</span>getCorePlugin()<span style="color:#f92672">-&gt;</span>onTranslateInstructionStart.connect(
</span></span><span style="display:flex;"><span>    sigc<span style="color:#f92672">::</span>mem_fun(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>, <span style="color:#f92672">&amp;</span>GoogleCTFUnbreakable<span style="color:#f92672">::</span>onTranslateInstruction));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This event occurs when code is translated by QEMU. We need to register another
event listener to notify our plugin when the code is actually executed. We do
this using the <code>ExecutionSignal</code> that is generated by the
<code>onTranslateInstructionStart</code> event. In <code>GoogleCTFUnbreakable.cpp</code> (don&rsquo;t
forget to add the method declarations to <code>GoogleCTFUnbreakable.h</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// We found these addresses during our initial analysis in IDA Pro.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Note that we assume non-PIE addresses
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint64_t</span> SUCCESS_ADDRESS <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x400724</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint64_t</span> FAILURE_ADDRESS <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x400850</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> GoogleCTFUnbreakable<span style="color:#f92672">::</span>onTranslateInstruction(ExecutionSignal <span style="color:#f92672">*</span>signal,
</span></span><span style="display:flex;"><span>    S2EExecutionState <span style="color:#f92672">*</span>state, TranslationBlock <span style="color:#f92672">*</span>tb, <span style="color:#66d9ef">uint64_t</span> pc) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (pc <span style="color:#f92672">==</span> SUCCESS_ADDRESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Register a handler for when the &#34;success&#34; code is executed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    signal<span style="color:#f92672">-&gt;</span>connect(sigc<span style="color:#f92672">::</span>mem_fun(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>, <span style="color:#f92672">&amp;</span>GoogleCTFUnbreakable<span style="color:#f92672">::</span>onSuccess));
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (pc <span style="color:#f92672">==</span> FAILURE_ADDRESS) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Register a handler for when the &#34;failure&#34; code is executed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    signal<span style="color:#f92672">-&gt;</span>connect(sigc<span style="color:#f92672">::</span>mem_fun(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>, <span style="color:#f92672">&amp;</span>GoogleCTFUnbreakable<span style="color:#f92672">::</span>onFailure));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> GoogleCTFUnbreakable<span style="color:#f92672">::</span>onSuccess(S2EExecutionState <span style="color:#f92672">*</span>state, <span style="color:#66d9ef">uint64_t</span> pc) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// We will return to this later
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> GoogleCTFUnbreakable<span style="color:#f92672">::</span>onFailure(S2EExecutionState <span style="color:#f92672">*</span>state, <span style="color:#66d9ef">uint64_t</span> pc) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// There is no reason to continue execution any further. So kill the state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  s2e()<span style="color:#f92672">-&gt;</span>getExecutor()<span style="color:#f92672">-&gt;</span>terminateStateEarly(<span style="color:#f92672">*</span>state, <span style="color:#e6db74">&#34;Invalid path&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Once execution reaches either the success or failure code, there is no reason
to continue. We therefore kill the state to avoid wasting resources.</p>
<p>Note that we use absolute addresses for our success and failure code. For
position independent code (PIE), you will need to register for module load
events, record the load address of the module you are interested in (in this
case unbreakable) and calculate the success and failure addresses via offsets
at run time.</p>
<p>Unfortunately, there is a problem with our plugin. Remember that S2E performs
full-system emulation, meaning other processes may be executing at the same
time that we are analyzing unbreakable. Virtual addressing also means that
there may be other processes that have code at <code>SUCCESS_ADDRESS</code> and
<code>FAILURE_ADDRESS</code>. If this code is executed, our plugin&rsquo;s <code>onSuccess</code> and
<code>onFailure</code> methods will execute, potentially interfering with our analysis.
We will avoid this problem with the
<a href="https://github.com/S2E/libs2eplugins/blob/master/src/s2e/Plugins/OSMonitors/Support/ProcessExecutionDetector.h">ProcessExecutionDetector</a>
plugin.</p>
<p>The <code>ProcessExecutionDetector</code> tracks the execution of processes in the
system. It is configurable so that only processes of interest are tracked. To
add this plugin as a dependency, in <code>GoogleCTFUnbreakable.cpp</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/Plugins/OSMonitors/Support/ProcessExecutionDetector.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>S2E_DEFINE_PLUGIN(
</span></span><span style="display:flex;"><span>  GoogleCTFUnbreakable,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Solve the Google CTF unbreakable product activation code&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;ProcessExecutionDetector&#34;</span>
</span></span><span style="display:flex;"><span>); <span style="color:#75715e">// Plugin dependency
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> GoogleCTFUnbreakable<span style="color:#f92672">::</span>initialize() {
</span></span><span style="display:flex;"><span>  m_procDetector <span style="color:#f92672">=</span> s2e()<span style="color:#f92672">-&gt;</span>getPlugin<span style="color:#f92672">&lt;</span>ProcessExecutionDetector<span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>And add the <code>ProcessExecutionDetector</code> as a private member of the
<code>GoogleCTFUnbreakable</code> class:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// In GoogleCTFUnbreakable.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GoogleCTFUnbreakable</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Plugin {
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  ProcessExecutionDetector <span style="color:#f92672">*</span>m_procDetector;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p>Now we can filter out all other processes <strong>except</strong> the unbreakable process.
The following code should be added to the <strong>beginning</strong> of the
<code>onTranslateInstruction</code> event handler:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> GoogleCTFUnbreakable<span style="color:#f92672">::</span>onTranslateInstruction(ExecutionSignal <span style="color:#f92672">*</span>signal,
</span></span><span style="display:flex;"><span>    S2EExecutionState <span style="color:#f92672">*</span>state, TranslationBlock <span style="color:#f92672">*</span>tb, <span style="color:#66d9ef">uint64_t</span> pc) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The processes to track are declared in the S2E LUA configuration file
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>m_procDetector<span style="color:#f92672">-&gt;</span>isTracked(state)) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>This takes care of our success and failure paths. What about the rest of our
initial analysis? Remember that we were told that the activation code begins
with &ldquo;CTF{&rdquo;. How can we encode this knowledge in our plugin?</p>
<p>Because we made the product activation string symbolic, we can use the
<code>onSymbolicVariableCreation</code> event to wait for the product activation code to
become symbolic, and then constrain this variable with our existing knowledge.
In <code>GoogleCTFUnbreakable.cpp</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;klee/util/ExprTemplatees.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Register our onSymbolicVariableCreation event handler
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> GoogleCTFUnbreakable<span style="color:#f92672">::</span>initialize() {
</span></span><span style="display:flex;"><span>  s2e()<span style="color:#f92672">-&gt;</span>getCorePlugin()<span style="color:#f92672">-&gt;</span>onSymbolicVariableCreation.connect(
</span></span><span style="display:flex;"><span>    sigc<span style="color:#f92672">::</span>mem_fun(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>, <span style="color:#f92672">&amp;</span>GoogleCTFUnbreakable<span style="color:#f92672">::</span>onSymbolicVariableCreation));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> GoogleCTFUnbreakable<span style="color:#f92672">::</span>onSymbolicVariableCreation(S2EExecutionState <span style="color:#f92672">*</span>state,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;</span>name, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>klee<span style="color:#f92672">::</span>ref<span style="color:#f92672">&lt;</span>klee<span style="color:#f92672">::</span>Expr<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">&amp;</span>expr,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> klee<span style="color:#f92672">::</span>MemoryObject <span style="color:#f92672">*</span>mo, <span style="color:#66d9ef">const</span> klee<span style="color:#f92672">::</span>Array <span style="color:#f92672">*</span>array) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// This check is not strictly required, because we only have one symbolic
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// variable in the analysis.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// The first program argument made symbolic with the S2E_SYM_ARGS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// environment variable will have the name &#34;arg1&#34;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (name <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;arg1&#34;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// We know that the product activation key starts with &#34;CTF{&#34;. We encode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// this information as KLEE constraints
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  state<span style="color:#f92672">-&gt;</span>constraints.addConstraint(E_EQ(expr[<span style="color:#ae81ff">0</span>], E_CONST(<span style="color:#e6db74">&#39;C&#39;</span>, klee<span style="color:#f92672">::</span>Expr<span style="color:#f92672">::</span>Int8)));
</span></span><span style="display:flex;"><span>  state<span style="color:#f92672">-&gt;</span>constraints.addConstraint(E_EQ(expr[<span style="color:#ae81ff">1</span>], E_CONST(<span style="color:#e6db74">&#39;T&#39;</span>, klee<span style="color:#f92672">::</span>Expr<span style="color:#f92672">::</span>Int8)));
</span></span><span style="display:flex;"><span>  state<span style="color:#f92672">-&gt;</span>constraints.addConstraint(E_EQ(expr[<span style="color:#ae81ff">2</span>], E_CONST(<span style="color:#e6db74">&#39;F&#39;</span>, klee<span style="color:#f92672">::</span>Expr<span style="color:#f92672">::</span>Int8)));
</span></span><span style="display:flex;"><span>  state<span style="color:#f92672">-&gt;</span>constraints.addConstraint(E_EQ(expr[<span style="color:#ae81ff">3</span>], E_CONST(<span style="color:#e6db74">&#39;{&#39;</span>, klee<span style="color:#f92672">::</span>Expr<span style="color:#f92672">::</span>Int8)));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Encoding this information in the form of additional constraints helps to speed
up symbolic execution. Now the constraint solver will not waste time generating
solutions which we know are not viable (e.g. activation codes beginning with
&ldquo;ABCD&rdquo;, &ldquo;1337&rdquo;, etc.).</p>
<p>We could have also encoded additional constraints for our solution. For
example, we can assume that none of the remaining characters is a NULL
terminator.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>; i <span style="color:#f92672">&lt;</span> expr.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>  state<span style="color:#f92672">-&gt;</span>constraints.addConstraint(E_NEQ(expr[i], E_CONST(<span style="color:#e6db74">&#39;\0&#39;</span>, klee<span style="color:#f92672">::</span>Expr<span style="color:#f92672">::</span>Int8)));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>An alternate set of constraints could be that the other remaining characters
are printable ASCII characters.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>; i <span style="color:#f92672">&lt;</span> expr.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>  state<span style="color:#f92672">-&gt;</span>constraints.addConstraint(E_GE(expr[i], E_CONST(<span style="color:#e6db74">&#39; &#39;</span>, klee<span style="color:#f92672">::</span>Expr<span style="color:#f92672">::</span>Int8)));
</span></span><span style="display:flex;"><span>  state<span style="color:#f92672">-&gt;</span>constraints.addConstraint(E_LE(expr[i], E_CONST(<span style="color:#e6db74">&#39;~&#39;</span>, klee<span style="color:#f92672">::</span>Expr<span style="color:#f92672">::</span>Int8)));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In practice I found that these additional constraints had a significant impact
on performance. I will discuss this later.</p>
<p>The final step is to complete the <code>onSuccess</code> method. This involves solving the
constraints accumulated during symbolic execution and displaying the result.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cctype&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sstream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> GoogleCTFUnbreakable<span style="color:#f92672">::</span>onSuccess(S2EExecutionState <span style="color:#f92672">*</span>state, <span style="color:#66d9ef">uint64_t</span> pc) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// `results` is a vector containing pairs of strings and a vector of bytes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// The string corresponds to the symbolic variable&#39;s name while the vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// of bytes is the actual solution
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;&gt;</span> results;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Invoke the constraint solver
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>s2e()<span style="color:#f92672">-&gt;</span>getExecutor()<span style="color:#f92672">-&gt;</span>getSymbolicSolution(<span style="color:#f92672">*</span>state, results)) {
</span></span><span style="display:flex;"><span>    getWarningsStream(state) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Unable to generate a solution for the product activation code</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Since we only have a single symbolic variable, we will only have a single
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// result. We then iterate over the bytes in this result to print the solution
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>stringstream ss;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> c : results[<span style="color:#ae81ff">0</span>].second) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>std<span style="color:#f92672">::</span>isprint(c)) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ss <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">char</span>) c;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  getInfoStream(state) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Product activation code = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ss.str() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// No need to continue running S2E — terminate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  exit(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>With the plugin complete, we need to ensure that it is compiled with the other
S2E plugins. To do this, add the following to <code>libs2eplugins/src/CMakeLists.txt</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">src/Plugins/GoogleCTFUnbreakable.cpp
</span></span></span></code></pre></div><p>S2E will need to be rebuilt to ensure that our plugin is compiled and available
for the analysis. Finally, we need to rebuild S2E with our plugin.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>s2e build --clean-target libs2e
</span></span></code></pre></div><h2 id="capturing-the-flag">Capturing the flag</h2>
<p>With the plugin complete, we can use it to solve the challenge. First, the
plugin must be enabled in our project&rsquo;s S2E config file. By default,
<code>s2e new_project</code> will generate a <code>s2e-config.lua</code> file with a standard set of
plugins enabled and configured. However, most of them are not needed for this
challenge. At a minimum the following plugins <strong>must</strong> be enabled:</p>
<ul>
<li><code>GoogleCTFUnbreakable</code></li>
<li><code>BaseInstructions</code></li>
<li><code>HostFiles</code></li>
<li><code>LinuxMonitor</code></li>
<li><code>ProcessExecutionDetector</code></li>
</ul>
<p>Finally, we can run S2E with the <code>launch-s2e.sh</code> script. After a short while
S2E will terminate and the following message will be displayed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>Product activation code <span style="color:#f92672">=</span> CTF<span style="color:#f92672">{</span>0The1Quick2Brown3Fox4Jumped5Over6The7Lazy8Fox9<span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="performance">Performance</h2>
<p>Let&rsquo;s return to the discussion on (1) the <code>FunctionModels</code> plugin and (2)
the performance impact caused by enforcing additional constraints on the
product activation code.</p>
<h3 id="using-the-functionmodels-plugin">Using the FunctionModels plugin</h3>
<p>The <a href="https://github.com/S2E/docs/blob/master/src/Plugins/Linux/FunctionModels.rst">FunctionModels</a>
plugin attempts to reduce <a href="https://en.wikipedia.org/wiki/Symbolic_execution#Path_Explosion">path explosion</a>.
<code>s2e-env</code> analyzes the binary when the <code>new_project</code> command is executed and
determines that the binary imports the <code>strncpy</code> function, for which a model
exists.</p>
<p><code>strncpy</code> is typically implemented as a loop over the input string until either
a NULL terminator is found or <code>n</code> characters have been copied. By analyzing the
binary in a disassembler we can see that this input string is the product
activation key, which we made symbolic. Looping over a symbolic string will
result in a greater number of states forked, because any of the 63 characters
following the &ldquo;CTF{&rdquo; prefix could contain a NULL terminator.</p>
<p>By enabling the <code>FunctionModels</code> plugin, the <code>strncpy</code> loop will be
replaced by a single symbolic expression, reducing the total number of states
forked. However, this comes with some performance trade-offs that I will
discuss later.</p>
<p>To enable the <code>FunctionModels</code> plugin, add the following to <code>s2e-config.lua</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>add_plugin(<span style="color:#e6db74">&#34;FunctionModels&#34;</span>)
</span></span></code></pre></div><h3 id="measuring-performance">Measuring performance</h3>
<p>With the flag under our belt, we can now explore the various performance
trade-offs that must be taken into account when we (1) apply various
constraints to the product activation code and (2) use the <code>FunctionModels</code>
plugin. Results are given in the tables below — one for execution time and one
for the number of states forked.</p>
<p>For the &ldquo;explore all states&rdquo; results I removed the call to <code>exit</code> in the
<code>onSuccess</code> method, even after capturing the flag (in practice this is
unnecessary). For reference I also give the Angr results (as quoted from their
source code) and Manticore results (from running it myself).</p>
<h5 id="execution-times">Execution times</h5>
<table>
<thead>
<tr>
<th>Description</th>
<th>Terminate on solution (secs)</th>
<th>Explore all states (secs)</th>
</tr>
</thead>
<tbody>
<tr>
<td>No additional constraints on the input string</td>
<td>12</td>
<td>240</td>
</tr>
<tr>
<td>No NULL terminator within the input string</td>
<td>12</td>
<td>12</td>
</tr>
<tr>
<td>All characters must be printable ASCII</td>
<td>3,180</td>
<td>3,180</td>
</tr>
<tr>
<td>Using FunctionModels</td>
<td>13</td>
<td>13</td>
</tr>
<tr>
<td>Angr</td>
<td>4.5</td>
<td>N/A</td>
</tr>
<tr>
<td>Manticore</td>
<td>60</td>
<td>N/A</td>
</tr>
</tbody>
</table>
<h5 id="no-of-states-forked">No. of states forked</h5>
<table>
<thead>
<tr>
<th>Description</th>
<th>Terminate on solution (no. states)</th>
<th>Explore all states (no. states)</th>
</tr>
</thead>
<tbody>
<tr>
<td>No additional constraints on the input string</td>
<td>111</td>
<td>1720</td>
</tr>
<tr>
<td>No NULL terminator within the input string</td>
<td>49</td>
<td>49</td>
</tr>
<tr>
<td>All characters must be printable ASCII</td>
<td>44</td>
<td>44</td>
</tr>
<tr>
<td>Using FunctionModels</td>
<td>49</td>
<td>49</td>
</tr>
<tr>
<td>Angr</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>Manticore</td>
<td>N/A</td>
<td>N/A</td>
</tr>
</tbody>
</table>
<p>The first set of results are our baseline. The only constraints that we impose
are that the product activation code begins with &ldquo;CTF{&rdquo;; the remaining 63
characters are unconstrained. Of the 111 states forked before the solution is
found, 62 of them occurred within <code>strncpy</code>. These 62 states correspond to the
NULL terminator being located within one of the remaining 63 characters
(e.g. &ldquo;CTF{\0&rdquo;, &ldquo;CTF{x\0&rdquo;, &ldquo;CTF{xxxxxxxx\0&rdquo;, etc.). However, the depth-first
search (DFS) strategy means that none of these 62 states is scheduled for
execution before the solution is found. The total number of states quickly
explodes otherwise.</p>
<p>Now look at the performance after we constrain the remaining 63 characters of
the product activation code to <strong>exclude</strong> the NULL terminator. The total
number of states is reduced to 49. While this has negligible impact on
execution time (when we terminate after the solution is found — again due to
DFS), the total number of states no longer explodes.</p>
<p>Performance degrades significantly when we over-constrain the product
activation code to <strong>only</strong> contain printable ASCII characters. While the total
number of states is reduced, the bottleneck is simply transferred from state
exploration to the constraint solver.</p>
<p><strong>NOTE</strong>: To view the symbolic formulae during execution the
<code>--verbose-fork-info</code> can be added to the <code>kleeArgs</code> table in <code>s2e-config.lua</code>.</p>
<p>Finally, we find that the <code>FunctionModels</code> plugin reduces the state space to
the same levels as when we excluded NULL terminators from the product
activation code. However, like when we over-constrain, the formula that the
constraint solver must solve grows increasingly complex after the <code>strncpy</code>
model is applied and the constraint solver once again becomes the bottleneck.</p>
<p>I personally find this trade-off between state space and constraint formulae
complexity quite interesting. AFAIK there are no automatic ways to determine
this trade-off; it can only be found through experimentation.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Compared to the Angr and Manticore solutions, solving this challenge with S2E
may seem overly complex. There are a variety of reasons for this: S2E runs a
full-system emulator, so the user must handle the full software stack (OS
kernel, libraries, drivers, etc.); S2E is written in C++; and S2E is built on
top of many different tools and frameworks (KLEE, QEMU, LLVM, etc.), each with
their own APIs.</p>
<p>Ultimately it is a matter of selecting the correct tool for the job. For
CTF-style challenges, where the program is largely self-contained and has very
little interaction with the rest of the system (e.g. the OS, libraries such as
libc, etc.), using full-system emulation is probably overkill (however, as I&rsquo;ve
hopefully demonstrated, it can be done!). However for more complex software
(e.g. device drivers, software with more complex interaction with the system,
etc.), S2E may be the more suitable choice.</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>About</title>
      <link>https://adrianherrera.github.io/pages/about/</link>
      <pubDate>Mon, 07 Aug 2017 07:00:31 +0200</pubDate>
      
      <guid>https://adrianherrera.github.io/pages/about/</guid>
      <description><![CDATA[<p>Hi there! My name is Adrian Herrera. I am a security researcher interested in
applying program analysis techniques to reverse engineering and software
security problems. This blog is mainly about those things.</p>
<p>In addition to my day job, I am a PhD student at the <a href="http://www.anu.edu.au/">Australian National
University</a> (ANU) under the supervision of <a href="http://hosking.github.io/">Tony
Hosking</a> (ANU),
<a href="https://comp.anu.edu.au/people/michael-norrish/">Michael Norrish</a> (ANU), and
<a href="https://nebelwelt.net/">Mathias Payer</a> (EPFL). In a previous life I worked on
the <a href="http://s2e.systems">S2E</a> symbolic execution engine. I regularly contribute
to open-source software (mostly focused around program analysis and software
security. Unsurprisingly).</p>
<p>When I&rsquo;m not breaking software I like to run, climb, and take
<a href="https://www.instagram.com/adrian.herrera87/">photos</a> of things (generally not
at the same time).</p>
]]></description>
      
    </item>
    
    
    
    
    
    
  </channel>
</rss>
