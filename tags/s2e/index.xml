<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet href="/feed_style.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="https://www.rssboard.org/media-rss">
  <channel>
    <title>S2e on Software Security from ⊤ to ⊥</title>
    <link>https://adrianherrera.github.io/tags/s2e/</link>
    <description>Recent content in S2e on Software Security from ⊤ to ⊥</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Copyright Adrian Herrera, all rights reserved.</copyright>
    <lastBuildDate>Sun, 02 Sep 2018 12:08:25 +1100</lastBuildDate><atom:link href="https://adrianherrera.github.io/tags/s2e/index.xml" rel="self" type="application/rss+xml" /><icon>https://adrianherrera.github.io/img/logo.png</icon>
    
    
    <item>
      <title>Analysing &#34;Trigger-based&#34; Malware with S2E</title>
      <link>https://adrianherrera.github.io/posts/malware-s2e/</link>
      <pubDate>Sun, 02 Sep 2018 12:08:25 +1100</pubDate>
      
      <guid>https://adrianherrera.github.io/posts/malware-s2e/</guid>
      <description><![CDATA[<h2 id="introduction">Introduction</h2>
<p>This blog post is a quick brain-dump of the work that I was doing during my
last month in the <a href="http://dslab.epfl.ch">Dependable Systems Lab</a> at
<a href="https://epfl.ch">EPFL</a>. At the time I was working on malware analysis with
S2E. While not anything earth-shatteringly novel, I&rsquo;m hopeful that this post
will help others who want to use symbolic execution/S2E to analyse malware
behaviour.</p>
<h2 id="what-makes-malware-analysis-different">What makes malware analysis different?</h2>
<p>My previous blog posts have looked at solving a <a href="https://adrianherrera.github.io/posts/google-ctf-2016/">CTF challenge</a> and analysing <a href="https://adrianherrera.github.io/posts/kaitai-s2e/">file parsers</a>. These programs had two things in common:</p>
<ol>
<li>They were Linux ELF executables; and</li>
<li>Program input was specified by the user — either via STDIN or from a file
that was read from disk.</li>
</ol>
<p>In contrast, <em>most</em> malware:</p>
<ol>
<li>Targets Windows (while some
<a href="https://www.av-test.org/fileadmin/pdf/security_report/AV-TEST_Security_Report_2016-2017.pdf">reports</a>
suggest that Android malware is on the rise, Windows remains the primary target
for malware authors); and</li>
<li>Does not have a well defined input source. Input <em>could</em> come from
command-line arguments, but this is uncommon. Input is more likely to come from
registry keys, network data, etc.</li>
</ol>
<p>For these reasons, analysing malware in S2E is not as simple as making
command-line arguments symbolic, or feeding the program a symbolic file. This
blog post will walk through the S2E-based tools that we developed for malware
analysis, followed by two &ldquo;case studies&rdquo;. As usual, if you wish to play along
at home you can find all of the code on
<a href="https://github.com/adrianherrera/malware-s2e">Github</a>.</p>
<h2 id="analysing-windows-software-in-s2e">Analysing Windows software in S2E</h2>
<p>Up until now, we have only analysed Linux programs. Fortunately, S2E also
supports the analysis of Windows programs. So what&rsquo;s the difference?</p>
<ol>
<li>When building a Windows guest image, a Windows ISO must be provided to
the <code>image_build</code> command. ISOs for all versions of Windows supported by S2E
(listed <a href="https://github.com/S2E/guest-images/blob/master/images.json">here</a>)
can be downloaded from <a href="https://msdn.microsoft.com/">MSDN</a>. It is also possible
to <a href="https://github.com/S2E/guest-tools/tree/master/windows#adding-support-for-new-kernels">add support for other
versions</a>
if required. For this post we&rsquo;ll use Windows 7 Professional 32-bit.</li>
<li>There is no equivalent to
<a href="https://github.com/S2E/guest-tools/blob/master/linux/s2e.so/s2e.c"><code>s2e.so</code></a>
on Windows. Therefore, we&rsquo;ll need an alternative approach to inject symbolic
data into our malware. We could write an S2E plugin to do this, but this is
complex. Instead, we&rsquo;ll use DLL injection in the guest to hook Windows API
calls and inject symbolic data through these hooks.</li>
</ol>
<h2 id="hooking-the-windows-api">Hooking the Windows API</h2>
<p>There are many different techniques for hooking the Windows API. We&rsquo;ll use an
&ldquo;off the shelf&rdquo; solution rather than (re)inventing a new one. When I first
started this work, I wanted to reuse <a href="https://cuckoosandbox.org/">Cuckoo
Sandbox</a>&rsquo;s
<a href="http://cuckoo-monitor.readthedocs.io/en/latest/">Monitor</a> for API hooking (as
it was designed for malware analysis). However, we decided to use
<a href="https://easyhook.github.io/">EasyHook</a> instead, primarily because it
required less work to get started with.</p>
<p>Before we dive into some code, here&rsquo;s an overview of what we are going to
build:</p>
<ul>
<li><code>malware-inject</code>: A program that will start other programs (e.g. malware) and
inject a DLL into the newly-started process&rsquo; address space; and</li>
<li><code>malware-hook</code>: A DLL that is injected into a process&rsquo; address space via
<code>malware-inject</code>. This DLL will hook key functions from the Windows API,
providing us with a mechanism to inject symbolic data.</li>
</ul>
<p>Now let&rsquo;s dive into some code!</p>
<p>We&rsquo;ll start by opening <code>$S2EDIR/source/s2e/guest/windows/s2e.sln</code> in Visual
Studio and creating two new projects:</p>
<ul>
<li><code>malware-inject</code>: A Win32 console application; and</li>
<li><code>malware-hook</code>: A Win32 DLL.</li>
</ul>
<p>Both projects require the EasyHook native package, installable via
<a href="https://www.nuget.org/">Nuget</a>. Note that in the Github repo the
<code>malware-hook</code> project is split into <code>GetLocalTime-hook</code> and <code>wannacry-hook</code>
projects (our two case studies).</p>
<h2 id="malware-inject"><code>malware-inject</code></h2>
<p><code>malware-inject</code> is based on EasyHook&rsquo;s example
<a href="https://easyhook.github.io/tutorials/nativeremotehook.html">injector</a>
application. However, instead of using <code>RhInjectLibrary</code> (which injects a DLL
into an already-running process), we&rsquo;ll use <code>RhCreateAndInject</code>. This function
starts an application in a suspended state, injects a DLL and then resumes the
suspended process. <code>malware-inject</code> will also wait for the injected process to
complete before returning. This is useful because it prevents S2E killing
states when the <code>malware-inject</code> process exits.</p>
<p>Create <code>inject.c</code> and add the following code to it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Shlwapi.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;easyhook.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// We must add this header file to support writing to S2E&#39;s logs. s2e.h resides
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// in the libcommon project, so the libcommon project must be added as a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// dependency to the malware-inject project
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define USER_APP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/s2e.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define S2E_MSG_LEN 512
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX_PATH_LEN 256
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> INT s2eVersion <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Message</span>(LPCSTR fmt, ...) {
</span></span><span style="display:flex;"><span>  CHAR message[S2E_MSG_LEN];
</span></span><span style="display:flex;"><span>  va_list args;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">va_start</span>(args, fmt);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">vsnprintf</span>(message, S2E_MSG_LEN, fmt, args);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">va_end</span>(args);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (s2eVersion) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">S2EMessageFmt</span>(<span style="color:#e6db74">&#34;[malware-inject] %s&#34;</span>, message);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[malware-inject] %s&#34;</span>, message);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">GetFullPath</span>(LPCWSTR path, PWCHAR fullPath) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>path) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Message</span>(<span style="color:#e6db74">&#34;Path has not been provided</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">PathFileExistsW</span>(path)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Message</span>(<span style="color:#e6db74">&#34;Invalid path %S has been provided</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, path);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">GetFullPathNameW</span>(path, MAX_PATH_LEN, fullPath, NULL)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Message</span>(<span style="color:#e6db74">&#34;Unable to get full path of %S</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, path);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  INT argc;
</span></span><span style="display:flex;"><span>  LPWSTR <span style="color:#f92672">*</span>argv <span style="color:#f92672">=</span> <span style="color:#a6e22e">CommandLineToArgvW</span>(<span style="color:#a6e22e">GetCommandLineW</span>(), <span style="color:#f92672">&amp;</span>argc);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Usage: %S [options..]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>           <span style="color:#e6db74">&#34;   --dll &lt;dll&gt;       Path to DLL to inject into the application</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>           <span style="color:#e6db74">&#34;   --app &lt;target&gt;    Path to application to start</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>           <span style="color:#e6db74">&#34;   --timeout &lt;time&gt;  Timeout value in milliseconds &#34;</span>
</span></span><span style="display:flex;"><span>           <span style="color:#e6db74">&#34;(infinite if not provided)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Used by the Message function to decide where to write output to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  s2eVersion <span style="color:#f92672">=</span> <span style="color:#a6e22e">S2EGetVersion</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  LPWSTR dllPath <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  WCHAR fullDllPath[MAX_PATH_LEN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  LPWSTR appPath <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  WCHAR fullAppPath[MAX_PATH_LEN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  DWORD timeout <span style="color:#f92672">=</span> INFINITE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> argc; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">wcscmp</span>(argv[i], <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;--dll&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>      dllPath <span style="color:#f92672">=</span> argv[<span style="color:#f92672">++</span>i];
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">wcscmp</span>(argv[i], <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;--app&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>      appPath <span style="color:#f92672">=</span> argv[<span style="color:#f92672">++</span>i];
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">wcscmp</span>(argv[i], <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;--timeout&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>      timeout <span style="color:#f92672">=</span> <span style="color:#a6e22e">wcstoul</span>(argv[<span style="color:#f92672">++</span>i], NULL, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Message</span>(<span style="color:#e6db74">&#34;Unsupported argument: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[i]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Check that the given paths are valid
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">GetFullPath</span>(dllPath, fullDllPath);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">GetFullPath</span>(appPath, fullAppPath);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Start the target application (in a suspended state) and inject the given DLL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ULONG pid;
</span></span><span style="display:flex;"><span>  NTSTATUS result <span style="color:#f92672">=</span> <span style="color:#a6e22e">RhCreateAndInject</span>(appPath, <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;&#34;</span>, CREATE_SUSPENDED,
</span></span><span style="display:flex;"><span>    EASYHOOK_INJECT_DEFAULT,
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(_M_IX86)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    dllPath, NULL,
</span></span><span style="display:flex;"><span><span style="color:#75715e">#elif defined(_M_X64)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    NULL, dllPath,
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#error &#34;Platform not supported&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    NULL, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>pid);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">FAILED</span>(result)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Message</span>(<span style="color:#e6db74">&#34;RhCreateAndInject failed: %S</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">RtlGetLastErrorString</span>());
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Message</span>(<span style="color:#e6db74">&#34;Successfully injected %S into %S (PID=0x%x)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, fullDllPath,
</span></span><span style="display:flex;"><span>    fullAppPath, pid);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  DWORD exitCode <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Get a handle to the newly-created process and wait for it to terminate.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Once the process has terminated, get its return code and return that as
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// our return code
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  HANDLE hProcess <span style="color:#f92672">=</span> <span style="color:#a6e22e">OpenProcess</span>(SYNCHRONIZE <span style="color:#f92672">|</span> PROCESS_QUERY_INFORMATION,
</span></span><span style="display:flex;"><span>    FALSE, pid);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (hProcess) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">WaitForSingleObject</span>(hProcess, timeout);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">GetExitCodeProcess</span>(hProcess, <span style="color:#f92672">&amp;</span>exitCode);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">CloseHandle</span>(hProcess);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Message</span>(<span style="color:#e6db74">&#34;Unable to open process 0x%x: 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pid, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> exitCode;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Of course, it is entirely possible that the malware will be watching for API
hooks (we are dealing with malicious software after all!). Whilst an important
issue, we won&rsquo;t deal with it in this post.</p>
<p>Now that we&rsquo;ve written the tool to run our malware with an injected DLL, let&rsquo;s
turn our attention to what this DLL actually does.</p>
<h2 id="malware-hook"><code>malware-hook</code></h2>
<p>Likewise, we&rsquo;ll base <code>malware-hook</code> on EasyHook&rsquo;s example
<a href="https://easyhook.github.io/tutorials/nativeremotehook.html">BeepHook</a> DLL.
Here is the skeleton of our hook DLL, which we&rsquo;ll put in <code>malware-hook.cpp</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;strsafe.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;easyhook.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define USER_APP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/s2e.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define S2E_MSG_LEN 512
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> INT s2eVersion <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Message</span>(LPCSTR fmt, ...) {
</span></span><span style="display:flex;"><span>  CHAR message[S2E_MSG_LEN];
</span></span><span style="display:flex;"><span>  va_list args;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  va_start(args, fmt);
</span></span><span style="display:flex;"><span>  vsnprintf(message, S2E_MSG_LEN, fmt, args);
</span></span><span style="display:flex;"><span>  va_end(args);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (s2eVersion) {
</span></span><span style="display:flex;"><span>    S2EMessageFmt(<span style="color:#e6db74">&#34;[0x%x|malware-hook] %s&#34;</span>, GetCurrentProcessId(), message);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;[0x%x|malware-hook] %s&#34;</span>, GetCurrentProcessId(), message);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// EasyHook will be looking for this export to support DLL injection. If not
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// found then DLL injection will fail
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__declspec</span>(dllexport) <span style="color:#66d9ef">__stdcall</span> NativeInjectionEntryPoint(REMOTE_ENTRY_INFO <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__stdcall</span> <span style="color:#a6e22e">NativeInjectionEntryPoint</span>(REMOTE_ENTRY_INFO <span style="color:#f92672">*</span>inRemoteInfo) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Unused
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>) inRemoteInfo;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Used by the Message function to decide where to write output to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  s2eVersion <span style="color:#f92672">=</span> S2EGetVersion();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// TODO initialize hooks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The process was started in a suspended state. Wake it up...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  RhWakeUpProcess();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So, what are we going to hook? Let&rsquo;s take some inspiration from two great
papers on this topic: David Brumley&rsquo;s &ldquo;<a href="http://www.keylogger.org/articles/botnet_book-2007.pdf">Automatically Identifying Trigger-based
Behaviour in Malware</a>&rdquo;
and Andreas Moser&rsquo;s &ldquo;<a href="http://analysis.seclab.tuwien.ac.at/papers/explore.pdf">Exploring Multiple Execution Paths for Malware
Analysis</a>&rdquo;. Both of
these papers look at &ldquo;trigger-based malware&rdquo;, which is malware whose malicious
actions only occur under specific circumstances; i.e. when certain <em>trigger
conditions</em> are met. For example, malware may only launch its payload on a
specific date (as the <a href="https://en.wikipedia.org/wiki/Mydoom">MyDoom</a> worm did),
or upon receiving specific data from a command &amp; control server. In these two
examples, the <em>trigger sources</em> are the current date/time and data read from a
network. Other trigger sources include (as listed in Moser&rsquo;s paper):</p>
<ul>
<li>Internet connectivity;</li>
<li>Mutex objects;</li>
<li>Existence of files;</li>
<li>Existence of Registry entries; and</li>
<li>Data read from a file.</li>
</ul>
<p>How can we analyse trigger-based malware? Brumley&rsquo;s paper proposed Minesweeper,
a tool designed to detect the existence of trigger-based behaviours and to find
inputs that exercise these behaviours. As far as I can tell, Minesweeper was
never publicly released. However, we can build a very similar system in S2E
using our <code>malware-hook</code> DLL! So let&rsquo;s go ahead and create hooks for some of
the trigger sources discussed in these two papers.</p>
<h2 id="case-study-1-getlocaltime-test">Case study 1: <code>GetLocalTime-test</code></h2>
<p>The first trigger source that Brumley&rsquo;s paper explores is
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724338">GetLocalTime</a>.
<code>GetLocalTime</code> has the following prototype:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> WINAPI <span style="color:#a6e22e">GetLocalTime</span>(
</span></span><span style="display:flex;"><span>  _Out_ LPSYSTEMTIME lpSystemTime
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>In Minesweeper, the user was required to specify where in memory the trigger
inputs will be stored. This was so the symbolic execution engine could properly
assign symbolic variables during execution. In the case of <code>GetLocalTime</code>, this
would require specifying that <code>GetLocalTime</code> stores its result in a 16-byte
structure pointed to by a stack value when <code>GetLocalTime</code> is called.
Fortunately, we don&rsquo;t have to worry about these low-level details. Instead, we
can just call <code>S2EMakeSymbolic</code> on the variable we pass to <code>GetLocalTime</code>.
Here&rsquo;s how we do this in <code>malware-hook</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Function hooks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> WINAPI <span style="color:#a6e22e">GetLocalTimeHook</span>(LPSYSTEMTIME lpSystemTime) {
</span></span><span style="display:flex;"><span>  Message(<span style="color:#e6db74">&#34;Intercepted GetLocalTime</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Call the original GetLocalTime to get a concrete value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  GetLocalTime(lpSystemTime);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Make the value concolic
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  S2EMakeSymbolic(lpSystemTime, <span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>lpSystemTime), <span style="color:#e6db74">&#34;SystemTime&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The names of the functions to hook (and the library they belong to)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> LPCSTR functionsToHook[][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  { <span style="color:#e6db74">&#34;kernel32&#34;</span>, <span style="color:#e6db74">&#34;GetLocalTime&#34;</span>} ,
</span></span><span style="display:flex;"><span>  { NULL, NULL },
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The function hooks that we will install
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> PVOID hookFunctions[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  GetLocalTimeHook,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The actual hooks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> HOOK_TRACE_INFO hooks[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  { NULL },
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// This function was defined previously
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__stdcall</span> <span style="color:#a6e22e">NativeInjectionEntryPoint</span>(REMOTE_ENTRY_INFO <span style="color:#f92672">*</span>inRemoteInfo) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Replace the previous TODO with the following code to install the GetLocalTime hook
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; functionsToHook[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> NULL; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    LPCSTR moduleName <span style="color:#f92672">=</span> functionsToHook[i][<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    LPCSTR functionName <span style="color:#f92672">=</span> functionsToHook[i][<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Install the hook
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    NTSTATUS result <span style="color:#f92672">=</span> LhInstallHook(
</span></span><span style="display:flex;"><span>      GetProcAddress(GetModuleHandleA(moduleName), functionName),
</span></span><span style="display:flex;"><span>      hookFunctions[i],
</span></span><span style="display:flex;"><span>      NULL,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&amp;</span>hooks[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (FAILED(result)) {
</span></span><span style="display:flex;"><span>      Message(<span style="color:#e6db74">&#34;Failed to hook %s.%s: %S</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, moduleName, functionName,
</span></span><span style="display:flex;"><span>              RtlGetLastErrorString());
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      Message(<span style="color:#e6db74">&#34;Successfully hooked %s.%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, moduleName, functionName);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Ensure that all threads _except_ the injector thread will be hooked
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ULONG ACLEntries[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>    LhSetExclusiveACL(ACLEntries, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>hooks[i]);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Let&rsquo;s implement the running example that Brumley et al. used in their paper
(Fig. 1.1) to test that everything works as expected.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ddos</span> (LPCSTR target) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// DDOS code goes here :)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  SYSTEMTIME systime;
</span></span><span style="display:flex;"><span>  LPCSTR site <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;www.usenix.org&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">GetLocalTime</span>(<span style="color:#f92672">&amp;</span>systime);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">9</span> <span style="color:#f92672">==</span> systime.wDay) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">10</span> <span style="color:#f92672">==</span> systime.wHour) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">11</span> <span style="color:#f92672">==</span> systime.wMonth) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">6</span> <span style="color:#f92672">==</span> systime.wMinute) {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">ddos</span>(site);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Ensure that you compile everything for the x86 platform (since we&rsquo;ll be using
a 32-bit Windows 7 VM). Once everything is built (including the VM!), we can
create a new project:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>s2e new_project -i windows-7sp1pro-i386 /path/to/malware-s2e/GetLocalTime-test/Debug/GetLocalTime-test.exe
</span></span></code></pre></div><p>Note that this will create a <code>bootstrap.sh</code> that executes
<code>GetLocalTime-test.exe</code> directly. We must modify <code>bootstrap.sh</code> to have
<code>malware-inject.exe</code> execute <code>GetLocalTime-test.exe</code> instead. To do this we&rsquo;ll
need access to our hooking tools from within the VM. We can do this by
executing the following command in our S2E environment to create the necessary
symbolic links in our project directory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cd $S2EDIR/projects/GetLocalTime-test
</span></span><span style="display:flex;"><span>HOOK_FILES<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;EasyHook32.dll malware-hook.dll malware-inject.exe&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> FILE in $HOOK_FILES; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  ln -s $S2EDIR/source/s2e/guest/windows/Debug/$FILE $FILE
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span></code></pre></div><p>And then edit <code>bootstrap.sh</code> as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># ...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># The target does not get executed directly - we execute it via malware-inject</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> execute_target <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  local TARGET
</span></span><span style="display:flex;"><span>  TARGET<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  ./malware-inject.exe --dll <span style="color:#e6db74">&#34;./malware-hook.dll&#34;</span> --app <span style="color:#e6db74">${</span>TARGET<span style="color:#e6db74">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># We also need to download the files required for hooking</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Download the target file to analyze</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">${</span>S2EGET<span style="color:#e6db74">}</span> <span style="color:#e6db74">&#34;GetLocalTime-test.exe&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">${</span>S2EGET<span style="color:#e6db74">}</span> <span style="color:#e6db74">&#34;EasyHook32.dll&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">${</span>S2EGET<span style="color:#e6db74">}</span> <span style="color:#e6db74">&#34;malware-hook.dll&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">${</span>S2EGET<span style="color:#e6db74">}</span> <span style="color:#e6db74">&#34;malware-inject.exe&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ...</span>
</span></span></code></pre></div><p>Finally, we can disable the following plugins in <code>s2e-config.lua</code> (they are not
required):</p>
<ul>
<li><code>WebServiceInterface</code></li>
<li><code>KeyValueStore</code></li>
<li><code>MultiSearcher</code></li>
<li><code>CUPASearcher</code></li>
<li><code>StaticFunctionModels</code></li>
</ul>
<p>We are now ready to run our analysis!</p>
<h3 id="results">Results</h3>
<p>We should see S2E fork four times during our analysis. If we enable the
<code>--verbose-fork-info</code> KLEE argument (in <code>s2e-config.lua</code>) we can see the
constraints generated at each of these four fork points. The following image
shows a disassembly with these points highlighted.</p>
<figure><a href="/img/getlocaltime_test-binja.png"><img src="/img/getlocaltime_test-binja.png"
    alt="GetLocalTime-test fork points"></a>
</figure>

<p><code>ReadLSB w16 X SystemTime</code> can be understood as &ldquo;read 16 bits (i.e. one <code>WORD</code>)
at offset <code>X</code> in the symbolic <code>SystemTime</code> variable. If we look up the
<code>SYSTEMTIME</code> struct on
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724950">MSDN</a> we
will see that each <code>WORD</code> at these offsets (<code>0x6</code>, <code>0x8</code>, <code>0x2</code>, <code>0xA</code>)
corresponds with the <code>wDay</code>, <code>wHour</code>, <code>wMonth</code> and <code>wMinute</code> fields
respectively - just as expected. Finally, we should find a line in <code>debug.txt</code>
containing the following test case (I&rsquo;ve reformatted the line and added the
field names to make it easier to read):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>TestCaseGenerator:  v0_SystemTime_0 <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wYear */</span>
</span></span><span style="display:flex;"><span>                                       <span style="color:#ae81ff">0xb</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wMonth */</span>
</span></span><span style="display:flex;"><span>                                       <span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wDayOfWeek */</span>
</span></span><span style="display:flex;"><span>                                       <span style="color:#ae81ff">0x9</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wDay */</span>
</span></span><span style="display:flex;"><span>                                       <span style="color:#ae81ff">0xa</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wHour */</span>
</span></span><span style="display:flex;"><span>                                       <span style="color:#ae81ff">0x6</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wMinute */</span>
</span></span><span style="display:flex;"><span>                                       <span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">0x0</span>, <span style="color:#75715e">/* wSecond */</span>
</span></span><span style="display:flex;"><span>                                       <span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">0x0</span>} <span style="color:#75715e">/* wMilliseconds */</span>
</span></span></code></pre></div><p>If we cross-reference this against <code>GetLocalTime-test/test.c</code> we can see that
this is the time to launch the DDOS. Success!</p>
<h2 id="case-study-2-wannacry">Case study 2: WannaCry</h2>
<p>That was nice, but malware has moved on since the Minesweeper paper was written
in 2007. Let&rsquo;s look at something a bit more recent - the
<a href="https://en.wikipedia.org/wiki/WannaCry_ransomware_attack">WannaCry</a>
ransomware. WannaCry famously contained a &ldquo;killswitch&rdquo; that stopped the
ransomware from encrypting the target&rsquo;s data. This killswitch was a check for
whether a gibberish URL led to a live webpage. WannaCry would shut down if this
URL could be reached (this check was probably done to fool dynamic analysis
tools, which are typically configured to return valid, dummy responses to all
network queries). With this in mind, let&rsquo;s use S2E to explore WannaCry&rsquo;s
behaviour when this trigger condition is <strong>and</strong> isn&rsquo;t satisfied. We&rsquo;ll focus
on the sample discussed in Amanda Rousseau&rsquo;s excellent
<a href="https://www.endgame.com/blog/technical-blog/wcrywanacry-ransomware-technical-analysis">writeup</a>
(MD5 hash db349b97c37d22f5ea1d1841e3c89eb4).</p>
<h3 id="disassembly">Disassembly</h3>
<p>Let&rsquo;s take a quick look at the WannaCry killswitch in a disassembler.</p>
<figure><a href="/img/wannacry-killswitch.png"><img src="/img/wannacry-killswitch.png"
    alt="WannaCry killswitch"></a>
</figure>

<p>We can see that the
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa385331">WinINet</a>
API is used to open a connection to the killswitch URL
(hxxp://www[.]iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea[.]com). The following
functions are called to do this:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/windows/desktop/api/wininet/nf-wininet-internetopena">InternetOpenA</a>:
Initializes the WinINet system. Returns an <code>HINTERNET</code> handle on success, or
<code>NULL</code> on failure.</li>
<li><a href="https://docs.microsoft.com/en-us/windows/desktop/api/wininet/nf-wininet-internetopenurla">InternetOpenUrlA</a>:
Using the handle returned by <code>InternetOpenA</code>, open a resource specified by the
given URL. Returns an <code>HINTERNET</code> handle on success, or <code>NULL</code> on failure.</li>
<li><a href="https://docs.microsoft.com/en-us/windows/desktop/api/wininet/nf-wininet-internetclosehandle">InternetCloseHandle</a>:
Close the handles opened by <code>InternetOpenA</code> and <code>InternetOpenUrlA</code>.</li>
</ul>
<p>At a minimum we must hook <code>InternetOpenUrlA</code> and force a fork to explore both
paths at <code>0x4081a5</code>. What about <code>InternetOpenA</code>? We can see in the WannaCry
code that the <code>HINTERNET</code> handle returned by <code>InternetOpenA</code> is never checked,
so we don&rsquo;t have to worry about this function. If the returned handle was
(properly) checked, we may have needed to hook <code>InternetOpenA</code> and force it to
return some dummy, non-<code>NULL</code> value. Similarly, if we were interested in the
code executed when <code>InternetOpenA</code> fails, we could also force a fork on some
symbolic value. However, for simplicity we&rsquo;ll just focus on <code>InternetOpenUrlA</code>.
Let&rsquo;s write some more code!</p>
<h3 id="wininet-hooks">WinINet hooks</h3>
<p>First, replace the hooked functions in <code>malware-hook.cpp</code> with the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> LPCSTR functionsToHook[][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  { <span style="color:#e6db74">&#34;wininet&#34;</span>, <span style="color:#e6db74">&#34;InternetOpenUrlA&#34;</span> },
</span></span><span style="display:flex;"><span>  { <span style="color:#e6db74">&#34;wininet&#34;</span>, <span style="color:#e6db74">&#34;InternetCloseHandle&#34;</span> },
</span></span><span style="display:flex;"><span>  { NULL, NULL },
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> PVOID hookFunctions[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  InternetOpenUrlAHook,
</span></span><span style="display:flex;"><span>  InternetCloseHandleHook,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> HOOK_TRACE_INFO hooks[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  { NULL },
</span></span><span style="display:flex;"><span>  { NULL },
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Then write the actual hook functions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/// Keep track of dummy Internet handles that we&#39;ve created
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>HINTERNET<span style="color:#f92672">&gt;</span> dummyHandles;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> HINTERNET WINAPI <span style="color:#a6e22e">InternetOpenUrlAHook</span>(
</span></span><span style="display:flex;"><span>  HINTERNET hInternet,
</span></span><span style="display:flex;"><span>  LPCSTR lpszUrl,
</span></span><span style="display:flex;"><span>  LPCSTR lpszHeaders,
</span></span><span style="display:flex;"><span>  DWORD dwHeadersLength,
</span></span><span style="display:flex;"><span>  DWORD dwFlags,
</span></span><span style="display:flex;"><span>  DWORD_PTR dwContext
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Message</span>(<span style="color:#e6db74">&#34;Intercepted InternetOpenUrlA(%p, %s, %s, 0x%x, 0x%x, %p)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>    hInternet, lpszUrl, lpszHeaders, dwHeadersLength, dwFlags, dwContext);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Force a fork via a symbolic variable. Since both branches are feasible,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// both paths are taken
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UINT8 returnResource <span style="color:#f92672">=</span> <span style="color:#a6e22e">S2ESymbolicChar</span>(<span style="color:#e6db74">&#34;hInternet&#34;</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (returnResource) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Explore the program when InternetOpenUrlA &#34;succeeds&#34; by returning a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// dummy resource handle. Because we know that the resource handle is never
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// used, we don&#39;t have to do anything fancy to create it.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// However, we will need to keep track of it so we can free it when the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// handle is closed.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    HINTERNET resourceHandle <span style="color:#f92672">=</span> (HINTERNET) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(HINTERNET));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Record the dummy handle so we can clean up afterwards
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    dummyHandles.<span style="color:#a6e22e">insert</span>(resourceHandle);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> resourceHandle;
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Explore the program when InternetOpenUrlA &#34;fails&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> BOOL WINAPI <span style="color:#a6e22e">InternetCloseHandleHook</span>(HINTERNET hInternet) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Message</span>(<span style="color:#e6db74">&#34;Intercepted InternetCloseHandle(%p)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, hInternet);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>HINTERNET<span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> dummyHandles.<span style="color:#a6e22e">find</span>(hInternet);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">==</span> dummyHandles.<span style="color:#a6e22e">end</span>()) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The handle is not one of our dummy handles, so call the original
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// InternetCloseHandle function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">InternetCloseHandle</span>(hInternet);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The handle is a dummy handle. Free it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">free</span>(<span style="color:#f92672">*</span>it);
</span></span><span style="display:flex;"><span>    dummyHandles.<span style="color:#a6e22e">erase</span>(it);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here we follow the approach taken in S2E&rsquo;s <a href="https://github.com/S2E/docs/blob/master/src/Tutorials/WindowsDrivers/FaultInjection.rst">multi-path fault injection
tutorial</a>.
The <code>returnResource</code> symbolic variable forces a fork, resulting in one state
where <code>InternetOpenUrlA</code> succeeds (by returning a dummy resource) and another
state where <code>InternetOpenUrlA</code> fails (by returning <code>NULL</code>). We can return a
dummy resource handle because the <code>InternetOpenUrlA</code> handle is never actually
used: remember, WannCry only checks if it is <code>NULL</code>. The <code>InternetCloseHandle</code>
hook then cleans up the allocated memory. Now let&rsquo;s hook and run WannaCry in
S2E.</p>
<h3 id="initial-results">Initial results</h3>
<p>We can follow the same procedure that we used for <code>GetLocalTime-test</code> to set up
an S2E project for WannaCry. Remember to make symbolic links to EasyHook32.dll,
malware-hook.dll and malware-inject.exe and <code>s2eget</code> them in the bootstrap
script.</p>
<p>Before running S2E, enable the <code>LibraryCallMonitor</code> plugin in <code>s2e-config.lua</code>.
This plugin monitors and logs external library function calls, which gives us a
better picture of what WannaCry is doing. When you run S2E, you should see a
fork in <code>malware-hook</code>&rsquo;s address space (likely hidden amongst <strong>a lot</strong> of
debug output produced by <code>LibraryCallMonitor</code>). If you follow the library calls
made by the WannaCry executable (instead of all the other DLLs loaded in its
address space), you should see the following library calls in state 0:</p>
<table>
<thead>
<tr>
<th>Address</th>
<th>DLL</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x4081bc</td>
<td>wininet</td>
<td>InternetCloseHandle</td>
</tr>
<tr>
<td>0x4081bf</td>
<td>wininet</td>
<td>InternetCloseHandle</td>
</tr>
<tr>
<td>0x409b4e</td>
<td>msvcrt</td>
<td>exit</td>
</tr>
</tbody>
</table>
<p>While in state 1 you should see:</p>
<table>
<thead>
<tr>
<th>Address</th>
<th>DLL</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x4081a7</td>
<td>wininet</td>
<td>InternetCloseHandle</td>
</tr>
<tr>
<td>0x4081ab</td>
<td>wininet</td>
<td>InternetCloseHandle</td>
</tr>
<tr>
<td>0x40809f</td>
<td>kernel32</td>
<td>GetModuleFileNameA</td>
</tr>
<tr>
<td>0x4080a5</td>
<td>msvcrt</td>
<td>__p___argc</td>
</tr>
<tr>
<td>0x407c56</td>
<td>msvcrt</td>
<td>sprintf</td>
</tr>
<tr>
<td>0x407c68</td>
<td>advapi32</td>
<td>OpenSCManagerA</td>
</tr>
<tr>
<td>0x407c9b</td>
<td>advapi32</td>
<td>CreateServiceA</td>
</tr>
<tr>
<td>0x407cb2</td>
<td>advapi32</td>
<td>StartServiceA</td>
</tr>
<tr>
<td>&hellip;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>0x407d74</td>
<td>kernel32</td>
<td>FindResourceA</td>
</tr>
<tr>
<td>0x407d86</td>
<td>kernel32</td>
<td>LoadResource</td>
</tr>
<tr>
<td>0x407d95</td>
<td>kernel32</td>
<td>LockResource</td>
</tr>
<tr>
<td>0x407da9</td>
<td>kernel32</td>
<td>SizeofResource</td>
</tr>
<tr>
<td>&hellip;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>0x407ee8</td>
<td>kernel32</td>
<td>CreateProcessA</td>
</tr>
<tr>
<td>&hellip;</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>This looks good: we have successfully explored WannaCry&rsquo;s behaviour when the
killswitch was <strong>and</strong> wasn&rsquo;t triggered. Rousseau&rsquo;s writeup outlines WannaCry&rsquo;s
execution flow, and if we follow state 1&rsquo;s library calls we should see that the
execution flows match.</p>
<h3 id="hooking-process-creation">Hooking process creation</h3>
<p>Let&rsquo;s write one last hook. What happens if our hooked process spawns a new
process? This is pretty common for  &ldquo;dropper&rdquo; malware, and indeed WannaCry does
this by loading an executable (<code>tasksche.exe</code>) from a resource, writing it to
disk and then running it (via <code>CreateProcessA</code>). When this happens, we are
totally blind to what this new process is doing: both in terms of injecting
symbolic data via our hooks and tracking its behaviour with S2E (e.g. via the
<code>LibraryCallMonitor</code> plugin).</p>
<p>We can solve the former (losing our ability to inject symbolic data into the
new process) by hooking <code>CreateProcessA</code> and using the EasyHook API to inject
<code>malware-hook</code> into this new process. The following code achieves this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Don&#39;t forget to add CreateProcessA to the functionsToHook, hookFunctions and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// hooks arrays
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>BOOL WINAPI <span style="color:#a6e22e">CreateProcessAHook</span>(
</span></span><span style="display:flex;"><span>  LPCSTR                lpApplicationName,
</span></span><span style="display:flex;"><span>  LPSTR                 lpCommandLine,
</span></span><span style="display:flex;"><span>  LPSECURITY_ATTRIBUTES lpProcessAttributes,
</span></span><span style="display:flex;"><span>  LPSECURITY_ATTRIBUTES lpThreadAttributes,
</span></span><span style="display:flex;"><span>  BOOL                  bInheritHandles,
</span></span><span style="display:flex;"><span>  DWORD                 dwCreationFlags,
</span></span><span style="display:flex;"><span>  LPVOID                lpEnvironment,
</span></span><span style="display:flex;"><span>  LPCSTR                lpCurrentDirectory,
</span></span><span style="display:flex;"><span>  LPSTARTUPINFOA        lpStartupInfo,
</span></span><span style="display:flex;"><span>  LPPROCESS_INFORMATION lpProcessInformation
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>  Message(<span style="color:#e6db74">&#34;Intercepted CreateProcessA(%s, %s, %p, %p, %d, %d, %p, %s, %p, %p)&#34;</span>,
</span></span><span style="display:flex;"><span>    lpApplicationName, lpCommandLine, lpProcessAttributes,
</span></span><span style="display:flex;"><span>    lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment,
</span></span><span style="display:flex;"><span>    lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Get this DLL&#39;s path
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  HMODULE hDll <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  DWORD hModFlags <span style="color:#f92672">=</span> GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>    GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>GetModuleHandleEx(hModFlags, (LPCTSTR)<span style="color:#f92672">&amp;</span>Message, <span style="color:#f92672">&amp;</span>hDll)) {
</span></span><span style="display:flex;"><span>    Message(<span style="color:#e6db74">&#34;Failed to retrive DLL handle: 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLastError());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> default_create_process;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  WCHAR dllPath[MAX_PATH_LEN];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>GetModuleFileNameW(hDll, dllPath, MAX_PATH_LEN)) {
</span></span><span style="display:flex;"><span>    Message(<span style="color:#e6db74">&#34;Failed to retrive DLL path: 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLastError());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> default_create_process;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Create the new process, but force it to be created in a suspended state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>CreateProcessA(lpApplicationName, lpCommandLine, lpProcessAttributes,
</span></span><span style="display:flex;"><span>      lpThreadAttributes, bInheritHandles, dwCreationFlags <span style="color:#f92672">|</span> CREATE_SUSPENDED,
</span></span><span style="display:flex;"><span>      lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation)) {
</span></span><span style="display:flex;"><span>    Message(<span style="color:#e6db74">&#34;Failed to create suspended process: 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLastError());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> default_create_process;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Inject ourselves into the new, suspended process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// NativeInjectionEntryPoint will call RhWakeupProcess, which will kick
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// ourselves out of the suspended state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  NTSTATUS result <span style="color:#f92672">=</span> RhInjectLibrary(lpProcessInformation<span style="color:#f92672">-&gt;</span>dwProcessId,
</span></span><span style="display:flex;"><span>    lpProcessInformation<span style="color:#f92672">-&gt;</span>dwThreadId, EASYHOOK_INJECT_DEFAULT,
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(_M_IX86)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    dllPath, NULL,
</span></span><span style="display:flex;"><span><span style="color:#75715e">#elif defined(_M_X64)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    NULL, dllPath,
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#error &#34;Platform not supported&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    NULL, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (FAILED(result)) {
</span></span><span style="display:flex;"><span>    Message(<span style="color:#e6db74">&#34;RhInjectLibrary failed: %S</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, RtlGetLastErrorString());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> default_create_process;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Message(<span style="color:#e6db74">&#34;Successfully injected %S into %s %s (PID=0x%x)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dllPath,
</span></span><span style="display:flex;"><span>    lpApplicationName, lpCommandLine, lpProcessInformation<span style="color:#f92672">-&gt;</span>dwProcessId);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>default_create_process:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> CreateProcessA(lpApplicationName, lpCommandLine, lpProcessAttributes,
</span></span><span style="display:flex;"><span>    lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment,
</span></span><span style="display:flex;"><span>    lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This hook will start the new process in a suspended state and inject itself
into the new process. <code>malware-hook</code>&rsquo;s <code>NativeInjectionEntryPoint</code> function
is then responsible for waking the process up.</p>
<p>This solves the problem of injecting symbolic data into a new process started
by WannaCry. What about tracking this new process&rsquo; behaviour in S2E?
Unfortunately, this requires a bit more work. One approach could be to write an
S2E plugin that listened for <a href="https://github.com/S2E/libs2eplugins/blob/master/src/s2e/Plugins/OSMonitors/OSMonitor.h">OSMonitor</a>&rsquo;s
<code>onProcessLoad</code> signal. If a new process was found to originate from the
WannaCry process, we could add the new child process to
<a href="https://github.com/S2E/libs2eplugins/blob/master/src/s2e/Plugins/OSMonitors/Support/ProcessExecutionDetector.h">ProcessExecutionDetector</a>&rsquo;s
tracked modules. <code>LibraryCallMonitor</code> would then start emitting <code>onLibraryCall</code>
events for this new process, allowing us to track its behaviour too. Because I
wanted to avoid writing S2E plugins in this post, I&rsquo;ll leave this &ldquo;as an
exercise for the reader&rdquo;.</p>
<p>One last problem exists: The original WannaCry process terminates after it
starts <code>tasksche.exe</code>. This causes <code>malware-inject</code> to also terminate (remember
it calls <code>WaitForSingleObject</code>), leading to <code>bootstrap.sh</code> killing the current
(and only active) state. Unfortunately, this means that S2E will terminate
before we get to see WannaCry do something interesting (like encrypt our data).
The hacky way to fix this: add a <code>sleep</code> command after the call to <code>execute</code> in
<code>bootstrap.sh</code> (don&rsquo;t forget to set an appropriate amount of time to sleep
for). This is hacky because it means that we&rsquo;ll waste time sleeping in state 0
after WannaCry exits (and does nothing interesting). A better approach is to
wait for <code>tasksche.exe</code> (and any other child processes) to terminate. Let&rsquo;s add
a function to do this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Set a sensible timeout value (in milliseconds). Can also be INFINITE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define CHILD_PROCESS_TIMEOUT 10 * 1000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Keep track of child proceses (such as tasksche.exe)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>DWORD<span style="color:#f92672">&gt;</span> childPids;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> BOOL <span style="color:#a6e22e">WaitForChildProcesses</span>(DWORD timeout) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> retCode <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (childPids.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Convert the set of PIDS to a list of handles with the appropriate permissions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>HANDLE<span style="color:#f92672">&gt;</span> childHandles;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (DWORD pid : childPids) {
</span></span><span style="display:flex;"><span>      Message(<span style="color:#e6db74">&#34;Getting handle to process 0x%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pid);
</span></span><span style="display:flex;"><span>      HANDLE childHandle <span style="color:#f92672">=</span> OpenProcess(SYNCHRONIZE <span style="color:#f92672">|</span> PROCESS_QUERY_INFORMATION,
</span></span><span style="display:flex;"><span>        FALSE, pid);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (childHandle) {
</span></span><span style="display:flex;"><span>        childHandles.push_back(childHandle);
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        Message(<span style="color:#e6db74">&#34;Unable to open child process 0x%x: 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pid, GetLastError());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Wait for the processes to terminate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Message(<span style="color:#e6db74">&#34;Waiting %d ms for %d children processes to terminate...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>      timeout, childHandles.size());
</span></span><span style="display:flex;"><span>    DWORD waitRes <span style="color:#f92672">=</span> WaitForMultipleObjects(childHandles.size(),
</span></span><span style="display:flex;"><span>      childHandles.data(), TRUE, timeout);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (waitRes) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">case</span> WAIT_FAILED:
</span></span><span style="display:flex;"><span>        Message(<span style="color:#e6db74">&#34;Failed to wait for child processes: 0x%X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLastError());
</span></span><span style="display:flex;"><span>        retCode <span style="color:#f92672">=</span> FALSE;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">case</span> WAIT_TIMEOUT:
</span></span><span style="display:flex;"><span>        Message(<span style="color:#e6db74">&#34;Timeout - not all child processes may have terminated</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Close all handles
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (HANDLE handle : childHandles) {
</span></span><span style="display:flex;"><span>      CloseHandle(handle);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> retCode;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>WaitForChildProcesses</code> should be called when the hooked WannaCry process
exits. We can do this by adding <code>DLLMain</code> and checking for reason code
<code>DLL_PROCESS_DETACH</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>BOOL WINAPI <span style="color:#a6e22e">DllMain</span>(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> (fdwReason) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Don&#39;t exit until all child processes have terminated (or a timeout is reached)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">case</span> DLL_PROCESS_DETACH:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> WaitForChildProcesses(CHILD_PROCESS_TIMEOUT);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Finally, don&rsquo;t forget to add the following code to <code>CreateProcessAHook</code> to
track child processes. The child process should only be saved if it is
successfully hooked (i.e. before returning <code>TRUE</code>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// This function was defined previously
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> BOOL WINAPI <span style="color:#a6e22e">CreateProcessAHook</span>(
</span></span><span style="display:flex;"><span>  LPCSTR                lpApplicationName,
</span></span><span style="display:flex;"><span>  LPSTR                 lpCommandLine,
</span></span><span style="display:flex;"><span>  LPSECURITY_ATTRIBUTES lpProcessAttributes,
</span></span><span style="display:flex;"><span>  LPSECURITY_ATTRIBUTES lpThreadAttributes,
</span></span><span style="display:flex;"><span>  BOOL                  bInheritHandles,
</span></span><span style="display:flex;"><span>  DWORD                 dwCreationFlags,
</span></span><span style="display:flex;"><span>  LPVOID                lpEnvironment,
</span></span><span style="display:flex;"><span>  LPCSTR                lpCurrentDirectory,
</span></span><span style="display:flex;"><span>  LPSTARTUPINFOA        lpStartupInfo,
</span></span><span style="display:flex;"><span>  LPPROCESS_INFORMATION lpProcessInformation
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Save the newly-created process&#39; PID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  childPids.insert(lpProcessInformation<span style="color:#f92672">-&gt;</span>dwProcessId);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>If you comment out <code>GRAPHICS=-nographic</code> in <code>launch-s2e.sh</code> (to enable the QEMU
GUI), you&rsquo;ll eventually be rewarded with the following (depending on the value
chosen for <code>CHILD_PROCESS_TIMEOUT</code>):</p>
<figure><a href="/img/wannacry-s2e.png"><img src="/img/wannacry-s2e.png"
    alt="WannaCry infection"></a>
</figure>

<h2 id="conclusion-and-next-steps">Conclusion and next steps</h2>
<p>In this post we&rsquo;ve looked at analysing Windows malware with S2E, essentially
recreating David Brumley&rsquo;s Minesweeper tool in S2E. Unlike programs we&rsquo;ve
looked at in previous posts, we had to come up with some new techniques to
inject symbolic data into our Windows programs. We used EasyHook to hook
&ldquo;trigger&rdquo; functions that are commonly used by malware to hide their behaviour.
While this approach worked well for our two case studies (which were admittedly
highly contrived), there are many avenues for improvement. These avenues
include:</p>
<ul>
<li>Hooking more of the Windows API. Brumley and Moser describe a number of
different trigger sources (e.g. network data, registry keys, etc.) that aren&rsquo;t
covered in this post.</li>
<li>Building more complex hooks. For example, our <code>InternetOpenUrlA</code> hook was
overly simplistic - it just returned a dummy handle allocated on the heap. If
this handle was later passed to a function like <code>InternetReadFile</code>, we&rsquo;d have
to hook this function as well. This is essentially the &ldquo;environment modelling&rdquo;
problem inherit in most symbolic execution engines.</li>
<li>Hiding our hooks from the malware being analysed. Some ideas including
porting Cuckoo Monitor to S2E or doing everything in an S2E plugin.</li>
<li>A broader study on real malware. Is this type of symbolic execution even
helpful for malware analysis? How common is trigger-based malware - can we get
away with just doing a dynamic analysis in Cuckoo Sandbox? Are the
obfuscation techniques discussed in Banescu&rsquo;s work on <a href="https://mediatum.ub.tum.de/doc/1343173/1343173.pdf">Code Obfuscation
Against Symbolic Execution Attacks</a>
used by malware authors, and if so how do they affect our analysis?</li>
</ul>
<p>Hopefully this post gives you the necessary background and tools to go and
look at some of these improvements. Maybe one day I&rsquo;ll even find the time to
look at some of them myself!</p>
<h2 id="edit">Edit</h2>
<p><strong>21/10/2018</strong>: I&rsquo;ve updated this post with a less-hacky way of waiting for
WannaCry&rsquo;s <code>tasksche.exe</code> to start encrypting data.</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>&#34;Targeting&#34; File Parsers with S2E and Kaitai Struct</title>
      <link>https://adrianherrera.github.io/posts/kaitai-s2e/</link>
      <pubDate>Mon, 23 Oct 2017 21:35:48 +1100</pubDate>
      
      <guid>https://adrianherrera.github.io/posts/kaitai-s2e/</guid>
      <description><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Recently I&rsquo;ve been playing around with file parsers in S2E. This typically
involves calling <code>s2ecmd symbfile</code> to make the parser&rsquo;s input symbolic and then
running S2E to explore different paths through the parser. However, this is a
relatively heavy-handed approach; it makes the entire input file one big
symbolic blob, which quickly causes
<a href="https://en.wikipedia.org/wiki/Symbolic_execution#Path_Explosion">path explosion</a>.
Additionally, we may only be interested in exploring paths that exercise
specific functionality.</p>
<p>So how can we achieve more targeted symbolic execution on file-based programs
such as parsers? One approach could be to write a custom S2E plugin that
handles the <code>onSymbolicVariableCreation</code> event and intercepts
<code>s2ecmd symbfile</code>. You could then write C++ code that iterated over the
symbolic data and adjusted what was symbolic/concrete. The downsides of this
approach should be evident: it is time consuming and error prone to write C++
code to do this; it requires knowledge of the input file format; and you would
have to repeat this process for different file formats. Can we do better?</p>
<h2 id="kaitai-struct">Kaitai Struct</h2>
<p>Let&rsquo;s briefly diverge from S2E and discuss <a href="http://kaitai.io">Kaitai Struct</a>.
Kaitai Struct is a tool for developing parsers for binary structures. It
provides a YAML-like language that allows for the concise definition of a
binary structure. The Kaitai Struct Compiler (<code>ksc</code>) then generates a parser
from this definition. This parser can be generated in a number of languages,
including C++, Python and Java.</p>
<p>Here is a partial definition of the ELF format in Kaitai Struct (taken from the
<a href="http://formats.kaitai.io/elf/index.html">format gallery</a>). It consists of a
number of &ldquo;attributes&rdquo; (e.g. <code>magic</code>, <code>abi_version</code>, etc.) which describe an
ELF file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">meta</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">id</span>: <span style="color:#ae81ff">elf</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">title</span>: <span style="color:#ae81ff">Executable and Linkable Format</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">application</span>: <span style="color:#ae81ff">SVR4 ABI and up, many *nix systems</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">license</span>: <span style="color:#ae81ff">CC0-1.0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ks-version</span>: <span style="color:#ae81ff">0.8</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">seq</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># e_ident[EI_MAG0]..e[EI_MAG3]</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">magic</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">size</span>: <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">contents</span>: [<span style="color:#ae81ff">0x7f</span>, <span style="color:#e6db74">&#34;ELF&#34;</span>]
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># e_ident[EI_CLASS]</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">bits</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">type</span>: <span style="color:#ae81ff">u1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">enum</span>: <span style="color:#ae81ff">bits</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># e_ident[EI_DATA]</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">endian</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">type</span>: <span style="color:#ae81ff">u1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">enum</span>: <span style="color:#ae81ff">endian</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># e_ident[EI_VERSION]</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">ei_version</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">type</span>: <span style="color:#ae81ff">u1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># e_ident[EI_OSABI]</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">abi</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">type</span>: <span style="color:#ae81ff">u1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">enum</span>: <span style="color:#ae81ff">os_abi</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">abi_version</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">type</span>: <span style="color:#ae81ff">u1</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">pad</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">size</span>: <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">header</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">type</span>: <span style="color:#ae81ff">endian_elf</span>
</span></span></code></pre></div><p>I strongly recommend reading the Kaitai Struct
<a href="http://doc.kaitai.io">documentation</a> to get the most out of this post, as I
will skip much of the detail here (mostly because I&rsquo;m not really an expert
myself!). Nevertheless, there is one feature that is worth singling out: the
&ldquo;<a href="http://doc.kaitai.io/ksy_reference.html#spec-process">processing spec</a>&rdquo;.</p>
<p>The processing spec allows you to apply a custom function that will &ldquo;process&rdquo;
an attribute in some way. For example, an attribute may be encrypted/encoded. A
processing spec can be applied to decrypt/decode this attribute at run time.</p>
<p>How is this relevant to symbolic execution? Suppose that we had an
<code>s2e_make_symbolic</code> processing spec, and by applying this spec to particular
attributes we would make <strong>only</strong> those parts of the input file symbolic. This
would give us more fine-grained control over S2E&rsquo;s state space and potentially
reduce the path explosion problem. All we need is a way to combine S2E and
Kaitai Struct to make this possible!</p>
<h2 id="combining-s2e-and-kaitai-struct">Combining S2E and Kaitai Struct</h2>
<p>We will use the <a href="https://www.lua.org">Lua</a> programming language to combine S2E
and Kaitai Struct. Using Lua allows us to reuse existing components — S2E
contains an embedded Lua interpreter (for parsing the S2E configuration file
and writing function/instruction
<a href="https://github.com/S2E/docs/blob/master/src/Plugins/Annotations.rst">annotations</a>),
while <code>ksc</code> is capable of generating Lua parsers. Thus, we can use <code>ksc</code> to
generate a Lua parser for our input file and embed this parser within the S2E
configuration file to make it accessible to S2E. (We could have used <code>ksc</code> to
generate a C++ parser, but this would require recompiling S2E every time we
wanted to use a different file format.) By selectively applying the
<code>s2e_make_symbolic</code> processing spec in our input definition, we can achieve
more targeted symbolic execution.</p>
<p>The remainder of this blog post will walk through how I combined S2E and Kaitai
Struct. I&rsquo;ll use the ELF definition (discussed previously) and
<a href="https://sourceware.org/binutils/docs/binutils/readelf.html">readelf</a> as a
practical example.</p>
<p>In an effort to make it easier for others to play with the code, I&rsquo;ve tried to
make it as stand-alone as possible — there are no modifications to S2E&rsquo;s core
engine or <code>ksc</code>. However, this means that the code is far from polished! The
code consists of the following components:</p>
<ul>
<li>A command-line tool (<code>s2e_kaitai_cmd</code>) that executes in the guest OS. This
tool reads the input file and invokes an S2E plugin to selectively make the
file symbolic;</li>
<li>An S2E plugin (<code>KaitaiStruct</code>) that invokes Lua code to run a parser
generated by <code>ksc</code>; and</li>
<li>A small amount of Lua glue between the S2E configuration file and the parser
generated by <code>ksc</code>.</li>
</ul>
<p>Each of these components are described below. The complete code is available
<a href="https://github.com/adrianherrera/kaitai-s2e">here</a>.</p>
<h3 id="the-s2e_kaitai_cmd-tool">The <code>s2e_kaitai_cmd</code> tool</h3>
<p>At the start of this post I mentioned that we would normally use
<code>s2ecmd symbfile</code> to make an input file symbolic. The <code>symbfile</code> command makes
an input file symbolic by:</p>
<ol>
<li>Opening the input file in read/write mode</li>
<li>Reading the input file into a buffer</li>
<li>Calling <code>s2e_make_symbolic</code> on the buffer</li>
<li>Writing the (now symbolic) buffer back to the original input file</li>
</ol>
<p>We&rsquo;ll take a similar approach, except we&rsquo;ll modify step (3) to:</p>
<ul>
<li>Invoke the <code>KaitaiStruct</code> plugin to selectively make the buffer symbolic</li>
</ul>
<p>To do this we&rsquo;ll add the following directories/files to our S2E environment:</p>
<ul>
<li><code>source/s2e/guest/common/s2e_kaitai_cmd/s2e_kaitai_cmd.c</code></li>
<li><code>source/s2e/guest/common/include/s2e/kaitai/commands.h</code></li>
</ul>
<p>I&rsquo;ll skip steps 1, 2 and 4 because they have already been implemented in
<a href="https://github.com/S2E/guest-tools/blob/master/common/s2ecmd/s2ecmd.c">s2ecmd</a>.
For step 3, we&rsquo;ll create a custom S2E command to invoke a plugin (described
later) that will selectively make the input file symbolic. The command
structure should be placed in
<code>source/s2e/guest/common/include/s2e/kaitai/commands.h</code>. It follows the
standard method for
<a href="https://github.com/S2E/guest-tools/blob/master/common/include/s2e/seed_searcher/commands.h">invoking</a>
<a href="https://github.com/S2E/guest-tools/blob/master/common/include/s2e/monitors/commands/linux.h">S2E</a>
<a href="https://github.com/S2E/guest-tools/blob/master/common/include/s2e/monitors/commands/raw.h">plugins</a>
from the guest:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> S2E_KAITAI_COMMANDS {
</span></span><span style="display:flex;"><span>  KAITAI_MAKE_SYMBOLIC,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> S2E_KAITAI_COMMAND_MAKE_SYMBOLIC {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Pointer to guest memory where the symbolic file has been loaded
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint64_t</span> InputFile;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Size of the input file (in bytes)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint64_t</span> FileSize;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 1 on success, 0 on failure
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint64_t</span> Result;
</span></span><span style="display:flex;"><span>} <span style="color:#a6e22e">__attribute__</span>((packed));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> S2E_KAITAI_COMMAND {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">enum</span> S2E_KAITAI_COMMANDS Command;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> S2E_KAITAI_COMMAND_MAKE_SYMBOLIC MakeSymbolic;
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>} <span style="color:#a6e22e">__attribute__</span>((packed));
</span></span></code></pre></div><p>We can then add the following function to <code>s2e_kaitai_cmd.c</code>. This function
takes a pointer to the file contents (which have been <code>read</code> into a buffer) and
the size of the buffer (determined with <code>lseek</code>), constructs the relevant
command and sends this command to S2E.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">s2e_kaitai_make_symbolic</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint8_t</span> <span style="color:#f92672">*</span>buffer, <span style="color:#66d9ef">unsigned</span> size) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> S2E_KAITAI_COMMAND cmd <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  cmd.Command <span style="color:#f92672">=</span> S2E_KAITAI_MAKE_SYMBOLIC;
</span></span><span style="display:flex;"><span>  cmd.MakeSymbolic.InputFile <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uintptr_t</span>) buffer;
</span></span><span style="display:flex;"><span>  cmd.MakeSymbolic.FileSize <span style="color:#f92672">=</span> size;
</span></span><span style="display:flex;"><span>  cmd.MakeSymbolic.Result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">s2e_invoke_plugin</span>(<span style="color:#e6db74">&#34;KaitaiStruct&#34;</span>, <span style="color:#f92672">&amp;</span>cmd, <span style="color:#66d9ef">sizeof</span>(cmd));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">int</span>) cmd.MakeSymbolic.Result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now we need an S2E plugin to handle this command.</p>
<h3 id="the-kaitaistruct-plugin">The <code>KaitaiStruct</code> plugin</h3>
<p>Let&rsquo;s start with a skeleton plugin (don&rsquo;t forget to add
<code>s2e/Plugins/KaitaiStruct.cpp</code> to the <code>add_library</code> command in
<code>source/s2e/libs2eplugins/src/CMakeLists.txt</code>).</p>
<p>The header file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#ifndef S2E_PLUGINS_KAITAI_STRUCT_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define S2E_PLUGINS_KAITAI_STRUCT_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/CorePlugin.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/Plugins/Core/BaseInstructions.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Forward declare the S2E command from s2e_kaitai_cmd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">S2E_KAITAI_COMMAND</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> s2e {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> plugins {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// In addition to extending the basic Plugin class, we must also implement the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// IPluginInvoker to handle custom S2E commands
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">KaitaiStruct</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Plugin, <span style="color:#66d9ef">public</span> IPluginInvoker {
</span></span><span style="display:flex;"><span>  S2E_PLUGIN
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  KaitaiStruct(S2E <span style="color:#f92672">*</span>s2e) <span style="color:#f92672">:</span> Plugin(s2e) { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">initialize</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The method from IPluginInvoker that we must implement to respond to a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// custom command. This method takes the current S2E state, a pointer to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// the custom command object and the size of the custom command object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">handleOpcodeInvocation</span>(S2EExecutionState <span style="color:#f92672">*</span>state,
</span></span><span style="display:flex;"><span>                                      <span style="color:#66d9ef">uint64_t</span> guestDataPtr,
</span></span><span style="display:flex;"><span>                                      <span style="color:#66d9ef">uint64_t</span> guestDataSize);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The name of the Lua function that will run the Kaitai Struct parser
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>string m_kaitaiParserFunc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// handleOpcodeInvocation will call this method to actually invoke the Lua function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">handleMakeSymbolic</span>(S2EExecutionState <span style="color:#f92672">*</span>state, <span style="color:#66d9ef">const</span> S2E_KAITAI_COMMAND <span style="color:#f92672">&amp;</span>command);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} <span style="color:#75715e">// namespace plugins
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#75715e">// namespace s2e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><p>And the CPP file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// From source/s2e/guest/common/include
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/kaitai/commands.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/ConfigFile.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/S2E.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/Utils.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;KaitaiStruct.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> s2e {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> plugins {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>S2E_DEFINE_PLUGIN(
</span></span><span style="display:flex;"><span>  KaitaiStruct,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Combine S2E and Kaitai Struct&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Dependencies
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#e6db74">&#34;LuaBindings&#34;</span>); <span style="color:#75715e">// Reuse the existing Lua binding code from the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                  <span style="color:#75715e">// function/instruction annotation plugins
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> KaitaiStruct<span style="color:#f92672">::</span>initialize() {
</span></span><span style="display:flex;"><span>  m_kaitaiParserFunc <span style="color:#f92672">=</span> s2e()<span style="color:#f92672">-&gt;</span>getConfig()<span style="color:#f92672">-&gt;</span>getString(
</span></span><span style="display:flex;"><span>    getConfigKey() <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;.parser&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> KaitaiStruct<span style="color:#f92672">::</span>handleMakeSymbolic(S2EExecutionState <span style="color:#f92672">*</span>state,
</span></span><span style="display:flex;"><span>                                      <span style="color:#66d9ef">const</span> S2E_KAITAI_COMMAND <span style="color:#f92672">&amp;</span>command) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// We&#39;ll finish this later
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> KaitaiStruct<span style="color:#f92672">::</span>handleOpcodeInvocation(S2EExecutionState <span style="color:#f92672">*</span>state,
</span></span><span style="display:flex;"><span>                                          <span style="color:#66d9ef">uint64_t</span> guestDataPtr,
</span></span><span style="display:flex;"><span>                                          <span style="color:#66d9ef">uint64_t</span> guestDataSize) {
</span></span><span style="display:flex;"><span>  S2E_KAITAI_COMMAND cmd;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 1. Validate the received command
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (guestDataSize <span style="color:#f92672">!=</span> <span style="color:#66d9ef">sizeof</span>(cmd)) {
</span></span><span style="display:flex;"><span>    getWarningsStream(state) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;S2E_KAITAI_COMMAND: Mismatched command &#34;</span>
</span></span><span style="display:flex;"><span>                             <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;structure size &#34;</span> <span style="color:#f92672">&lt;&lt;</span> guestDataSize <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 2. Read the command
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>state<span style="color:#f92672">-&gt;</span>mem()<span style="color:#f92672">-&gt;</span>read(guestDataPtr, <span style="color:#f92672">&amp;</span>cmd, guestDataSize)) {
</span></span><span style="display:flex;"><span>    getWarningsStream(state) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;S2E_KAITAI_COMMAND: Failed to read &#34;</span>
</span></span><span style="display:flex;"><span>                             <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;command</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 3. Handle the command
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">switch</span> (cmd.Command) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> KAITAI_MAKE_SYMBOLIC: {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">bool</span> success <span style="color:#f92672">=</span> handleMakeSymbolic(state, cmd);
</span></span><span style="display:flex;"><span>      cmd.MakeSymbolic.Result <span style="color:#f92672">=</span> success <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// Write the result back to the guest
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>state<span style="color:#f92672">-&gt;</span>mem()<span style="color:#f92672">-&gt;</span>write(guestDataPtr, cmd, guestDataSize)) {
</span></span><span style="display:flex;"><span>        getWarningsStream(State) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;S2E_KAITAI_COMMAND: Failed to &#34;</span>
</span></span><span style="display:flex;"><span>                                 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; write result to guest</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>        exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>      getWarningsStream(state) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;S2E_KAITAI_COMMAND: Invalid command &#34;</span>
</span></span><span style="display:flex;"><span>                               <span style="color:#f92672">&lt;&lt;</span> hexval(cmd.Command) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>      exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} <span style="color:#75715e">// namespace plugins
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#75715e">// namespace s2e
</span></span></span></code></pre></div><p>Our plugin has only one dependency: the <code>LuaBindings</code> plugin. This plugin
configures S2E&rsquo;s Lua interpreter and allows us to call Lua code in the S2E
configuration file.</p>
<p>The <code>handleOpcodeInvocation</code> method follows a similar pattern to other plugins
that implement <code>IPluginInvoker</code> (e.g.
<a href="https://github.com/S2E/libs2eplugins/blob/master/src/s2e/Plugins/Models/FunctionModels.cpp">FunctionModels</a>
and <a href="https://github.com/S2E/libs2eplugins/blob/master/src/s2e/Plugins/OSMonitors/Linux/BaseLinuxMonitor.h">LinuxMonitor</a>):</p>
<ol>
<li>Validate the received command by checking its size.</li>
<li>Read the command. Since the command is issued by the guest, it resides in
guest memory. Nothing in our command should be symbolic (remember it only
contains the input file&rsquo;s start address and size), so we can read this
memory concretely.</li>
<li>Handle the command. In this case we call another function (that we&rsquo;ll
discuss shortly) to invoke the Lua interpreter to parse the input file.</li>
<li>Indicate success/failure to the guest. We do this by setting a &ldquo;return code&rdquo;
in the command structure and writing the command back into guest memory.</li>
</ol>
<p>Let&rsquo;s finish <code>handleMakeSymbolic</code>. Since we are working with Lua code we must
include some extra header files:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/Plugins/Lua/Lua.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;s2e/Plugins/Lua/LuaS2EExecutionState.h&gt;</span><span style="color:#75715e">
</span></span></span></code></pre></div><p>And finally the function implementation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> KaitaiStruct<span style="color:#f92672">::</span>handleMakeSymbolic(S2EExecutionState <span style="color:#f92672">*</span>state,
</span></span><span style="display:flex;"><span>                                      <span style="color:#66d9ef">const</span> S2E_KAITAI_COMMAND <span style="color:#f92672">&amp;</span>command) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint64_t</span> addr <span style="color:#f92672">=</span> command.MakeSymbolic.InputFile;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint64_t</span> size <span style="color:#f92672">=</span> command.MakeSymbolic.FileSize;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span> data(size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Read the input file&#39;s contents from guest memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>state<span style="color:#f92672">-&gt;</span>mem()<span style="color:#f92672">-&gt;</span>read(addr, data.data(), <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">uint8_t</span>) <span style="color:#f92672">*</span> size)) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Get the Lua interpreter&#39;s state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  lua_State <span style="color:#f92672">*</span>L <span style="color:#f92672">=</span> s2e()<span style="color:#f92672">-&gt;</span>getConfig()<span style="color:#f92672">-&gt;</span>getState();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Wrap the current S2E execution state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  LuaS2EExecutionState <span style="color:#a6e22e">luaS2EState</span>(state);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Turn the input file into a Lua string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  luaL_Buffer luaBuff;
</span></span><span style="display:flex;"><span>  luaL_buffinit(L, <span style="color:#f92672">&amp;</span>luaBuff);
</span></span><span style="display:flex;"><span>  luaL_addlstring(<span style="color:#f92672">&amp;</span>luaBuff, (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>) data.data(), <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">uint8_t</span>) <span style="color:#f92672">*</span> size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Set up our function call on Lua&#39;s virtual stack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  lua_getglobal(L, m_kaitaiParserFunc.c_str());
</span></span><span style="display:flex;"><span>  Lunar<span style="color:#f92672">&lt;</span>LuaS2EExecutionState<span style="color:#f92672">&gt;::</span>push(L, <span style="color:#f92672">&amp;</span>luaS2EState);
</span></span><span style="display:flex;"><span>  lua_pushinteger(L, addr);
</span></span><span style="display:flex;"><span>  luaL_pushresult(<span style="color:#f92672">&amp;</span>luaBuff);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Call our Kaitai Struct parser function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  lua_call(L, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Hopefully this is relatively easy to understand (see
<a href="https://www.lua.org/manual/5.3/manual.html#4.8">here</a> for more information on
Lua&rsquo;s C API). First we read the input file into a Lua string for the Kaitai
Struct parser. Then, we call the Kaitai Struct parser function (which we&rsquo;ll
define in the following section).</p>
<p>We must set up the parser function&rsquo;s arguments before we can call it. A virtual
stack is used to pass values to Lua functions. The first item pushed onto this
stack is always the function name. Our parser function will be defined in Lua&rsquo;s
global namespace (for simplicity), so we can use <code>lua_getglobal</code> to retrieve
this function from the S2E configuration file and push it onto the stack. We
then push:</p>
<ol>
<li>The current S2E execution state;</li>
<li>The input file&rsquo;s start address (in guest memory); and</li>
<li>The contents of the input file (as a string).</li>
</ol>
<p>Now all that&rsquo;s left to do is to implement this parser in the S2E configuration
file.</p>
<h3 id="lua-scripts">Lua scripts</h3>
<p>First, we need to compile a Kaitai Struct format definition into a Lua parser.
Since we are going to be experimenting with readelf, let&rsquo;s create our readelf
project now and get the ELF definition from the Kaitai Struct gallery:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># Create the S2E project</span>
</span></span><span style="display:flex;"><span>s2e new_project -n readelf_kaitai readelf -h @@
</span></span><span style="display:flex;"><span>cd projects/readelf_kaitai
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Get the ELF Kaitai Struct definition and compile it</span>
</span></span><span style="display:flex;"><span>wget https://raw.githubusercontent.com/kaitai-io/kaitai_struct_formats/master/executable/elf.ksy
</span></span><span style="display:flex;"><span>ksc -t lua elf.ksy
</span></span></code></pre></div><p>This will generate <code>elf.lua</code>. Now let&rsquo;s try it out on a testcase from
<a href="http://lcamtuf.coredump.cx/afl/">AFL</a>. If you don&rsquo;t already have it, you&rsquo;ll
also need Kaitai Struct&rsquo;s <a href="https://github.com/kaitai-io/kaitai_struct_lua_runtime">Lua
runtime</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># Get Kaitai Struct&#39;s Lua runtime</span>
</span></span><span style="display:flex;"><span>git clone https://github.com/kaitai-io/kaitai_struct_lua_runtime lua_runtime
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Get the ELF testcase</span>
</span></span><span style="display:flex;"><span>wget https://raw.githubusercontent.com/mirrorer/afl/master/testcases/others/elf/small_exec.elf
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Parse the testcase</span>
</span></span><span style="display:flex;"><span>lua5.3 - <span style="color:#e6db74">&lt;&lt; EOF
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">package.path = package.path .. &#34;;./lua_runtime/?.lua&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">require(&#34;elf&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">inp = assert(io.open(&#34;small_exec.elf&#34;, &#34;rb&#34;))
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">testcase = Elf(KaitaiStream(inp))
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">print(&#34;testcase e_ehsize: &#34; .. testcase.header.e_ehsize)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EOF</span>
</span></span></code></pre></div><p>You should see a header size of 52 bytes (you can run
<code>readelf -h small_exec.elf</code> to confirm).</p>
<p>I originally stated that we&rsquo;d be using Kaitai Struct&rsquo;s processing spec to
target specific file attributes to make symbolic. Let&rsquo;s define this processing
spec in <code>lua_runtime/s2e_make_symbolic.lua</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">local</span> class <span style="color:#f92672">=</span> require(<span style="color:#e6db74">&#34;class&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>S2eMakeSymbolic <span style="color:#f92672">=</span> class.class()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">S2eMakeSymbolic</span>:<span style="color:#a6e22e">_init</span>(s2e_state, start_addr, curr_pos, name)
</span></span><span style="display:flex;"><span>  self._state <span style="color:#f92672">=</span> s2e_state
</span></span><span style="display:flex;"><span>  self._addr <span style="color:#f92672">=</span> start_addr <span style="color:#f92672">+</span> curr_pos
</span></span><span style="display:flex;"><span>  self._name <span style="color:#f92672">=</span> name
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">S2eMakeSymbolic</span>:<span style="color:#a6e22e">decode</span>(data)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> mem <span style="color:#f92672">=</span> self._state:mem()
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> size <span style="color:#f92672">=</span> data:len()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- The decode routine is called after the data has already been read, so we</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- must return to the start of the data in order to make it symbolic</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> addr <span style="color:#f92672">=</span> self._addr <span style="color:#f92672">-</span> size
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mem:makeConcolic(addr, size, self._name)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- Return the data unchanged</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> data
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>All we&rsquo;ve done here is define a new class, <code>S2eMakeSymbolic</code>, with a
constructor (<code>_init</code>) and a <code>decode</code> method. The constructor takes the
following arguments:</p>
<ol>
<li>The current S2E execution state;</li>
<li>The input file&rsquo;s start address (in guest memory);</li>
<li>The current position of the parser. This plus the start address tell us the
absolute memory address to make symbolic; and</li>
<li>The name of the symbolic variable.</li>
</ol>
<p>The ELF parser will automatically call <code>decode</code> when it encounters an attribute
with the <code>s2e_make_symbolic</code> processing spec applied. However, the <code>decode</code>
method is called <em>after</em> the data has been read from the input file, so we must
compensate for this when we make the data symbolic (by subtracting the size
of the memory region we just read).</p>
<p>Let&rsquo;s make something symbolic. We&rsquo;ll choose something simple for now — the ELF
header&rsquo;s <code>e_machine</code> field. In <code>elf.ksy</code> the <code>e_machine</code> field is defined under
the <code>endian_elf</code> type:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e"># The original definition of the e_machine field</span>
</span></span><span style="display:flex;"><span>- <span style="color:#f92672">id</span>: <span style="color:#ae81ff">machine</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">u2</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">enum</span>: <span style="color:#ae81ff">machine</span>
</span></span></code></pre></div><p>Processing specs can only be applied to byte arrays, so we must replace the
<code>type</code> specification with a byte array&rsquo;s <code>size</code> specification. Because the
original type was an unsigned 2-byte value, we can simply treat the <code>machine</code>
as a byte array of size 2. We must also remove the enum mapping, otherwise
<code>ksc</code> will raise a compilation error when it tries to apply an enum to a byte
array.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e"># Redefinition of the e_machine field to make it symbolic</span>
</span></span><span style="display:flex;"><span>- <span style="color:#f92672">id</span>: <span style="color:#ae81ff">machine</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">size</span>: <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">process</span>: <span style="color:#ae81ff">s2e_make_symbolic(s2e_state, start_addr, _io.pos, &#34;machine&#34;)</span>
</span></span></code></pre></div><p>Finally, we must propagate two additional arguments — the S2E execution state
and the input file&rsquo;s start address — from the parser&rsquo;s constructor to
<code>s2e_make_symbolic</code>. We do this with the &ldquo;params spec&rdquo;. The <code>machine</code> attribute
is nested under the <code>endian_elf</code> and top-level <code>elf</code> types, so the following
params spec must be defined under both.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">params</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">s2e_state</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">start_addr</span>
</span></span></code></pre></div><p>We must also modify the <code>header</code>&rsquo;s type from <code>endian_elf</code> to
<code>endian_elf(s2e_state, start_addr)</code>. This ensures that the two arguments are
passed to <code>endian_elf</code>&rsquo;s constructor. (If this is all getting a bit confusing,
remember that the full source code is available
<a href="https://github.com/adrianherrera/kaitai-s2e">here</a>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e"># The original header&#39;s type</span>
</span></span><span style="display:flex;"><span>- <span style="color:#f92672">id</span>: <span style="color:#ae81ff">header</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">endian_elf</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Redefined to propagate the S2E execution state and input file&#39;s start address</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># to the endian_elf type</span>
</span></span><span style="display:flex;"><span>- <span style="color:#f92672">id</span>: <span style="color:#ae81ff">header</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">endian_elf(s2e_state, start_addr)</span>
</span></span></code></pre></div><p>Now recompile <code>elf.ksy</code>. If you open <code>elf.lua</code> you should see that the
constructor (<code>Elf:_init</code>) now takes <code>s2e_state</code> and <code>start_addr</code> as its first
two arguments. These arguments are saved and later propagated to the
<code>S2eMakeSymbolic</code> constructor via the <code>Elf.EndianElf</code> constructor.</p>
<p>All that&rsquo;s left to do is write a small function in our S2E configuration file
that will instantiate and run our parser. This function is invoked by the
<code>handleMakeSymbolic</code> method in the <code>KaitaiStruct</code> plugin.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>package.path <span style="color:#f92672">=</span> package.path <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;;./lua_runtime/?.lua&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> stringstream <span style="color:#f92672">=</span> require(<span style="color:#e6db74">&#34;string_stream&#34;</span>)
</span></span><span style="display:flex;"><span>require(<span style="color:#e6db74">&#34;elf&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">make_symbolic_elf</span>(state, start_addr, buffer)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> ss <span style="color:#f92672">=</span> stringstream(buffer)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- This will kick-start the parser. We don&#39;t care about the final result</span>
</span></span><span style="display:flex;"><span>  Elf(state, start_addr, KaitaiStream(ss))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Enable and configure the necessary plugins</span>
</span></span><span style="display:flex;"><span>add_plugin(<span style="color:#e6db74">&#34;LuaBindings&#34;</span>)
</span></span><span style="display:flex;"><span>add_plugin(<span style="color:#e6db74">&#34;KaitaiStruct&#34;</span>)
</span></span><span style="display:flex;"><span>pluginsConfig.KaitaiStruct <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  parser <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;make_symbolic_elf&#34;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And we&rsquo;re done!</p>
<h2 id="experimenting-with-readelf">Experimenting with readelf</h2>
<p>We&rsquo;re finally ready to experiment with readelf. Before we do, modify the S2E
configuration file so that only the following plugins are enabled:</p>
<ul>
<li>BaseInstructions</li>
<li>HostFiles</li>
<li>Vmi</li>
<li>TranslationBlockCoverage</li>
<li>ModuleExecutionDetector</li>
<li>ForkLimiter</li>
<li>ProcessExecutionDetector</li>
<li>LinuxMonitor</li>
</ul>
<p>We&rsquo;ll also have to modify <code>bootstrap.sh</code>. Under <code>${S2EGET} &quot;readelf&quot;</code> add
<code>${S2EGET} &quot;small_exec.elf&quot;</code> to copy our testcase to the guest. In the
<code>prepare_inputs</code> function replace <code>truncate -s 256 ${SYMB_FILE}</code> with
<code>cp small_exec.elf ${SYMB_FILE}</code> to use our testcase. We won&rsquo;t replace the
<code>symbfile</code> command yet; let&rsquo;s get an initial idea of how readelf performs on a
fully symbolic file.</p>
<p>Run S2E for a minute or so before killing it. You should see many forked states
(I forked 136 states). Let&rsquo;s generate code coverage information:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># The actual disassembler isn&#39;t important</span>
</span></span><span style="display:flex;"><span>s2e coverage basic_block --disassembler<span style="color:#f92672">=</span>binaryninja readelf_kaitai
</span></span></code></pre></div><p>Where are these forks occurring? Many are in libc, due to readelf calling
<code>printf</code> on symbolic data. What about the forks that occur in readelf? The
following images show snippets of two functions from readelf:
<code>process_section_headers</code> and <code>init_dwarf_regnames</code>. Green basic blocks
indicate blocks that were executed by S2E. Fork points have also been annotated
with their constraints (in KLEE&rsquo;s
<a href="https://klee.github.io/docs/kquery/">KQuery</a> format):</p>
<figure><a href="/img/readelf-process_section_headers.png"><img src="/img/readelf-process_section_headers.png"
    alt="readelf proccess_section_headers code coverage"></a><figcaption>
      <p>readelf&rsquo;s process_section_headers code coverage</p>
    </figcaption>
</figure>

<figure><a href="/img/readelf-init_dwarf_regnames.png"><img src="/img/readelf-init_dwarf_regnames.png"
    alt="readelf init_dwarf_regnames code coverage"></a><figcaption>
      <p>readelf&rsquo;s init_dwarf_regnames code coverage</p>
    </figcaption>
</figure>

<p>Forking also occurs when checking:</p>
<ul>
<li>If the input file is an archive</li>
<li>The data encoding (little endian or big endian)</li>
<li>The section header table&rsquo;s file offset</li>
<li>If each section&rsquo;s <code>sh_link</code> and <code>sh_info</code> values are valid</li>
</ul>
<p>And at many other locations! Now let&rsquo;s try and reduce forking to only those
program paths that relate to the ELF header&rsquo;s <code>e_machine</code> field. Edit
<code>bootstrap.sh</code> and replace <code>${S2ECMD} symbfile ${SYMB_FILE}</code> with
<code>./s2e_kaitai_cmd ${SYMB_FILE}</code>. Now rerun S2E for a minute. During my run,
forking was limited to the <code>get_machine_name</code> and <code>init_dwarf_regnames</code>
functions, both of which have switch statements based on the value of
<code>e_machine</code>. Success!</p>
<p>Let&rsquo;s try and target a different field in the ELF file — the section header&rsquo;s
<code>sh_type</code>. Unlike the <code>e_machine</code> field, which only occurs once in the ELF
file, the <code>sh_type</code> can occur multiple times throughout the file (depending on
the number of sections in the ELF file).</p>
<p>Once again, we must propagate the S2E execution state and input file&rsquo;s start
address to the appropriate attribute in the ELF declaration. This time we must
add the params spec to the <code>section_header</code> type. The <code>type</code> attribute is
defined as an unsigned 4-byte enum, so we must change this to a 4 byte array so
that we can apply <code>s2e_make_symbolic</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e"># Elf(32|64)_Shdr</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">section_header</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">params</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">s2e_state</span>
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">start_addr</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">seq</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># sh_name</span>
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">name_offset</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">type</span>: <span style="color:#ae81ff">u4</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># sh_type</span>
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">type</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">size</span>: <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">process</span>: <span style="color:#ae81ff">s2e_make_symbolic(s2e_state, start_addr, _io.pos, &#34;sh_type&#34;)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ...</span>
</span></span></code></pre></div><p>We must also ensure that these two arguments are passed to the
<code>SectionHeader</code>&rsquo;s constructor. The section header can be found under the
<code>section_headers</code> instance:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e"># The original section_headers</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">section_headers</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">pos</span>: <span style="color:#ae81ff">section_header_offset</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">repeat</span>: <span style="color:#ae81ff">expr</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">repeat-expr</span>: <span style="color:#ae81ff">qty_section_header</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">size</span>: <span style="color:#ae81ff">section_header_entry_size</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">section_header</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Redefined for symbolic execution</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">section_headers</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">pos</span>: <span style="color:#ae81ff">section_header_offset</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">repeat</span>: <span style="color:#ae81ff">expr</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">repeat-expr</span>: <span style="color:#ae81ff">qty_section_header</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">size</span>: <span style="color:#ae81ff">section_header_entry_size</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">section_header(s2e_state, start_addr)</span>
</span></span></code></pre></div><p>Notice that <code>section_headers</code> is declared as an
&ldquo;<a href="http://doc.kaitai.io/ksy_reference.html#spec-instance">instance spec</a>&rdquo;. This
means that <code>section_headers</code> compiles to a function that will only parse the
section header on demand. Therefore we must access the <code>section_headers</code> to
force them to be parsed. To do this we must modify the <code>make_elf_symbolic</code>
function in <code>s2e-config.lua</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">make_symbolic_elf</span>(state, start_addr, buffer)
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- ...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- This will kick-start the parser. However, now we do care about the final</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- result, because we must access the section headers to force them to be</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- parsed</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> elf_file <span style="color:#f92672">=</span> Elf(state, start_addr, KaitaiStream(ss))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- This will kick-start the section header parser</span>
</span></span><span style="display:flex;"><span>  _ <span style="color:#f92672">=</span> elf_file.header.section_headers
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Run <code>ksc</code> to regenerate <code>elf.lua</code>. Before we rerun S2E, let&rsquo;s take a look at
<code>elf.lua</code>. In particular, the parsing of the section headers in the
<code>section_headers</code>&rsquo; <code>get</code> method:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Elf</span>.<span style="color:#a6e22e">EndianElf</span>.<span style="color:#a6e22e">property</span>.<span style="color:#a6e22e">section_headers</span>:<span style="color:#a6e22e">get</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- ...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, self.qty_section_header <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    self._raw__m_section_headers[i] <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">\</span>
</span></span><span style="display:flex;"><span>      self._io:read_bytes(self.section_header_entry_size)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> _io <span style="color:#f92672">=</span> KaitaiStream(stringstream(self._raw__m_section_headers[i]))
</span></span><span style="display:flex;"><span>    self._m_section_headers[i] <span style="color:#f92672">=</span> Elf.EndianElf.SectionHeader(self.s2e_state,
</span></span><span style="display:flex;"><span>                                                             self.start_addr,
</span></span><span style="display:flex;"><span>                                                             _io, self,
</span></span><span style="display:flex;"><span>                                                             self._root,
</span></span><span style="display:flex;"><span>                                                             self._is_le)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- ...</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Notice that <code>ksc</code> creates a local variable, <code>_io</code>, that gets passed to the
<code>SectionHeader</code> constructor. This <code>_io</code> variable contains the raw data that
will eventually be transformed into a <code>SectionHeader</code> object. Unfortunately,
this causes a problem for the <code>s2e_make_symbolic</code> processing spec.</p>
<p>Recall that the parser&rsquo;s current position (<code>_io.pos</code>) is passed to the
<code>s2e_make_symbolic</code> processing spec. Unfortunately, when the local <code>_io</code> stream
is created, this position is reset to zero, so using this position would result
in an incorrect memory address being made symbolic. Fortunately, we can fix
this with a small change to the Lua code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, self.qty_section_header <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- Get the absolute start address of the section header before it is parsed</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> _sec_hdr_start_addr <span style="color:#f92672">=</span> self.start_addr <span style="color:#f92672">+</span> self._io:pos()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  self._raw__m_section_headers[i] <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">\</span>
</span></span><span style="display:flex;"><span>    self._io:read_bytes(self.section_header_entry_size)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> _io <span style="color:#f92672">=</span> KaitaiStream(stringstream(self._raw__m_section_headers[i]))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- Use the section header&#39;s start address instead of the ELF&#39;s start address</span>
</span></span><span style="display:flex;"><span>  self._m_section_headers[i] <span style="color:#f92672">=</span> Elf.EndianElf.SectionHeader(self.s2e_state,
</span></span><span style="display:flex;"><span>                                                           _sec_hdr_start_addr,
</span></span><span style="display:flex;"><span>                                                           _io, self,
</span></span><span style="display:flex;"><span>                                                           self._root,
</span></span><span style="display:flex;"><span>                                                           self._is_le)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Yes, hacking the generated Lua code is kind of disgusting. However, it ensures
that the correct memory address is made symbolic. When I reran S2E, forking was
limited to <code>sh_type</code> comparisons in the <code>process_section_headers</code> function.
Success again!</p>
<h2 id="conclusions-and-future-work">Conclusions and future work</h2>
<p>In this post I&rsquo;ve looked at how we can perform more targeted symbolic execution
of file parsers. Rather than giving the parser a fully-symbolic input file
(which quickly leads to path explosion), we can use Kaitai Struct to target
specific parts of the input file to make symbolic. While this approach seems to
work, there are a few problems associated with it.</p>
<p>First, it relies on the user having a valid <em>seed</em> file to perform symbolic
execution with. This seed file must also contain data for the part of the
parser that we wish to exercise. For example, let&rsquo;s assume that we wanted to
apply this technique to a PNG parser. If we took
<a href="http://formats.kaitai.io/png/index.html">this</a> definition of a PNG file and
wanted to see what happened when the <code>bkgd_truecolor</code> attribute was made
symbolic, our PNG seed would also have to contain a <a href="http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.bKGD">background color
chunk</a>.
Otherwise  our parser would have nothing to make symbolic.</p>
<p>For similar reasons, we cannot just use the &ldquo;empty&rdquo; symbolic file that the S2E
bootstrap script creates. Why? Because when the Kaitai Struct parser executes,
it runs on concrete data contained in the file. The default symbolic file that
S2E creates is filled with <code>NULL</code> characters, so the parser would fail
instantly. Wouldn&rsquo;t it be cool if we could <a href="http://lcamtuf.blogspot.com.au/2014/11/pulling-jpegs-out-of-thin-air.html">pull files out of thin
air</a>?</p>
<p>Other issues stem from how we are using Kaitai Struct. This is not the fault of
Kaitai Struct; in fact the Kaitai Struct
<a href="http://doc.kaitai.io/faq.html">FAQ</a> explicitly states that the generated
parsers are not designed for this model of &ldquo;event-based&rdquo; parsing. We could have
modified <code>ksc</code> to generate code that required fewer manual modifications (e.g.
automatically generate the params spec, use non-lazy instance specs, always
keep track of the parser&rsquo;s absolute position, etc.), however for simplicity I
wanted to leave Kaitai Struct &ldquo;as is&rdquo;.</p>
<p>What about non file-based symbolic execution? For example, in my <a href="https://adrianherrera.github.io/posts/google-ctf-2016/">previous</a> post I showed how to use S2E to solve a CTF
challenge that used a command-line string as input. The approach described in
this post would not help in solving this CTF challenge. However, there is no
reason why the <code>KaitaiStruct</code> plugin could not be extended to work on
command-line strings. For example, we could define the CTF challenge&rsquo;s input
string in Kaitai Struct as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">meta</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">id</span>: <span style="color:#ae81ff">ctf-input</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">title</span>: <span style="color:#ae81ff">Google CTF input format</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ks-version</span>: <span style="color:#ae81ff">0.8</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">seq</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">prefix</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">size</span>: <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">contents</span>: <span style="color:#e6db74">&#34;CTF{&#34;</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">to_solve</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">size</span>: <span style="color:#ae81ff">63</span> <span style="color:#75715e"># total length of 67 bytes minus the 4 byte prefix</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">process</span>: <span style="color:#ae81ff">s2e_make_symbolic(s2e_state, start_addr, _io.pos, &#34;to_solve&#34;)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">params</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">s2e_state</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">start_addr</span>
</span></span></code></pre></div><p>With some additional code we could run this parser on the input string to make
only the last 63 bytes symbolic. This would allow us to remove the
<code>onSymbolicVariableCreation</code> method from the S2E
<a href="https://gist.github.com/adrianherrera/397dc68918374c81cf63e53e659bd083">plugin</a>.</p>
<p>Despite these problems, combining S2E and Kaitai Struct seemed to work fairly
well for the work that I was doing (although your mileage may vary!). We could
probably get around these problems with a bit more work (and a lot more code).
However, I think I&rsquo;ll save that for a future post :)</p>
]]></description>
      
    </item>
    
    
  </channel>
</rss>
